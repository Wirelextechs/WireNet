var md = t => {
    throw TypeError(t)
}
;
var Ka = (t, e, r) => e.has(t) || md("Cannot " + r);
var _ = (t, e, r) => (Ka(t, e, "read from private field"),
r ? r.call(t) : e.get(t))
  , G = (t, e, r) => e.has(t) ? md("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r)
  , $ = (t, e, r, n) => (Ka(t, e, "write to private field"),
n ? n.call(t, r) : e.set(t, r),
r)
  , ee = (t, e, r) => (Ka(t, e, "access private method"),
r);
var qi = (t, e, r, n) => ({
    set _(s) {
        $(t, e, s, r)
    },
    get _() {
        return _(t, e, n)
    }
});
function jf(t, e) {
    for (var r = 0; r < e.length; r++) {
        const n = e[r];
        if (typeof n != "string" && !Array.isArray(n)) {
            for (const s in n)
                if (s !== "default" && !(s in t)) {
                    const i = Object.getOwnPropertyDescriptor(n, s);
                    i && Object.defineProperty(t, s, i.get ? i : {
                        enumerable: !0,
                        get: () => n[s]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const s of document.querySelectorAll('link[rel="modulepreload"]'))
        n(s);
    new MutationObserver(s => {
        for (const i of s)
            if (i.type === "childList")
                for (const o of i.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && n(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function r(s) {
        const i = {};
        return s.integrity && (i.integrity = s.integrity),
        s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy),
        s.crossOrigin === "use-credentials" ? i.credentials = "include" : s.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin",
        i
    }
    function n(s) {
        if (s.ep)
            return;
        s.ep = !0;
        const i = r(s);
        fetch(s.href, i)
    }
}
)();
var In = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Tf(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
function Ui(t) {
    if (t.__esModule)
        return t;
    var e = t.default;
    if (typeof e == "function") {
        var r = function n() {
            return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        };
        r.prototype = e.prototype
    } else
        r = {};
    return Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    Object.keys(t).forEach(function(n) {
        var s = Object.getOwnPropertyDescriptor(t, n);
        Object.defineProperty(r, n, s.get ? s : {
            enumerable: !0,
            get: function() {
                return t[n]
            }
        })
    }),
    r
}
var Pf = {
    exports: {}
}
  , ba = {}
  , Of = {
    exports: {}
}
  , Y = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Fi = Symbol.for("react.element")
  , Gy = Symbol.for("react.portal")
  , Vy = Symbol.for("react.fragment")
  , Hy = Symbol.for("react.strict_mode")
  , qy = Symbol.for("react.profiler")
  , Ky = Symbol.for("react.provider")
  , Qy = Symbol.for("react.context")
  , Jy = Symbol.for("react.forward_ref")
  , Xy = Symbol.for("react.suspense")
  , Yy = Symbol.for("react.memo")
  , Zy = Symbol.for("react.lazy")
  , yd = Symbol.iterator;
function ev(t) {
    return t === null || typeof t != "object" ? null : (t = yd && t[yd] || t["@@iterator"],
    typeof t == "function" ? t : null)
}
var Rf = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , Af = Object.assign
  , If = {};
function Rs(t, e, r) {
    this.props = t,
    this.context = e,
    this.refs = If,
    this.updater = r || Rf
}
Rs.prototype.isReactComponent = {};
Rs.prototype.setState = function(t, e) {
    if (typeof t != "object" && typeof t != "function" && t != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, t, e, "setState")
}
;
Rs.prototype.forceUpdate = function(t) {
    this.updater.enqueueForceUpdate(this, t, "forceUpdate")
}
;
function Nf() {}
Nf.prototype = Rs.prototype;
function rc(t, e, r) {
    this.props = t,
    this.context = e,
    this.refs = If,
    this.updater = r || Rf
}
var nc = rc.prototype = new Nf;
nc.constructor = rc;
Af(nc, Rs.prototype);
nc.isPureReactComponent = !0;
var vd = Array.isArray
  , Lf = Object.prototype.hasOwnProperty
  , sc = {
    current: null
}
  , Df = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function $f(t, e, r) {
    var n, s = {}, i = null, o = null;
    if (e != null)
        for (n in e.ref !== void 0 && (o = e.ref),
        e.key !== void 0 && (i = "" + e.key),
        e)
            Lf.call(e, n) && !Df.hasOwnProperty(n) && (s[n] = e[n]);
    var a = arguments.length - 2;
    if (a === 1)
        s.children = r;
    else if (1 < a) {
        for (var l = Array(a), c = 0; c < a; c++)
            l[c] = arguments[c + 2];
        s.children = l
    }
    if (t && t.defaultProps)
        for (n in a = t.defaultProps,
        a)
            s[n] === void 0 && (s[n] = a[n]);
    return {
        $$typeof: Fi,
        type: t,
        key: i,
        ref: o,
        props: s,
        _owner: sc.current
    }
}
function tv(t, e) {
    return {
        $$typeof: Fi,
        type: t.type,
        key: e,
        ref: t.ref,
        props: t.props,
        _owner: t._owner
    }
}
function ic(t) {
    return typeof t == "object" && t !== null && t.$$typeof === Fi
}
function rv(t) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + t.replace(/[=:]/g, function(r) {
        return e[r]
    })
}
var wd = /\/+/g;
function Qa(t, e) {
    return typeof t == "object" && t !== null && t.key != null ? rv("" + t.key) : e.toString(36)
}
function _o(t, e, r, n, s) {
    var i = typeof t;
    (i === "undefined" || i === "boolean") && (t = null);
    var o = !1;
    if (t === null)
        o = !0;
    else
        switch (i) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (t.$$typeof) {
            case Fi:
            case Gy:
                o = !0
            }
        }
    if (o)
        return o = t,
        s = s(o),
        t = n === "" ? "." + Qa(o, 0) : n,
        vd(s) ? (r = "",
        t != null && (r = t.replace(wd, "$&/") + "/"),
        _o(s, e, r, "", function(c) {
            return c
        })) : s != null && (ic(s) && (s = tv(s, r + (!s.key || o && o.key === s.key ? "" : ("" + s.key).replace(wd, "$&/") + "/") + t)),
        e.push(s)),
        1;
    if (o = 0,
    n = n === "" ? "." : n + ":",
    vd(t))
        for (var a = 0; a < t.length; a++) {
            i = t[a];
            var l = n + Qa(i, a);
            o += _o(i, e, r, l, s)
        }
    else if (l = ev(t),
    typeof l == "function")
        for (t = l.call(t),
        a = 0; !(i = t.next()).done; )
            i = i.value,
            l = n + Qa(i, a++),
            o += _o(i, e, r, l, s);
    else if (i === "object")
        throw e = String(t),
        Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return o
}
function Ki(t, e, r) {
    if (t == null)
        return t;
    var n = []
      , s = 0;
    return _o(t, n, "", "", function(i) {
        return e.call(r, i, s++)
    }),
    n
}
function nv(t) {
    if (t._status === -1) {
        var e = t._result;
        e = e(),
        e.then(function(r) {
            (t._status === 0 || t._status === -1) && (t._status = 1,
            t._result = r)
        }, function(r) {
            (t._status === 0 || t._status === -1) && (t._status = 2,
            t._result = r)
        }),
        t._status === -1 && (t._status = 0,
        t._result = e)
    }
    if (t._status === 1)
        return t._result.default;
    throw t._result
}
var rt = {
    current: null
}
  , So = {
    transition: null
}
  , sv = {
    ReactCurrentDispatcher: rt,
    ReactCurrentBatchConfig: So,
    ReactCurrentOwner: sc
};
function Uf() {
    throw Error("act(...) is not supported in production builds of React.")
}
Y.Children = {
    map: Ki,
    forEach: function(t, e, r) {
        Ki(t, function() {
            e.apply(this, arguments)
        }, r)
    },
    count: function(t) {
        var e = 0;
        return Ki(t, function() {
            e++
        }),
        e
    },
    toArray: function(t) {
        return Ki(t, function(e) {
            return e
        }) || []
    },
    only: function(t) {
        if (!ic(t))
            throw Error("React.Children.only expected to receive a single React element child.");
        return t
    }
};
Y.Component = Rs;
Y.Fragment = Vy;
Y.Profiler = qy;
Y.PureComponent = rc;
Y.StrictMode = Hy;
Y.Suspense = Xy;
Y.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sv;
Y.act = Uf;
Y.cloneElement = function(t, e, r) {
    if (t == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
    var n = Af({}, t.props)
      , s = t.key
      , i = t.ref
      , o = t._owner;
    if (e != null) {
        if (e.ref !== void 0 && (i = e.ref,
        o = sc.current),
        e.key !== void 0 && (s = "" + e.key),
        t.type && t.type.defaultProps)
            var a = t.type.defaultProps;
        for (l in e)
            Lf.call(e, l) && !Df.hasOwnProperty(l) && (n[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l])
    }
    var l = arguments.length - 2;
    if (l === 1)
        n.children = r;
    else if (1 < l) {
        a = Array(l);
        for (var c = 0; c < l; c++)
            a[c] = arguments[c + 2];
        n.children = a
    }
    return {
        $$typeof: Fi,
        type: t.type,
        key: s,
        ref: i,
        props: n,
        _owner: o
    }
}
;
Y.createContext = function(t) {
    return t = {
        $$typeof: Qy,
        _currentValue: t,
        _currentValue2: t,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    t.Provider = {
        $$typeof: Ky,
        _context: t
    },
    t.Consumer = t
}
;
Y.createElement = $f;
Y.createFactory = function(t) {
    var e = $f.bind(null, t);
    return e.type = t,
    e
}
;
Y.createRef = function() {
    return {
        current: null
    }
}
;
Y.forwardRef = function(t) {
    return {
        $$typeof: Jy,
        render: t
    }
}
;
Y.isValidElement = ic;
Y.lazy = function(t) {
    return {
        $$typeof: Zy,
        _payload: {
            _status: -1,
            _result: t
        },
        _init: nv
    }
}
;
Y.memo = function(t, e) {
    return {
        $$typeof: Yy,
        type: t,
        compare: e === void 0 ? null : e
    }
}
;
Y.startTransition = function(t) {
    var e = So.transition;
    So.transition = {};
    try {
        t()
    } finally {
        So.transition = e
    }
}
;
Y.unstable_act = Uf;
Y.useCallback = function(t, e) {
    return rt.current.useCallback(t, e)
}
;
Y.useContext = function(t) {
    return rt.current.useContext(t)
}
;
Y.useDebugValue = function() {}
;
Y.useDeferredValue = function(t) {
    return rt.current.useDeferredValue(t)
}
;
Y.useEffect = function(t, e) {
    return rt.current.useEffect(t, e)
}
;
Y.useId = function() {
    return rt.current.useId()
}
;
Y.useImperativeHandle = function(t, e, r) {
    return rt.current.useImperativeHandle(t, e, r)
}
;
Y.useInsertionEffect = function(t, e) {
    return rt.current.useInsertionEffect(t, e)
}
;
Y.useLayoutEffect = function(t, e) {
    return rt.current.useLayoutEffect(t, e)
}
;
Y.useMemo = function(t, e) {
    return rt.current.useMemo(t, e)
}
;
Y.useReducer = function(t, e, r) {
    return rt.current.useReducer(t, e, r)
}
;
Y.useRef = function(t) {
    return rt.current.useRef(t)
}
;
Y.useState = function(t) {
    return rt.current.useState(t)
}
;
Y.useSyncExternalStore = function(t, e, r) {
    return rt.current.useSyncExternalStore(t, e, r)
}
;
Y.useTransition = function() {
    return rt.current.useTransition()
}
;
Y.version = "18.3.1";
Of.exports = Y;
var j = Of.exports;
const Ff = Tf(j)
  , iv = jf({
    __proto__: null,
    default: Ff
}, [j]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ov = j
  , av = Symbol.for("react.element")
  , lv = Symbol.for("react.fragment")
  , uv = Object.prototype.hasOwnProperty
  , cv = ov.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , dv = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function Bf(t, e, r) {
    var n, s = {}, i = null, o = null;
    r !== void 0 && (i = "" + r),
    e.key !== void 0 && (i = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
    for (n in e)
        uv.call(e, n) && !dv.hasOwnProperty(n) && (s[n] = e[n]);
    if (t && t.defaultProps)
        for (n in e = t.defaultProps,
        e)
            s[n] === void 0 && (s[n] = e[n]);
    return {
        $$typeof: av,
        type: t,
        key: i,
        ref: o,
        props: s,
        _owner: cv.current
    }
}
ba.Fragment = lv;
ba.jsx = Bf;
ba.jsxs = Bf;
Pf.exports = ba;
var u = Pf.exports
  , Pl = {}
  , zf = {
    exports: {}
}
  , wt = {}
  , Mf = {
    exports: {}
}
  , Wf = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(t) {
    function e(S, R) {
        var L = S.length;
        S.push(R);
        e: for (; 0 < L; ) {
            var O = L - 1 >>> 1
              , W = S[O];
            if (0 < s(W, R))
                S[O] = R,
                S[L] = W,
                L = O;
            else
                break e
        }
    }
    function r(S) {
        return S.length === 0 ? null : S[0]
    }
    function n(S) {
        if (S.length === 0)
            return null;
        var R = S[0]
          , L = S.pop();
        if (L !== R) {
            S[0] = L;
            e: for (var O = 0, W = S.length, ie = W >>> 1; O < ie; ) {
                var ue = 2 * (O + 1) - 1
                  , We = S[ue]
                  , Ge = ue + 1
                  , zt = S[Ge];
                if (0 > s(We, L))
                    Ge < W && 0 > s(zt, We) ? (S[O] = zt,
                    S[Ge] = L,
                    O = Ge) : (S[O] = We,
                    S[ue] = L,
                    O = ue);
                else if (Ge < W && 0 > s(zt, L))
                    S[O] = zt,
                    S[Ge] = L,
                    O = Ge;
                else
                    break e
            }
        }
        return R
    }
    function s(S, R) {
        var L = S.sortIndex - R.sortIndex;
        return L !== 0 ? L : S.id - R.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var i = performance;
        t.unstable_now = function() {
            return i.now()
        }
    } else {
        var o = Date
          , a = o.now();
        t.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = []
      , c = []
      , d = 1
      , h = null
      , f = 3
      , p = !1
      , v = !1
      , w = !1
      , b = typeof setTimeout == "function" ? setTimeout : null
      , g = typeof clearTimeout == "function" ? clearTimeout : null
      , m = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function y(S) {
        for (var R = r(c); R !== null; ) {
            if (R.callback === null)
                n(c);
            else if (R.startTime <= S)
                n(c),
                R.sortIndex = R.expirationTime,
                e(l, R);
            else
                break;
            R = r(c)
        }
    }
    function x(S) {
        if (w = !1,
        y(S),
        !v)
            if (r(l) !== null)
                v = !0,
                ne(k);
            else {
                var R = r(c);
                R !== null && Le(x, R.startTime - S)
            }
    }
    function k(S, R) {
        v = !1,
        w && (w = !1,
        g(I),
        I = -1),
        p = !0;
        var L = f;
        try {
            for (y(R),
            h = r(l); h !== null && (!(h.expirationTime > R) || S && !Z()); ) {
                var O = h.callback;
                if (typeof O == "function") {
                    h.callback = null,
                    f = h.priorityLevel;
                    var W = O(h.expirationTime <= R);
                    R = t.unstable_now(),
                    typeof W == "function" ? h.callback = W : h === r(l) && n(l),
                    y(R)
                } else
                    n(l);
                h = r(l)
            }
            if (h !== null)
                var ie = !0;
            else {
                var ue = r(c);
                ue !== null && Le(x, ue.startTime - R),
                ie = !1
            }
            return ie
        } finally {
            h = null,
            f = L,
            p = !1
        }
    }
    var C = !1
      , T = null
      , I = -1
      , z = 5
      , N = -1;
    function Z() {
        return !(t.unstable_now() - N < z)
    }
    function V() {
        if (T !== null) {
            var S = t.unstable_now();
            N = S;
            var R = !0;
            try {
                R = T(!0, S)
            } finally {
                R ? he() : (C = !1,
                T = null)
            }
        } else
            C = !1
    }
    var he;
    if (typeof m == "function")
        he = function() {
            m(V)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var Me = new MessageChannel
          , M = Me.port2;
        Me.port1.onmessage = V,
        he = function() {
            M.postMessage(null)
        }
    } else
        he = function() {
            b(V, 0)
        }
        ;
    function ne(S) {
        T = S,
        C || (C = !0,
        he())
    }
    function Le(S, R) {
        I = b(function() {
            S(t.unstable_now())
        }, R)
    }
    t.unstable_IdlePriority = 5,
    t.unstable_ImmediatePriority = 1,
    t.unstable_LowPriority = 4,
    t.unstable_NormalPriority = 3,
    t.unstable_Profiling = null,
    t.unstable_UserBlockingPriority = 2,
    t.unstable_cancelCallback = function(S) {
        S.callback = null
    }
    ,
    t.unstable_continueExecution = function() {
        v || p || (v = !0,
        ne(k))
    }
    ,
    t.unstable_forceFrameRate = function(S) {
        0 > S || 125 < S ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : z = 0 < S ? Math.floor(1e3 / S) : 5
    }
    ,
    t.unstable_getCurrentPriorityLevel = function() {
        return f
    }
    ,
    t.unstable_getFirstCallbackNode = function() {
        return r(l)
    }
    ,
    t.unstable_next = function(S) {
        switch (f) {
        case 1:
        case 2:
        case 3:
            var R = 3;
            break;
        default:
            R = f
        }
        var L = f;
        f = R;
        try {
            return S()
        } finally {
            f = L
        }
    }
    ,
    t.unstable_pauseExecution = function() {}
    ,
    t.unstable_requestPaint = function() {}
    ,
    t.unstable_runWithPriority = function(S, R) {
        switch (S) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            S = 3
        }
        var L = f;
        f = S;
        try {
            return R()
        } finally {
            f = L
        }
    }
    ,
    t.unstable_scheduleCallback = function(S, R, L) {
        var O = t.unstable_now();
        switch (typeof L == "object" && L !== null ? (L = L.delay,
        L = typeof L == "number" && 0 < L ? O + L : O) : L = O,
        S) {
        case 1:
            var W = -1;
            break;
        case 2:
            W = 250;
            break;
        case 5:
            W = 1073741823;
            break;
        case 4:
            W = 1e4;
            break;
        default:
            W = 5e3
        }
        return W = L + W,
        S = {
            id: d++,
            callback: R,
            priorityLevel: S,
            startTime: L,
            expirationTime: W,
            sortIndex: -1
        },
        L > O ? (S.sortIndex = L,
        e(c, S),
        r(l) === null && S === r(c) && (w ? (g(I),
        I = -1) : w = !0,
        Le(x, L - O))) : (S.sortIndex = W,
        e(l, S),
        v || p || (v = !0,
        ne(k))),
        S
    }
    ,
    t.unstable_shouldYield = Z,
    t.unstable_wrapCallback = function(S) {
        var R = f;
        return function() {
            var L = f;
            f = R;
            try {
                return S.apply(this, arguments)
            } finally {
                f = L
            }
        }
    }
}
)(Wf);
Mf.exports = Wf;
var hv = Mf.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var fv = j
  , vt = hv;
function A(t) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, r = 1; r < arguments.length; r++)
        e += "&args[]=" + encodeURIComponent(arguments[r]);
    return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var Gf = new Set
  , hi = {};
function Pn(t, e) {
    xs(t, e),
    xs(t + "Capture", e)
}
function xs(t, e) {
    for (hi[t] = e,
    t = 0; t < e.length; t++)
        Gf.add(e[t])
}
var ar = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , Ol = Object.prototype.hasOwnProperty
  , pv = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , bd = {}
  , xd = {};
function gv(t) {
    return Ol.call(xd, t) ? !0 : Ol.call(bd, t) ? !1 : pv.test(t) ? xd[t] = !0 : (bd[t] = !0,
    !1)
}
function mv(t, e, r, n) {
    if (r !== null && r.type === 0)
        return !1;
    switch (typeof e) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return n ? !1 : r !== null ? !r.acceptsBooleans : (t = t.toLowerCase().slice(0, 5),
        t !== "data-" && t !== "aria-");
    default:
        return !1
    }
}
function yv(t, e, r, n) {
    if (e === null || typeof e > "u" || mv(t, e, r, n))
        return !0;
    if (n)
        return !1;
    if (r !== null)
        switch (r.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
        }
    return !1
}
function nt(t, e, r, n, s, i, o) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4,
    this.attributeName = n,
    this.attributeNamespace = s,
    this.mustUseProperty = r,
    this.propertyName = t,
    this.type = e,
    this.sanitizeURL = i,
    this.removeEmptyString = o
}
var ze = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t) {
    ze[t] = new nt(t,0,!1,t,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(t) {
    var e = t[0];
    ze[e] = new nt(e,1,!1,t[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(t) {
    ze[t] = new nt(t,2,!1,t.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(t) {
    ze[t] = new nt(t,2,!1,t,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t) {
    ze[t] = new nt(t,3,!1,t.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(t) {
    ze[t] = new nt(t,3,!0,t,null,!1,!1)
});
["capture", "download"].forEach(function(t) {
    ze[t] = new nt(t,4,!1,t,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(t) {
    ze[t] = new nt(t,6,!1,t,null,!1,!1)
});
["rowSpan", "start"].forEach(function(t) {
    ze[t] = new nt(t,5,!1,t.toLowerCase(),null,!1,!1)
});
var oc = /[\-:]([a-z])/g;
function ac(t) {
    return t[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t) {
    var e = t.replace(oc, ac);
    ze[e] = new nt(e,1,!1,t,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t) {
    var e = t.replace(oc, ac);
    ze[e] = new nt(e,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(t) {
    var e = t.replace(oc, ac);
    ze[e] = new nt(e,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(t) {
    ze[t] = new nt(t,1,!1,t.toLowerCase(),null,!1,!1)
});
ze.xlinkHref = new nt("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(t) {
    ze[t] = new nt(t,1,!1,t.toLowerCase(),null,!0,!0)
});
function lc(t, e, r, n) {
    var s = ze.hasOwnProperty(e) ? ze[e] : null;
    (s !== null ? s.type !== 0 : n || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (yv(e, r, s, n) && (r = null),
    n || s === null ? gv(e) && (r === null ? t.removeAttribute(e) : t.setAttribute(e, "" + r)) : s.mustUseProperty ? t[s.propertyName] = r === null ? s.type === 3 ? !1 : "" : r : (e = s.attributeName,
    n = s.attributeNamespace,
    r === null ? t.removeAttribute(e) : (s = s.type,
    r = s === 3 || s === 4 && r === !0 ? "" : "" + r,
    n ? t.setAttributeNS(n, e, r) : t.setAttribute(e, r))))
}
var dr = fv.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , Qi = Symbol.for("react.element")
  , Mn = Symbol.for("react.portal")
  , Wn = Symbol.for("react.fragment")
  , uc = Symbol.for("react.strict_mode")
  , Rl = Symbol.for("react.profiler")
  , Vf = Symbol.for("react.provider")
  , Hf = Symbol.for("react.context")
  , cc = Symbol.for("react.forward_ref")
  , Al = Symbol.for("react.suspense")
  , Il = Symbol.for("react.suspense_list")
  , dc = Symbol.for("react.memo")
  , yr = Symbol.for("react.lazy")
  , qf = Symbol.for("react.offscreen")
  , _d = Symbol.iterator;
function Us(t) {
    return t === null || typeof t != "object" ? null : (t = _d && t[_d] || t["@@iterator"],
    typeof t == "function" ? t : null)
}
var _e = Object.assign, Ja;
function Ks(t) {
    if (Ja === void 0)
        try {
            throw Error()
        } catch (r) {
            var e = r.stack.trim().match(/\n( *(at )?)/);
            Ja = e && e[1] || ""
        }
    return `
` + Ja + t
}
var Xa = !1;
function Ya(t, e) {
    if (!t || Xa)
        return "";
    Xa = !0;
    var r = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                throw Error()
            }
            ,
            Object.defineProperty(e.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (c) {
                    var n = c
                }
                Reflect.construct(t, [], e)
            } else {
                try {
                    e.call()
                } catch (c) {
                    n = c
                }
                t.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (c) {
                n = c
            }
            t()
        }
    } catch (c) {
        if (c && n && typeof c.stack == "string") {
            for (var s = c.stack.split(`
`), i = n.stack.split(`
`), o = s.length - 1, a = i.length - 1; 1 <= o && 0 <= a && s[o] !== i[a]; )
                a--;
            for (; 1 <= o && 0 <= a; o--,
            a--)
                if (s[o] !== i[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--,
                            a--,
                            0 > a || s[o] !== i[a]) {
                                var l = `
` + s[o].replace(" at new ", " at ");
                                return t.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", t.displayName)),
                                l
                            }
                        while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        Xa = !1,
        Error.prepareStackTrace = r
    }
    return (t = t ? t.displayName || t.name : "") ? Ks(t) : ""
}
function vv(t) {
    switch (t.tag) {
    case 5:
        return Ks(t.type);
    case 16:
        return Ks("Lazy");
    case 13:
        return Ks("Suspense");
    case 19:
        return Ks("SuspenseList");
    case 0:
    case 2:
    case 15:
        return t = Ya(t.type, !1),
        t;
    case 11:
        return t = Ya(t.type.render, !1),
        t;
    case 1:
        return t = Ya(t.type, !0),
        t;
    default:
        return ""
    }
}
function Nl(t) {
    if (t == null)
        return null;
    if (typeof t == "function")
        return t.displayName || t.name || null;
    if (typeof t == "string")
        return t;
    switch (t) {
    case Wn:
        return "Fragment";
    case Mn:
        return "Portal";
    case Rl:
        return "Profiler";
    case uc:
        return "StrictMode";
    case Al:
        return "Suspense";
    case Il:
        return "SuspenseList"
    }
    if (typeof t == "object")
        switch (t.$$typeof) {
        case Hf:
            return (t.displayName || "Context") + ".Consumer";
        case Vf:
            return (t._context.displayName || "Context") + ".Provider";
        case cc:
            var e = t.render;
            return t = t.displayName,
            t || (t = e.displayName || e.name || "",
            t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"),
            t;
        case dc:
            return e = t.displayName || null,
            e !== null ? e : Nl(t.type) || "Memo";
        case yr:
            e = t._payload,
            t = t._init;
            try {
                return Nl(t(e))
            } catch {}
        }
    return null
}
function wv(t) {
    var e = t.type;
    switch (t.tag) {
    case 24:
        return "Cache";
    case 9:
        return (e.displayName || "Context") + ".Consumer";
    case 10:
        return (e._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return t = e.render,
        t = t.displayName || t.name || "",
        e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return e;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return Nl(e);
    case 8:
        return e === uc ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof e == "function")
            return e.displayName || e.name || null;
        if (typeof e == "string")
            return e
    }
    return null
}
function Wr(t) {
    switch (typeof t) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return t;
    case "object":
        return t;
    default:
        return ""
    }
}
function Kf(t) {
    var e = t.type;
    return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}
function bv(t) {
    var e = Kf(t) ? "checked" : "value"
      , r = Object.getOwnPropertyDescriptor(t.constructor.prototype, e)
      , n = "" + t[e];
    if (!t.hasOwnProperty(e) && typeof r < "u" && typeof r.get == "function" && typeof r.set == "function") {
        var s = r.get
          , i = r.set;
        return Object.defineProperty(t, e, {
            configurable: !0,
            get: function() {
                return s.call(this)
            },
            set: function(o) {
                n = "" + o,
                i.call(this, o)
            }
        }),
        Object.defineProperty(t, e, {
            enumerable: r.enumerable
        }),
        {
            getValue: function() {
                return n
            },
            setValue: function(o) {
                n = "" + o
            },
            stopTracking: function() {
                t._valueTracker = null,
                delete t[e]
            }
        }
    }
}
function Ji(t) {
    t._valueTracker || (t._valueTracker = bv(t))
}
function Qf(t) {
    if (!t)
        return !1;
    var e = t._valueTracker;
    if (!e)
        return !0;
    var r = e.getValue()
      , n = "";
    return t && (n = Kf(t) ? t.checked ? "true" : "false" : t.value),
    t = n,
    t !== r ? (e.setValue(t),
    !0) : !1
}
function Uo(t) {
    if (t = t || (typeof document < "u" ? document : void 0),
    typeof t > "u")
        return null;
    try {
        return t.activeElement || t.body
    } catch {
        return t.body
    }
}
function Ll(t, e) {
    var r = e.checked;
    return _e({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: r ?? t._wrapperState.initialChecked
    })
}
function Sd(t, e) {
    var r = e.defaultValue == null ? "" : e.defaultValue
      , n = e.checked != null ? e.checked : e.defaultChecked;
    r = Wr(e.value != null ? e.value : r),
    t._wrapperState = {
        initialChecked: n,
        initialValue: r,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}
function Jf(t, e) {
    e = e.checked,
    e != null && lc(t, "checked", e, !1)
}
function Dl(t, e) {
    Jf(t, e);
    var r = Wr(e.value)
      , n = e.type;
    if (r != null)
        n === "number" ? (r === 0 && t.value === "" || t.value != r) && (t.value = "" + r) : t.value !== "" + r && (t.value = "" + r);
    else if (n === "submit" || n === "reset") {
        t.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? $l(t, e.type, r) : e.hasOwnProperty("defaultValue") && $l(t, e.type, Wr(e.defaultValue)),
    e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked)
}
function kd(t, e, r) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var n = e.type;
        if (!(n !== "submit" && n !== "reset" || e.value !== void 0 && e.value !== null))
            return;
        e = "" + t._wrapperState.initialValue,
        r || e === t.value || (t.value = e),
        t.defaultValue = e
    }
    r = t.name,
    r !== "" && (t.name = ""),
    t.defaultChecked = !!t._wrapperState.initialChecked,
    r !== "" && (t.name = r)
}
function $l(t, e, r) {
    (e !== "number" || Uo(t.ownerDocument) !== t) && (r == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + r && (t.defaultValue = "" + r))
}
var Qs = Array.isArray;
function es(t, e, r, n) {
    if (t = t.options,
    e) {
        e = {};
        for (var s = 0; s < r.length; s++)
            e["$" + r[s]] = !0;
        for (r = 0; r < t.length; r++)
            s = e.hasOwnProperty("$" + t[r].value),
            t[r].selected !== s && (t[r].selected = s),
            s && n && (t[r].defaultSelected = !0)
    } else {
        for (r = "" + Wr(r),
        e = null,
        s = 0; s < t.length; s++) {
            if (t[s].value === r) {
                t[s].selected = !0,
                n && (t[s].defaultSelected = !0);
                return
            }
            e !== null || t[s].disabled || (e = t[s])
        }
        e !== null && (e.selected = !0)
    }
}
function Ul(t, e) {
    if (e.dangerouslySetInnerHTML != null)
        throw Error(A(91));
    return _e({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + t._wrapperState.initialValue
    })
}
function Ed(t, e) {
    var r = e.value;
    if (r == null) {
        if (r = e.children,
        e = e.defaultValue,
        r != null) {
            if (e != null)
                throw Error(A(92));
            if (Qs(r)) {
                if (1 < r.length)
                    throw Error(A(93));
                r = r[0]
            }
            e = r
        }
        e == null && (e = ""),
        r = e
    }
    t._wrapperState = {
        initialValue: Wr(r)
    }
}
function Xf(t, e) {
    var r = Wr(e.value)
      , n = Wr(e.defaultValue);
    r != null && (r = "" + r,
    r !== t.value && (t.value = r),
    e.defaultValue == null && t.defaultValue !== r && (t.defaultValue = r)),
    n != null && (t.defaultValue = "" + n)
}
function Cd(t) {
    var e = t.textContent;
    e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e)
}
function Yf(t) {
    switch (t) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function Fl(t, e) {
    return t == null || t === "http://www.w3.org/1999/xhtml" ? Yf(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t
}
var Xi, Zf = function(t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, r, n, s) {
        MSApp.execUnsafeLocalFunction(function() {
            return t(e, r, n, s)
        })
    }
    : t
}(function(t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in t)
        t.innerHTML = e;
    else {
        for (Xi = Xi || document.createElement("div"),
        Xi.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
        e = Xi.firstChild; t.firstChild; )
            t.removeChild(t.firstChild);
        for (; e.firstChild; )
            t.appendChild(e.firstChild)
    }
});
function fi(t, e) {
    if (e) {
        var r = t.firstChild;
        if (r && r === t.lastChild && r.nodeType === 3) {
            r.nodeValue = e;
            return
        }
    }
    t.textContent = e
}
var ni = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , xv = ["Webkit", "ms", "Moz", "O"];
Object.keys(ni).forEach(function(t) {
    xv.forEach(function(e) {
        e = e + t.charAt(0).toUpperCase() + t.substring(1),
        ni[e] = ni[t]
    })
});
function ep(t, e, r) {
    return e == null || typeof e == "boolean" || e === "" ? "" : r || typeof e != "number" || e === 0 || ni.hasOwnProperty(t) && ni[t] ? ("" + e).trim() : e + "px"
}
function tp(t, e) {
    t = t.style;
    for (var r in e)
        if (e.hasOwnProperty(r)) {
            var n = r.indexOf("--") === 0
              , s = ep(r, e[r], n);
            r === "float" && (r = "cssFloat"),
            n ? t.setProperty(r, s) : t[r] = s
        }
}
var _v = _e({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function Bl(t, e) {
    if (e) {
        if (_v[t] && (e.children != null || e.dangerouslySetInnerHTML != null))
            throw Error(A(137, t));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null)
                throw Error(A(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html"in e.dangerouslySetInnerHTML))
                throw Error(A(61))
        }
        if (e.style != null && typeof e.style != "object")
            throw Error(A(62))
    }
}
function zl(t, e) {
    if (t.indexOf("-") === -1)
        return typeof e.is == "string";
    switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var Ml = null;
function hc(t) {
    return t = t.target || t.srcElement || window,
    t.correspondingUseElement && (t = t.correspondingUseElement),
    t.nodeType === 3 ? t.parentNode : t
}
var Wl = null
  , ts = null
  , rs = null;
function jd(t) {
    if (t = Mi(t)) {
        if (typeof Wl != "function")
            throw Error(A(280));
        var e = t.stateNode;
        e && (e = Ea(e),
        Wl(t.stateNode, t.type, e))
    }
}
function rp(t) {
    ts ? rs ? rs.push(t) : rs = [t] : ts = t
}
function np() {
    if (ts) {
        var t = ts
          , e = rs;
        if (rs = ts = null,
        jd(t),
        e)
            for (t = 0; t < e.length; t++)
                jd(e[t])
    }
}
function sp(t, e) {
    return t(e)
}
function ip() {}
var Za = !1;
function op(t, e, r) {
    if (Za)
        return t(e, r);
    Za = !0;
    try {
        return sp(t, e, r)
    } finally {
        Za = !1,
        (ts !== null || rs !== null) && (ip(),
        np())
    }
}
function pi(t, e) {
    var r = t.stateNode;
    if (r === null)
        return null;
    var n = Ea(r);
    if (n === null)
        return null;
    r = n[e];
    e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (n = !n.disabled) || (t = t.type,
        n = !(t === "button" || t === "input" || t === "select" || t === "textarea")),
        t = !n;
        break e;
    default:
        t = !1
    }
    if (t)
        return null;
    if (r && typeof r != "function")
        throw Error(A(231, e, typeof r));
    return r
}
var Gl = !1;
if (ar)
    try {
        var Fs = {};
        Object.defineProperty(Fs, "passive", {
            get: function() {
                Gl = !0
            }
        }),
        window.addEventListener("test", Fs, Fs),
        window.removeEventListener("test", Fs, Fs)
    } catch {
        Gl = !1
    }
function Sv(t, e, r, n, s, i, o, a, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(r, c)
    } catch (d) {
        this.onError(d)
    }
}
var si = !1
  , Fo = null
  , Bo = !1
  , Vl = null
  , kv = {
    onError: function(t) {
        si = !0,
        Fo = t
    }
};
function Ev(t, e, r, n, s, i, o, a, l) {
    si = !1,
    Fo = null,
    Sv.apply(kv, arguments)
}
function Cv(t, e, r, n, s, i, o, a, l) {
    if (Ev.apply(this, arguments),
    si) {
        if (si) {
            var c = Fo;
            si = !1,
            Fo = null
        } else
            throw Error(A(198));
        Bo || (Bo = !0,
        Vl = c)
    }
}
function On(t) {
    var e = t
      , r = t;
    if (t.alternate)
        for (; e.return; )
            e = e.return;
    else {
        t = e;
        do
            e = t,
            e.flags & 4098 && (r = e.return),
            t = e.return;
        while (t)
    }
    return e.tag === 3 ? r : null
}
function ap(t) {
    if (t.tag === 13) {
        var e = t.memoizedState;
        if (e === null && (t = t.alternate,
        t !== null && (e = t.memoizedState)),
        e !== null)
            return e.dehydrated
    }
    return null
}
function Td(t) {
    if (On(t) !== t)
        throw Error(A(188))
}
function jv(t) {
    var e = t.alternate;
    if (!e) {
        if (e = On(t),
        e === null)
            throw Error(A(188));
        return e !== t ? null : t
    }
    for (var r = t, n = e; ; ) {
        var s = r.return;
        if (s === null)
            break;
        var i = s.alternate;
        if (i === null) {
            if (n = s.return,
            n !== null) {
                r = n;
                continue
            }
            break
        }
        if (s.child === i.child) {
            for (i = s.child; i; ) {
                if (i === r)
                    return Td(s),
                    t;
                if (i === n)
                    return Td(s),
                    e;
                i = i.sibling
            }
            throw Error(A(188))
        }
        if (r.return !== n.return)
            r = s,
            n = i;
        else {
            for (var o = !1, a = s.child; a; ) {
                if (a === r) {
                    o = !0,
                    r = s,
                    n = i;
                    break
                }
                if (a === n) {
                    o = !0,
                    n = s,
                    r = i;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = i.child; a; ) {
                    if (a === r) {
                        o = !0,
                        r = i,
                        n = s;
                        break
                    }
                    if (a === n) {
                        o = !0,
                        n = i,
                        r = s;
                        break
                    }
                    a = a.sibling
                }
                if (!o)
                    throw Error(A(189))
            }
        }
        if (r.alternate !== n)
            throw Error(A(190))
    }
    if (r.tag !== 3)
        throw Error(A(188));
    return r.stateNode.current === r ? t : e
}
function lp(t) {
    return t = jv(t),
    t !== null ? up(t) : null
}
function up(t) {
    if (t.tag === 5 || t.tag === 6)
        return t;
    for (t = t.child; t !== null; ) {
        var e = up(t);
        if (e !== null)
            return e;
        t = t.sibling
    }
    return null
}
var cp = vt.unstable_scheduleCallback
  , Pd = vt.unstable_cancelCallback
  , Tv = vt.unstable_shouldYield
  , Pv = vt.unstable_requestPaint
  , Ee = vt.unstable_now
  , Ov = vt.unstable_getCurrentPriorityLevel
  , fc = vt.unstable_ImmediatePriority
  , dp = vt.unstable_UserBlockingPriority
  , zo = vt.unstable_NormalPriority
  , Rv = vt.unstable_LowPriority
  , hp = vt.unstable_IdlePriority
  , xa = null
  , Jt = null;
function Av(t) {
    if (Jt && typeof Jt.onCommitFiberRoot == "function")
        try {
            Jt.onCommitFiberRoot(xa, t, void 0, (t.current.flags & 128) === 128)
        } catch {}
}
var Ut = Math.clz32 ? Math.clz32 : Lv
  , Iv = Math.log
  , Nv = Math.LN2;
function Lv(t) {
    return t >>>= 0,
    t === 0 ? 32 : 31 - (Iv(t) / Nv | 0) | 0
}
var Yi = 64
  , Zi = 4194304;
function Js(t) {
    switch (t & -t) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return t & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return t & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return t
    }
}
function Mo(t, e) {
    var r = t.pendingLanes;
    if (r === 0)
        return 0;
    var n = 0
      , s = t.suspendedLanes
      , i = t.pingedLanes
      , o = r & 268435455;
    if (o !== 0) {
        var a = o & ~s;
        a !== 0 ? n = Js(a) : (i &= o,
        i !== 0 && (n = Js(i)))
    } else
        o = r & ~s,
        o !== 0 ? n = Js(o) : i !== 0 && (n = Js(i));
    if (n === 0)
        return 0;
    if (e !== 0 && e !== n && !(e & s) && (s = n & -n,
    i = e & -e,
    s >= i || s === 16 && (i & 4194240) !== 0))
        return e;
    if (n & 4 && (n |= r & 16),
    e = t.entangledLanes,
    e !== 0)
        for (t = t.entanglements,
        e &= n; 0 < e; )
            r = 31 - Ut(e),
            s = 1 << r,
            n |= t[r],
            e &= ~s;
    return n
}
function Dv(t, e) {
    switch (t) {
    case 1:
    case 2:
    case 4:
        return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function $v(t, e) {
    for (var r = t.suspendedLanes, n = t.pingedLanes, s = t.expirationTimes, i = t.pendingLanes; 0 < i; ) {
        var o = 31 - Ut(i)
          , a = 1 << o
          , l = s[o];
        l === -1 ? (!(a & r) || a & n) && (s[o] = Dv(a, e)) : l <= e && (t.expiredLanes |= a),
        i &= ~a
    }
}
function Hl(t) {
    return t = t.pendingLanes & -1073741825,
    t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
}
function fp() {
    var t = Yi;
    return Yi <<= 1,
    !(Yi & 4194240) && (Yi = 64),
    t
}
function el(t) {
    for (var e = [], r = 0; 31 > r; r++)
        e.push(t);
    return e
}
function Bi(t, e, r) {
    t.pendingLanes |= e,
    e !== 536870912 && (t.suspendedLanes = 0,
    t.pingedLanes = 0),
    t = t.eventTimes,
    e = 31 - Ut(e),
    t[e] = r
}
function Uv(t, e) {
    var r = t.pendingLanes & ~e;
    t.pendingLanes = e,
    t.suspendedLanes = 0,
    t.pingedLanes = 0,
    t.expiredLanes &= e,
    t.mutableReadLanes &= e,
    t.entangledLanes &= e,
    e = t.entanglements;
    var n = t.eventTimes;
    for (t = t.expirationTimes; 0 < r; ) {
        var s = 31 - Ut(r)
          , i = 1 << s;
        e[s] = 0,
        n[s] = -1,
        t[s] = -1,
        r &= ~i
    }
}
function pc(t, e) {
    var r = t.entangledLanes |= e;
    for (t = t.entanglements; r; ) {
        var n = 31 - Ut(r)
          , s = 1 << n;
        s & e | t[n] & e && (t[n] |= e),
        r &= ~s
    }
}
var le = 0;
function pp(t) {
    return t &= -t,
    1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1
}
var gp, gc, mp, yp, vp, ql = !1, eo = [], Ir = null, Nr = null, Lr = null, gi = new Map, mi = new Map, wr = [], Fv = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Od(t, e) {
    switch (t) {
    case "focusin":
    case "focusout":
        Ir = null;
        break;
    case "dragenter":
    case "dragleave":
        Nr = null;
        break;
    case "mouseover":
    case "mouseout":
        Lr = null;
        break;
    case "pointerover":
    case "pointerout":
        gi.delete(e.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        mi.delete(e.pointerId)
    }
}
function Bs(t, e, r, n, s, i) {
    return t === null || t.nativeEvent !== i ? (t = {
        blockedOn: e,
        domEventName: r,
        eventSystemFlags: n,
        nativeEvent: i,
        targetContainers: [s]
    },
    e !== null && (e = Mi(e),
    e !== null && gc(e)),
    t) : (t.eventSystemFlags |= n,
    e = t.targetContainers,
    s !== null && e.indexOf(s) === -1 && e.push(s),
    t)
}
function Bv(t, e, r, n, s) {
    switch (e) {
    case "focusin":
        return Ir = Bs(Ir, t, e, r, n, s),
        !0;
    case "dragenter":
        return Nr = Bs(Nr, t, e, r, n, s),
        !0;
    case "mouseover":
        return Lr = Bs(Lr, t, e, r, n, s),
        !0;
    case "pointerover":
        var i = s.pointerId;
        return gi.set(i, Bs(gi.get(i) || null, t, e, r, n, s)),
        !0;
    case "gotpointercapture":
        return i = s.pointerId,
        mi.set(i, Bs(mi.get(i) || null, t, e, r, n, s)),
        !0
    }
    return !1
}
function wp(t) {
    var e = an(t.target);
    if (e !== null) {
        var r = On(e);
        if (r !== null) {
            if (e = r.tag,
            e === 13) {
                if (e = ap(r),
                e !== null) {
                    t.blockedOn = e,
                    vp(t.priority, function() {
                        mp(r)
                    });
                    return
                }
            } else if (e === 3 && r.stateNode.current.memoizedState.isDehydrated) {
                t.blockedOn = r.tag === 3 ? r.stateNode.containerInfo : null;
                return
            }
        }
    }
    t.blockedOn = null
}
function ko(t) {
    if (t.blockedOn !== null)
        return !1;
    for (var e = t.targetContainers; 0 < e.length; ) {
        var r = Kl(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
        if (r === null) {
            r = t.nativeEvent;
            var n = new r.constructor(r.type,r);
            Ml = n,
            r.target.dispatchEvent(n),
            Ml = null
        } else
            return e = Mi(r),
            e !== null && gc(e),
            t.blockedOn = r,
            !1;
        e.shift()
    }
    return !0
}
function Rd(t, e, r) {
    ko(t) && r.delete(e)
}
function zv() {
    ql = !1,
    Ir !== null && ko(Ir) && (Ir = null),
    Nr !== null && ko(Nr) && (Nr = null),
    Lr !== null && ko(Lr) && (Lr = null),
    gi.forEach(Rd),
    mi.forEach(Rd)
}
function zs(t, e) {
    t.blockedOn === e && (t.blockedOn = null,
    ql || (ql = !0,
    vt.unstable_scheduleCallback(vt.unstable_NormalPriority, zv)))
}
function yi(t) {
    function e(s) {
        return zs(s, t)
    }
    if (0 < eo.length) {
        zs(eo[0], t);
        for (var r = 1; r < eo.length; r++) {
            var n = eo[r];
            n.blockedOn === t && (n.blockedOn = null)
        }
    }
    for (Ir !== null && zs(Ir, t),
    Nr !== null && zs(Nr, t),
    Lr !== null && zs(Lr, t),
    gi.forEach(e),
    mi.forEach(e),
    r = 0; r < wr.length; r++)
        n = wr[r],
        n.blockedOn === t && (n.blockedOn = null);
    for (; 0 < wr.length && (r = wr[0],
    r.blockedOn === null); )
        wp(r),
        r.blockedOn === null && wr.shift()
}
var ns = dr.ReactCurrentBatchConfig
  , Wo = !0;
function Mv(t, e, r, n) {
    var s = le
      , i = ns.transition;
    ns.transition = null;
    try {
        le = 1,
        mc(t, e, r, n)
    } finally {
        le = s,
        ns.transition = i
    }
}
function Wv(t, e, r, n) {
    var s = le
      , i = ns.transition;
    ns.transition = null;
    try {
        le = 4,
        mc(t, e, r, n)
    } finally {
        le = s,
        ns.transition = i
    }
}
function mc(t, e, r, n) {
    if (Wo) {
        var s = Kl(t, e, r, n);
        if (s === null)
            cl(t, e, n, Go, r),
            Od(t, n);
        else if (Bv(s, t, e, r, n))
            n.stopPropagation();
        else if (Od(t, n),
        e & 4 && -1 < Fv.indexOf(t)) {
            for (; s !== null; ) {
                var i = Mi(s);
                if (i !== null && gp(i),
                i = Kl(t, e, r, n),
                i === null && cl(t, e, n, Go, r),
                i === s)
                    break;
                s = i
            }
            s !== null && n.stopPropagation()
        } else
            cl(t, e, n, null, r)
    }
}
var Go = null;
function Kl(t, e, r, n) {
    if (Go = null,
    t = hc(n),
    t = an(t),
    t !== null)
        if (e = On(t),
        e === null)
            t = null;
        else if (r = e.tag,
        r === 13) {
            if (t = ap(e),
            t !== null)
                return t;
            t = null
        } else if (r === 3) {
            if (e.stateNode.current.memoizedState.isDehydrated)
                return e.tag === 3 ? e.stateNode.containerInfo : null;
            t = null
        } else
            e !== t && (t = null);
    return Go = t,
    null
}
function bp(t) {
    switch (t) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (Ov()) {
        case fc:
            return 1;
        case dp:
            return 4;
        case zo:
        case Rv:
            return 16;
        case hp:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var Rr = null
  , yc = null
  , Eo = null;
function xp() {
    if (Eo)
        return Eo;
    var t, e = yc, r = e.length, n, s = "value"in Rr ? Rr.value : Rr.textContent, i = s.length;
    for (t = 0; t < r && e[t] === s[t]; t++)
        ;
    var o = r - t;
    for (n = 1; n <= o && e[r - n] === s[i - n]; n++)
        ;
    return Eo = s.slice(t, 1 < n ? 1 - n : void 0)
}
function Co(t) {
    var e = t.keyCode;
    return "charCode"in t ? (t = t.charCode,
    t === 0 && e === 13 && (t = 13)) : t = e,
    t === 10 && (t = 13),
    32 <= t || t === 13 ? t : 0
}
function to() {
    return !0
}
function Ad() {
    return !1
}
function bt(t) {
    function e(r, n, s, i, o) {
        this._reactName = r,
        this._targetInst = s,
        this.type = n,
        this.nativeEvent = i,
        this.target = o,
        this.currentTarget = null;
        for (var a in t)
            t.hasOwnProperty(a) && (r = t[a],
            this[a] = r ? r(i) : i[a]);
        return this.isDefaultPrevented = (i.defaultPrevented != null ? i.defaultPrevented : i.returnValue === !1) ? to : Ad,
        this.isPropagationStopped = Ad,
        this
    }
    return _e(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var r = this.nativeEvent;
            r && (r.preventDefault ? r.preventDefault() : typeof r.returnValue != "unknown" && (r.returnValue = !1),
            this.isDefaultPrevented = to)
        },
        stopPropagation: function() {
            var r = this.nativeEvent;
            r && (r.stopPropagation ? r.stopPropagation() : typeof r.cancelBubble != "unknown" && (r.cancelBubble = !0),
            this.isPropagationStopped = to)
        },
        persist: function() {},
        isPersistent: to
    }),
    e
}
var As = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(t) {
        return t.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, vc = bt(As), zi = _e({}, As, {
    view: 0,
    detail: 0
}), Gv = bt(zi), tl, rl, Ms, _a = _e({}, zi, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: wc,
    button: 0,
    buttons: 0,
    relatedTarget: function(t) {
        return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget
    },
    movementX: function(t) {
        return "movementX"in t ? t.movementX : (t !== Ms && (Ms && t.type === "mousemove" ? (tl = t.screenX - Ms.screenX,
        rl = t.screenY - Ms.screenY) : rl = tl = 0,
        Ms = t),
        tl)
    },
    movementY: function(t) {
        return "movementY"in t ? t.movementY : rl
    }
}), Id = bt(_a), Vv = _e({}, _a, {
    dataTransfer: 0
}), Hv = bt(Vv), qv = _e({}, zi, {
    relatedTarget: 0
}), nl = bt(qv), Kv = _e({}, As, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), Qv = bt(Kv), Jv = _e({}, As, {
    clipboardData: function(t) {
        return "clipboardData"in t ? t.clipboardData : window.clipboardData
    }
}), Xv = bt(Jv), Yv = _e({}, As, {
    data: 0
}), Nd = bt(Yv), Zv = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, e0 = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, t0 = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function r0(t) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(t) : (t = t0[t]) ? !!e[t] : !1
}
function wc() {
    return r0
}
var n0 = _e({}, zi, {
    key: function(t) {
        if (t.key) {
            var e = Zv[t.key] || t.key;
            if (e !== "Unidentified")
                return e
        }
        return t.type === "keypress" ? (t = Co(t),
        t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? e0[t.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: wc,
    charCode: function(t) {
        return t.type === "keypress" ? Co(t) : 0
    },
    keyCode: function(t) {
        return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
    },
    which: function(t) {
        return t.type === "keypress" ? Co(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
    }
})
  , s0 = bt(n0)
  , i0 = _e({}, _a, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , Ld = bt(i0)
  , o0 = _e({}, zi, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: wc
})
  , a0 = bt(o0)
  , l0 = _e({}, As, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , u0 = bt(l0)
  , c0 = _e({}, _a, {
    deltaX: function(t) {
        return "deltaX"in t ? t.deltaX : "wheelDeltaX"in t ? -t.wheelDeltaX : 0
    },
    deltaY: function(t) {
        return "deltaY"in t ? t.deltaY : "wheelDeltaY"in t ? -t.wheelDeltaY : "wheelDelta"in t ? -t.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , d0 = bt(c0)
  , h0 = [9, 13, 27, 32]
  , bc = ar && "CompositionEvent"in window
  , ii = null;
ar && "documentMode"in document && (ii = document.documentMode);
var f0 = ar && "TextEvent"in window && !ii
  , _p = ar && (!bc || ii && 8 < ii && 11 >= ii)
  , Dd = " "
  , $d = !1;
function Sp(t, e) {
    switch (t) {
    case "keyup":
        return h0.indexOf(e.keyCode) !== -1;
    case "keydown":
        return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function kp(t) {
    return t = t.detail,
    typeof t == "object" && "data"in t ? t.data : null
}
var Gn = !1;
function p0(t, e) {
    switch (t) {
    case "compositionend":
        return kp(e);
    case "keypress":
        return e.which !== 32 ? null : ($d = !0,
        Dd);
    case "textInput":
        return t = e.data,
        t === Dd && $d ? null : t;
    default:
        return null
    }
}
function g0(t, e) {
    if (Gn)
        return t === "compositionend" || !bc && Sp(t, e) ? (t = xp(),
        Eo = yc = Rr = null,
        Gn = !1,
        t) : null;
    switch (t) {
    case "paste":
        return null;
    case "keypress":
        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
            if (e.char && 1 < e.char.length)
                return e.char;
            if (e.which)
                return String.fromCharCode(e.which)
        }
        return null;
    case "compositionend":
        return _p && e.locale !== "ko" ? null : e.data;
    default:
        return null
    }
}
var m0 = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function Ud(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e === "input" ? !!m0[t.type] : e === "textarea"
}
function Ep(t, e, r, n) {
    rp(n),
    e = Vo(e, "onChange"),
    0 < e.length && (r = new vc("onChange","change",null,r,n),
    t.push({
        event: r,
        listeners: e
    }))
}
var oi = null
  , vi = null;
function y0(t) {
    Dp(t, 0)
}
function Sa(t) {
    var e = qn(t);
    if (Qf(e))
        return t
}
function v0(t, e) {
    if (t === "change")
        return e
}
var Cp = !1;
if (ar) {
    var sl;
    if (ar) {
        var il = "oninput"in document;
        if (!il) {
            var Fd = document.createElement("div");
            Fd.setAttribute("oninput", "return;"),
            il = typeof Fd.oninput == "function"
        }
        sl = il
    } else
        sl = !1;
    Cp = sl && (!document.documentMode || 9 < document.documentMode)
}
function Bd() {
    oi && (oi.detachEvent("onpropertychange", jp),
    vi = oi = null)
}
function jp(t) {
    if (t.propertyName === "value" && Sa(vi)) {
        var e = [];
        Ep(e, vi, t, hc(t)),
        op(y0, e)
    }
}
function w0(t, e, r) {
    t === "focusin" ? (Bd(),
    oi = e,
    vi = r,
    oi.attachEvent("onpropertychange", jp)) : t === "focusout" && Bd()
}
function b0(t) {
    if (t === "selectionchange" || t === "keyup" || t === "keydown")
        return Sa(vi)
}
function x0(t, e) {
    if (t === "click")
        return Sa(e)
}
function _0(t, e) {
    if (t === "input" || t === "change")
        return Sa(e)
}
function S0(t, e) {
    return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
}
var Bt = typeof Object.is == "function" ? Object.is : S0;
function wi(t, e) {
    if (Bt(t, e))
        return !0;
    if (typeof t != "object" || t === null || typeof e != "object" || e === null)
        return !1;
    var r = Object.keys(t)
      , n = Object.keys(e);
    if (r.length !== n.length)
        return !1;
    for (n = 0; n < r.length; n++) {
        var s = r[n];
        if (!Ol.call(e, s) || !Bt(t[s], e[s]))
            return !1
    }
    return !0
}
function zd(t) {
    for (; t && t.firstChild; )
        t = t.firstChild;
    return t
}
function Md(t, e) {
    var r = zd(t);
    t = 0;
    for (var n; r; ) {
        if (r.nodeType === 3) {
            if (n = t + r.textContent.length,
            t <= e && n >= e)
                return {
                    node: r,
                    offset: e - t
                };
            t = n
        }
        e: {
            for (; r; ) {
                if (r.nextSibling) {
                    r = r.nextSibling;
                    break e
                }
                r = r.parentNode
            }
            r = void 0
        }
        r = zd(r)
    }
}
function Tp(t, e) {
    return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? Tp(t, e.parentNode) : "contains"in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1
}
function Pp() {
    for (var t = window, e = Uo(); e instanceof t.HTMLIFrameElement; ) {
        try {
            var r = typeof e.contentWindow.location.href == "string"
        } catch {
            r = !1
        }
        if (r)
            t = e.contentWindow;
        else
            break;
        e = Uo(t.document)
    }
    return e
}
function xc(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true")
}
function k0(t) {
    var e = Pp()
      , r = t.focusedElem
      , n = t.selectionRange;
    if (e !== r && r && r.ownerDocument && Tp(r.ownerDocument.documentElement, r)) {
        if (n !== null && xc(r)) {
            if (e = n.start,
            t = n.end,
            t === void 0 && (t = e),
            "selectionStart"in r)
                r.selectionStart = e,
                r.selectionEnd = Math.min(t, r.value.length);
            else if (t = (e = r.ownerDocument || document) && e.defaultView || window,
            t.getSelection) {
                t = t.getSelection();
                var s = r.textContent.length
                  , i = Math.min(n.start, s);
                n = n.end === void 0 ? i : Math.min(n.end, s),
                !t.extend && i > n && (s = n,
                n = i,
                i = s),
                s = Md(r, i);
                var o = Md(r, n);
                s && o && (t.rangeCount !== 1 || t.anchorNode !== s.node || t.anchorOffset !== s.offset || t.focusNode !== o.node || t.focusOffset !== o.offset) && (e = e.createRange(),
                e.setStart(s.node, s.offset),
                t.removeAllRanges(),
                i > n ? (t.addRange(e),
                t.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset),
                t.addRange(e)))
            }
        }
        for (e = [],
        t = r; t = t.parentNode; )
            t.nodeType === 1 && e.push({
                element: t,
                left: t.scrollLeft,
                top: t.scrollTop
            });
        for (typeof r.focus == "function" && r.focus(),
        r = 0; r < e.length; r++)
            t = e[r],
            t.element.scrollLeft = t.left,
            t.element.scrollTop = t.top
    }
}
var E0 = ar && "documentMode"in document && 11 >= document.documentMode
  , Vn = null
  , Ql = null
  , ai = null
  , Jl = !1;
function Wd(t, e, r) {
    var n = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument;
    Jl || Vn == null || Vn !== Uo(n) || (n = Vn,
    "selectionStart"in n && xc(n) ? n = {
        start: n.selectionStart,
        end: n.selectionEnd
    } : (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection(),
    n = {
        anchorNode: n.anchorNode,
        anchorOffset: n.anchorOffset,
        focusNode: n.focusNode,
        focusOffset: n.focusOffset
    }),
    ai && wi(ai, n) || (ai = n,
    n = Vo(Ql, "onSelect"),
    0 < n.length && (e = new vc("onSelect","select",null,e,r),
    t.push({
        event: e,
        listeners: n
    }),
    e.target = Vn)))
}
function ro(t, e) {
    var r = {};
    return r[t.toLowerCase()] = e.toLowerCase(),
    r["Webkit" + t] = "webkit" + e,
    r["Moz" + t] = "moz" + e,
    r
}
var Hn = {
    animationend: ro("Animation", "AnimationEnd"),
    animationiteration: ro("Animation", "AnimationIteration"),
    animationstart: ro("Animation", "AnimationStart"),
    transitionend: ro("Transition", "TransitionEnd")
}
  , ol = {}
  , Op = {};
ar && (Op = document.createElement("div").style,
"AnimationEvent"in window || (delete Hn.animationend.animation,
delete Hn.animationiteration.animation,
delete Hn.animationstart.animation),
"TransitionEvent"in window || delete Hn.transitionend.transition);
function ka(t) {
    if (ol[t])
        return ol[t];
    if (!Hn[t])
        return t;
    var e = Hn[t], r;
    for (r in e)
        if (e.hasOwnProperty(r) && r in Op)
            return ol[t] = e[r];
    return t
}
var Rp = ka("animationend")
  , Ap = ka("animationiteration")
  , Ip = ka("animationstart")
  , Np = ka("transitionend")
  , Lp = new Map
  , Gd = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function Vr(t, e) {
    Lp.set(t, e),
    Pn(e, [t])
}
for (var al = 0; al < Gd.length; al++) {
    var ll = Gd[al]
      , C0 = ll.toLowerCase()
      , j0 = ll[0].toUpperCase() + ll.slice(1);
    Vr(C0, "on" + j0)
}
Vr(Rp, "onAnimationEnd");
Vr(Ap, "onAnimationIteration");
Vr(Ip, "onAnimationStart");
Vr("dblclick", "onDoubleClick");
Vr("focusin", "onFocus");
Vr("focusout", "onBlur");
Vr(Np, "onTransitionEnd");
xs("onMouseEnter", ["mouseout", "mouseover"]);
xs("onMouseLeave", ["mouseout", "mouseover"]);
xs("onPointerEnter", ["pointerout", "pointerover"]);
xs("onPointerLeave", ["pointerout", "pointerover"]);
Pn("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Pn("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Pn("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Pn("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Pn("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Pn("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Xs = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , T0 = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xs));
function Vd(t, e, r) {
    var n = t.type || "unknown-event";
    t.currentTarget = r,
    Cv(n, e, void 0, t),
    t.currentTarget = null
}
function Dp(t, e) {
    e = (e & 4) !== 0;
    for (var r = 0; r < t.length; r++) {
        var n = t[r]
          , s = n.event;
        n = n.listeners;
        e: {
            var i = void 0;
            if (e)
                for (var o = n.length - 1; 0 <= o; o--) {
                    var a = n[o]
                      , l = a.instance
                      , c = a.currentTarget;
                    if (a = a.listener,
                    l !== i && s.isPropagationStopped())
                        break e;
                    Vd(s, a, c),
                    i = l
                }
            else
                for (o = 0; o < n.length; o++) {
                    if (a = n[o],
                    l = a.instance,
                    c = a.currentTarget,
                    a = a.listener,
                    l !== i && s.isPropagationStopped())
                        break e;
                    Vd(s, a, c),
                    i = l
                }
        }
    }
    if (Bo)
        throw t = Vl,
        Bo = !1,
        Vl = null,
        t
}
function pe(t, e) {
    var r = e[tu];
    r === void 0 && (r = e[tu] = new Set);
    var n = t + "__bubble";
    r.has(n) || ($p(e, t, 2, !1),
    r.add(n))
}
function ul(t, e, r) {
    var n = 0;
    e && (n |= 4),
    $p(r, t, n, e)
}
var no = "_reactListening" + Math.random().toString(36).slice(2);
function bi(t) {
    if (!t[no]) {
        t[no] = !0,
        Gf.forEach(function(r) {
            r !== "selectionchange" && (T0.has(r) || ul(r, !1, t),
            ul(r, !0, t))
        });
        var e = t.nodeType === 9 ? t : t.ownerDocument;
        e === null || e[no] || (e[no] = !0,
        ul("selectionchange", !1, e))
    }
}
function $p(t, e, r, n) {
    switch (bp(e)) {
    case 1:
        var s = Mv;
        break;
    case 4:
        s = Wv;
        break;
    default:
        s = mc
    }
    r = s.bind(null, e, r, t),
    s = void 0,
    !Gl || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (s = !0),
    n ? s !== void 0 ? t.addEventListener(e, r, {
        capture: !0,
        passive: s
    }) : t.addEventListener(e, r, !0) : s !== void 0 ? t.addEventListener(e, r, {
        passive: s
    }) : t.addEventListener(e, r, !1)
}
function cl(t, e, r, n, s) {
    var i = n;
    if (!(e & 1) && !(e & 2) && n !== null)
        e: for (; ; ) {
            if (n === null)
                return;
            var o = n.tag;
            if (o === 3 || o === 4) {
                var a = n.stateNode.containerInfo;
                if (a === s || a.nodeType === 8 && a.parentNode === s)
                    break;
                if (o === 4)
                    for (o = n.return; o !== null; ) {
                        var l = o.tag;
                        if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo,
                        l === s || l.nodeType === 8 && l.parentNode === s))
                            return;
                        o = o.return
                    }
                for (; a !== null; ) {
                    if (o = an(a),
                    o === null)
                        return;
                    if (l = o.tag,
                    l === 5 || l === 6) {
                        n = i = o;
                        continue e
                    }
                    a = a.parentNode
                }
            }
            n = n.return
        }
    op(function() {
        var c = i
          , d = hc(r)
          , h = [];
        e: {
            var f = Lp.get(t);
            if (f !== void 0) {
                var p = vc
                  , v = t;
                switch (t) {
                case "keypress":
                    if (Co(r) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    p = s0;
                    break;
                case "focusin":
                    v = "focus",
                    p = nl;
                    break;
                case "focusout":
                    v = "blur",
                    p = nl;
                    break;
                case "beforeblur":
                case "afterblur":
                    p = nl;
                    break;
                case "click":
                    if (r.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    p = Id;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    p = Hv;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    p = a0;
                    break;
                case Rp:
                case Ap:
                case Ip:
                    p = Qv;
                    break;
                case Np:
                    p = u0;
                    break;
                case "scroll":
                    p = Gv;
                    break;
                case "wheel":
                    p = d0;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    p = Xv;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    p = Ld
                }
                var w = (e & 4) !== 0
                  , b = !w && t === "scroll"
                  , g = w ? f !== null ? f + "Capture" : null : f;
                w = [];
                for (var m = c, y; m !== null; ) {
                    y = m;
                    var x = y.stateNode;
                    if (y.tag === 5 && x !== null && (y = x,
                    g !== null && (x = pi(m, g),
                    x != null && w.push(xi(m, x, y)))),
                    b)
                        break;
                    m = m.return
                }
                0 < w.length && (f = new p(f,v,null,r,d),
                h.push({
                    event: f,
                    listeners: w
                }))
            }
        }
        if (!(e & 7)) {
            e: {
                if (f = t === "mouseover" || t === "pointerover",
                p = t === "mouseout" || t === "pointerout",
                f && r !== Ml && (v = r.relatedTarget || r.fromElement) && (an(v) || v[lr]))
                    break e;
                if ((p || f) && (f = d.window === d ? d : (f = d.ownerDocument) ? f.defaultView || f.parentWindow : window,
                p ? (v = r.relatedTarget || r.toElement,
                p = c,
                v = v ? an(v) : null,
                v !== null && (b = On(v),
                v !== b || v.tag !== 5 && v.tag !== 6) && (v = null)) : (p = null,
                v = c),
                p !== v)) {
                    if (w = Id,
                    x = "onMouseLeave",
                    g = "onMouseEnter",
                    m = "mouse",
                    (t === "pointerout" || t === "pointerover") && (w = Ld,
                    x = "onPointerLeave",
                    g = "onPointerEnter",
                    m = "pointer"),
                    b = p == null ? f : qn(p),
                    y = v == null ? f : qn(v),
                    f = new w(x,m + "leave",p,r,d),
                    f.target = b,
                    f.relatedTarget = y,
                    x = null,
                    an(d) === c && (w = new w(g,m + "enter",v,r,d),
                    w.target = y,
                    w.relatedTarget = b,
                    x = w),
                    b = x,
                    p && v)
                        t: {
                            for (w = p,
                            g = v,
                            m = 0,
                            y = w; y; y = Nn(y))
                                m++;
                            for (y = 0,
                            x = g; x; x = Nn(x))
                                y++;
                            for (; 0 < m - y; )
                                w = Nn(w),
                                m--;
                            for (; 0 < y - m; )
                                g = Nn(g),
                                y--;
                            for (; m--; ) {
                                if (w === g || g !== null && w === g.alternate)
                                    break t;
                                w = Nn(w),
                                g = Nn(g)
                            }
                            w = null
                        }
                    else
                        w = null;
                    p !== null && Hd(h, f, p, w, !1),
                    v !== null && b !== null && Hd(h, b, v, w, !0)
                }
            }
            e: {
                if (f = c ? qn(c) : window,
                p = f.nodeName && f.nodeName.toLowerCase(),
                p === "select" || p === "input" && f.type === "file")
                    var k = v0;
                else if (Ud(f))
                    if (Cp)
                        k = _0;
                    else {
                        k = b0;
                        var C = w0
                    }
                else
                    (p = f.nodeName) && p.toLowerCase() === "input" && (f.type === "checkbox" || f.type === "radio") && (k = x0);
                if (k && (k = k(t, c))) {
                    Ep(h, k, r, d);
                    break e
                }
                C && C(t, f, c),
                t === "focusout" && (C = f._wrapperState) && C.controlled && f.type === "number" && $l(f, "number", f.value)
            }
            switch (C = c ? qn(c) : window,
            t) {
            case "focusin":
                (Ud(C) || C.contentEditable === "true") && (Vn = C,
                Ql = c,
                ai = null);
                break;
            case "focusout":
                ai = Ql = Vn = null;
                break;
            case "mousedown":
                Jl = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                Jl = !1,
                Wd(h, r, d);
                break;
            case "selectionchange":
                if (E0)
                    break;
            case "keydown":
            case "keyup":
                Wd(h, r, d)
            }
            var T;
            if (bc)
                e: {
                    switch (t) {
                    case "compositionstart":
                        var I = "onCompositionStart";
                        break e;
                    case "compositionend":
                        I = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        I = "onCompositionUpdate";
                        break e
                    }
                    I = void 0
                }
            else
                Gn ? Sp(t, r) && (I = "onCompositionEnd") : t === "keydown" && r.keyCode === 229 && (I = "onCompositionStart");
            I && (_p && r.locale !== "ko" && (Gn || I !== "onCompositionStart" ? I === "onCompositionEnd" && Gn && (T = xp()) : (Rr = d,
            yc = "value"in Rr ? Rr.value : Rr.textContent,
            Gn = !0)),
            C = Vo(c, I),
            0 < C.length && (I = new Nd(I,t,null,r,d),
            h.push({
                event: I,
                listeners: C
            }),
            T ? I.data = T : (T = kp(r),
            T !== null && (I.data = T)))),
            (T = f0 ? p0(t, r) : g0(t, r)) && (c = Vo(c, "onBeforeInput"),
            0 < c.length && (d = new Nd("onBeforeInput","beforeinput",null,r,d),
            h.push({
                event: d,
                listeners: c
            }),
            d.data = T))
        }
        Dp(h, e)
    })
}
function xi(t, e, r) {
    return {
        instance: t,
        listener: e,
        currentTarget: r
    }
}
function Vo(t, e) {
    for (var r = e + "Capture", n = []; t !== null; ) {
        var s = t
          , i = s.stateNode;
        s.tag === 5 && i !== null && (s = i,
        i = pi(t, r),
        i != null && n.unshift(xi(t, i, s)),
        i = pi(t, e),
        i != null && n.push(xi(t, i, s))),
        t = t.return
    }
    return n
}
function Nn(t) {
    if (t === null)
        return null;
    do
        t = t.return;
    while (t && t.tag !== 5);
    return t || null
}
function Hd(t, e, r, n, s) {
    for (var i = e._reactName, o = []; r !== null && r !== n; ) {
        var a = r
          , l = a.alternate
          , c = a.stateNode;
        if (l !== null && l === n)
            break;
        a.tag === 5 && c !== null && (a = c,
        s ? (l = pi(r, i),
        l != null && o.unshift(xi(r, l, a))) : s || (l = pi(r, i),
        l != null && o.push(xi(r, l, a)))),
        r = r.return
    }
    o.length !== 0 && t.push({
        event: e,
        listeners: o
    })
}
var P0 = /\r\n?/g
  , O0 = /\u0000|\uFFFD/g;
function qd(t) {
    return (typeof t == "string" ? t : "" + t).replace(P0, `
`).replace(O0, "")
}
function so(t, e, r) {
    if (e = qd(e),
    qd(t) !== e && r)
        throw Error(A(425))
}
function Ho() {}
var Xl = null
  , Yl = null;
function Zl(t, e) {
    return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var eu = typeof setTimeout == "function" ? setTimeout : void 0
  , R0 = typeof clearTimeout == "function" ? clearTimeout : void 0
  , Kd = typeof Promise == "function" ? Promise : void 0
  , A0 = typeof queueMicrotask == "function" ? queueMicrotask : typeof Kd < "u" ? function(t) {
    return Kd.resolve(null).then(t).catch(I0)
}
: eu;
function I0(t) {
    setTimeout(function() {
        throw t
    })
}
function dl(t, e) {
    var r = e
      , n = 0;
    do {
        var s = r.nextSibling;
        if (t.removeChild(r),
        s && s.nodeType === 8)
            if (r = s.data,
            r === "/$") {
                if (n === 0) {
                    t.removeChild(s),
                    yi(e);
                    return
                }
                n--
            } else
                r !== "$" && r !== "$?" && r !== "$!" || n++;
        r = s
    } while (r);
    yi(e)
}
function Dr(t) {
    for (; t != null; t = t.nextSibling) {
        var e = t.nodeType;
        if (e === 1 || e === 3)
            break;
        if (e === 8) {
            if (e = t.data,
            e === "$" || e === "$!" || e === "$?")
                break;
            if (e === "/$")
                return null
        }
    }
    return t
}
function Qd(t) {
    t = t.previousSibling;
    for (var e = 0; t; ) {
        if (t.nodeType === 8) {
            var r = t.data;
            if (r === "$" || r === "$!" || r === "$?") {
                if (e === 0)
                    return t;
                e--
            } else
                r === "/$" && e++
        }
        t = t.previousSibling
    }
    return null
}
var Is = Math.random().toString(36).slice(2)
  , Qt = "__reactFiber$" + Is
  , _i = "__reactProps$" + Is
  , lr = "__reactContainer$" + Is
  , tu = "__reactEvents$" + Is
  , N0 = "__reactListeners$" + Is
  , L0 = "__reactHandles$" + Is;
function an(t) {
    var e = t[Qt];
    if (e)
        return e;
    for (var r = t.parentNode; r; ) {
        if (e = r[lr] || r[Qt]) {
            if (r = e.alternate,
            e.child !== null || r !== null && r.child !== null)
                for (t = Qd(t); t !== null; ) {
                    if (r = t[Qt])
                        return r;
                    t = Qd(t)
                }
            return e
        }
        t = r,
        r = t.parentNode
    }
    return null
}
function Mi(t) {
    return t = t[Qt] || t[lr],
    !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t
}
function qn(t) {
    if (t.tag === 5 || t.tag === 6)
        return t.stateNode;
    throw Error(A(33))
}
function Ea(t) {
    return t[_i] || null
}
var ru = []
  , Kn = -1;
function Hr(t) {
    return {
        current: t
    }
}
function ge(t) {
    0 > Kn || (t.current = ru[Kn],
    ru[Kn] = null,
    Kn--)
}
function de(t, e) {
    Kn++,
    ru[Kn] = t.current,
    t.current = e
}
var Gr = {}
  , Qe = Hr(Gr)
  , dt = Hr(!1)
  , Sn = Gr;
function _s(t, e) {
    var r = t.type.contextTypes;
    if (!r)
        return Gr;
    var n = t.stateNode;
    if (n && n.__reactInternalMemoizedUnmaskedChildContext === e)
        return n.__reactInternalMemoizedMaskedChildContext;
    var s = {}, i;
    for (i in r)
        s[i] = e[i];
    return n && (t = t.stateNode,
    t.__reactInternalMemoizedUnmaskedChildContext = e,
    t.__reactInternalMemoizedMaskedChildContext = s),
    s
}
function ht(t) {
    return t = t.childContextTypes,
    t != null
}
function qo() {
    ge(dt),
    ge(Qe)
}
function Jd(t, e, r) {
    if (Qe.current !== Gr)
        throw Error(A(168));
    de(Qe, e),
    de(dt, r)
}
function Up(t, e, r) {
    var n = t.stateNode;
    if (e = e.childContextTypes,
    typeof n.getChildContext != "function")
        return r;
    n = n.getChildContext();
    for (var s in n)
        if (!(s in e))
            throw Error(A(108, wv(t) || "Unknown", s));
    return _e({}, r, n)
}
function Ko(t) {
    return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || Gr,
    Sn = Qe.current,
    de(Qe, t),
    de(dt, dt.current),
    !0
}
function Xd(t, e, r) {
    var n = t.stateNode;
    if (!n)
        throw Error(A(169));
    r ? (t = Up(t, e, Sn),
    n.__reactInternalMemoizedMergedChildContext = t,
    ge(dt),
    ge(Qe),
    de(Qe, t)) : ge(dt),
    de(dt, r)
}
var tr = null
  , Ca = !1
  , hl = !1;
function Fp(t) {
    tr === null ? tr = [t] : tr.push(t)
}
function D0(t) {
    Ca = !0,
    Fp(t)
}
function qr() {
    if (!hl && tr !== null) {
        hl = !0;
        var t = 0
          , e = le;
        try {
            var r = tr;
            for (le = 1; t < r.length; t++) {
                var n = r[t];
                do
                    n = n(!0);
                while (n !== null)
            }
            tr = null,
            Ca = !1
        } catch (s) {
            throw tr !== null && (tr = tr.slice(t + 1)),
            cp(fc, qr),
            s
        } finally {
            le = e,
            hl = !1
        }
    }
    return null
}
var Qn = []
  , Jn = 0
  , Qo = null
  , Jo = 0
  , St = []
  , kt = 0
  , kn = null
  , sr = 1
  , ir = "";
function Zr(t, e) {
    Qn[Jn++] = Jo,
    Qn[Jn++] = Qo,
    Qo = t,
    Jo = e
}
function Bp(t, e, r) {
    St[kt++] = sr,
    St[kt++] = ir,
    St[kt++] = kn,
    kn = t;
    var n = sr;
    t = ir;
    var s = 32 - Ut(n) - 1;
    n &= ~(1 << s),
    r += 1;
    var i = 32 - Ut(e) + s;
    if (30 < i) {
        var o = s - s % 5;
        i = (n & (1 << o) - 1).toString(32),
        n >>= o,
        s -= o,
        sr = 1 << 32 - Ut(e) + s | r << s | n,
        ir = i + t
    } else
        sr = 1 << i | r << s | n,
        ir = t
}
function _c(t) {
    t.return !== null && (Zr(t, 1),
    Bp(t, 1, 0))
}
function Sc(t) {
    for (; t === Qo; )
        Qo = Qn[--Jn],
        Qn[Jn] = null,
        Jo = Qn[--Jn],
        Qn[Jn] = null;
    for (; t === kn; )
        kn = St[--kt],
        St[kt] = null,
        ir = St[--kt],
        St[kt] = null,
        sr = St[--kt],
        St[kt] = null
}
var yt = null
  , mt = null
  , ye = !1
  , $t = null;
function zp(t, e) {
    var r = Et(5, null, null, 0);
    r.elementType = "DELETED",
    r.stateNode = e,
    r.return = t,
    e = t.deletions,
    e === null ? (t.deletions = [r],
    t.flags |= 16) : e.push(r)
}
function Yd(t, e) {
    switch (t.tag) {
    case 5:
        var r = t.type;
        return e = e.nodeType !== 1 || r.toLowerCase() !== e.nodeName.toLowerCase() ? null : e,
        e !== null ? (t.stateNode = e,
        yt = t,
        mt = Dr(e.firstChild),
        !0) : !1;
    case 6:
        return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e,
        e !== null ? (t.stateNode = e,
        yt = t,
        mt = null,
        !0) : !1;
    case 13:
        return e = e.nodeType !== 8 ? null : e,
        e !== null ? (r = kn !== null ? {
            id: sr,
            overflow: ir
        } : null,
        t.memoizedState = {
            dehydrated: e,
            treeContext: r,
            retryLane: 1073741824
        },
        r = Et(18, null, null, 0),
        r.stateNode = e,
        r.return = t,
        t.child = r,
        yt = t,
        mt = null,
        !0) : !1;
    default:
        return !1
    }
}
function nu(t) {
    return (t.mode & 1) !== 0 && (t.flags & 128) === 0
}
function su(t) {
    if (ye) {
        var e = mt;
        if (e) {
            var r = e;
            if (!Yd(t, e)) {
                if (nu(t))
                    throw Error(A(418));
                e = Dr(r.nextSibling);
                var n = yt;
                e && Yd(t, e) ? zp(n, r) : (t.flags = t.flags & -4097 | 2,
                ye = !1,
                yt = t)
            }
        } else {
            if (nu(t))
                throw Error(A(418));
            t.flags = t.flags & -4097 | 2,
            ye = !1,
            yt = t
        }
    }
}
function Zd(t) {
    for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
        t = t.return;
    yt = t
}
function io(t) {
    if (t !== yt)
        return !1;
    if (!ye)
        return Zd(t),
        ye = !0,
        !1;
    var e;
    if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type,
    e = e !== "head" && e !== "body" && !Zl(t.type, t.memoizedProps)),
    e && (e = mt)) {
        if (nu(t))
            throw Mp(),
            Error(A(418));
        for (; e; )
            zp(t, e),
            e = Dr(e.nextSibling)
    }
    if (Zd(t),
    t.tag === 13) {
        if (t = t.memoizedState,
        t = t !== null ? t.dehydrated : null,
        !t)
            throw Error(A(317));
        e: {
            for (t = t.nextSibling,
            e = 0; t; ) {
                if (t.nodeType === 8) {
                    var r = t.data;
                    if (r === "/$") {
                        if (e === 0) {
                            mt = Dr(t.nextSibling);
                            break e
                        }
                        e--
                    } else
                        r !== "$" && r !== "$!" && r !== "$?" || e++
                }
                t = t.nextSibling
            }
            mt = null
        }
    } else
        mt = yt ? Dr(t.stateNode.nextSibling) : null;
    return !0
}
function Mp() {
    for (var t = mt; t; )
        t = Dr(t.nextSibling)
}
function Ss() {
    mt = yt = null,
    ye = !1
}
function kc(t) {
    $t === null ? $t = [t] : $t.push(t)
}
var $0 = dr.ReactCurrentBatchConfig;
function Ws(t, e, r) {
    if (t = r.ref,
    t !== null && typeof t != "function" && typeof t != "object") {
        if (r._owner) {
            if (r = r._owner,
            r) {
                if (r.tag !== 1)
                    throw Error(A(309));
                var n = r.stateNode
            }
            if (!n)
                throw Error(A(147, t));
            var s = n
              , i = "" + t;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === i ? e.ref : (e = function(o) {
                var a = s.refs;
                o === null ? delete a[i] : a[i] = o
            }
            ,
            e._stringRef = i,
            e)
        }
        if (typeof t != "string")
            throw Error(A(284));
        if (!r._owner)
            throw Error(A(290, t))
    }
    return t
}
function oo(t, e) {
    throw t = Object.prototype.toString.call(e),
    Error(A(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t))
}
function eh(t) {
    var e = t._init;
    return e(t._payload)
}
function Wp(t) {
    function e(g, m) {
        if (t) {
            var y = g.deletions;
            y === null ? (g.deletions = [m],
            g.flags |= 16) : y.push(m)
        }
    }
    function r(g, m) {
        if (!t)
            return null;
        for (; m !== null; )
            e(g, m),
            m = m.sibling;
        return null
    }
    function n(g, m) {
        for (g = new Map; m !== null; )
            m.key !== null ? g.set(m.key, m) : g.set(m.index, m),
            m = m.sibling;
        return g
    }
    function s(g, m) {
        return g = Br(g, m),
        g.index = 0,
        g.sibling = null,
        g
    }
    function i(g, m, y) {
        return g.index = y,
        t ? (y = g.alternate,
        y !== null ? (y = y.index,
        y < m ? (g.flags |= 2,
        m) : y) : (g.flags |= 2,
        m)) : (g.flags |= 1048576,
        m)
    }
    function o(g) {
        return t && g.alternate === null && (g.flags |= 2),
        g
    }
    function a(g, m, y, x) {
        return m === null || m.tag !== 6 ? (m = wl(y, g.mode, x),
        m.return = g,
        m) : (m = s(m, y),
        m.return = g,
        m)
    }
    function l(g, m, y, x) {
        var k = y.type;
        return k === Wn ? d(g, m, y.props.children, x, y.key) : m !== null && (m.elementType === k || typeof k == "object" && k !== null && k.$$typeof === yr && eh(k) === m.type) ? (x = s(m, y.props),
        x.ref = Ws(g, m, y),
        x.return = g,
        x) : (x = Io(y.type, y.key, y.props, null, g.mode, x),
        x.ref = Ws(g, m, y),
        x.return = g,
        x)
    }
    function c(g, m, y, x) {
        return m === null || m.tag !== 4 || m.stateNode.containerInfo !== y.containerInfo || m.stateNode.implementation !== y.implementation ? (m = bl(y, g.mode, x),
        m.return = g,
        m) : (m = s(m, y.children || []),
        m.return = g,
        m)
    }
    function d(g, m, y, x, k) {
        return m === null || m.tag !== 7 ? (m = _n(y, g.mode, x, k),
        m.return = g,
        m) : (m = s(m, y),
        m.return = g,
        m)
    }
    function h(g, m, y) {
        if (typeof m == "string" && m !== "" || typeof m == "number")
            return m = wl("" + m, g.mode, y),
            m.return = g,
            m;
        if (typeof m == "object" && m !== null) {
            switch (m.$$typeof) {
            case Qi:
                return y = Io(m.type, m.key, m.props, null, g.mode, y),
                y.ref = Ws(g, null, m),
                y.return = g,
                y;
            case Mn:
                return m = bl(m, g.mode, y),
                m.return = g,
                m;
            case yr:
                var x = m._init;
                return h(g, x(m._payload), y)
            }
            if (Qs(m) || Us(m))
                return m = _n(m, g.mode, y, null),
                m.return = g,
                m;
            oo(g, m)
        }
        return null
    }
    function f(g, m, y, x) {
        var k = m !== null ? m.key : null;
        if (typeof y == "string" && y !== "" || typeof y == "number")
            return k !== null ? null : a(g, m, "" + y, x);
        if (typeof y == "object" && y !== null) {
            switch (y.$$typeof) {
            case Qi:
                return y.key === k ? l(g, m, y, x) : null;
            case Mn:
                return y.key === k ? c(g, m, y, x) : null;
            case yr:
                return k = y._init,
                f(g, m, k(y._payload), x)
            }
            if (Qs(y) || Us(y))
                return k !== null ? null : d(g, m, y, x, null);
            oo(g, y)
        }
        return null
    }
    function p(g, m, y, x, k) {
        if (typeof x == "string" && x !== "" || typeof x == "number")
            return g = g.get(y) || null,
            a(m, g, "" + x, k);
        if (typeof x == "object" && x !== null) {
            switch (x.$$typeof) {
            case Qi:
                return g = g.get(x.key === null ? y : x.key) || null,
                l(m, g, x, k);
            case Mn:
                return g = g.get(x.key === null ? y : x.key) || null,
                c(m, g, x, k);
            case yr:
                var C = x._init;
                return p(g, m, y, C(x._payload), k)
            }
            if (Qs(x) || Us(x))
                return g = g.get(y) || null,
                d(m, g, x, k, null);
            oo(m, x)
        }
        return null
    }
    function v(g, m, y, x) {
        for (var k = null, C = null, T = m, I = m = 0, z = null; T !== null && I < y.length; I++) {
            T.index > I ? (z = T,
            T = null) : z = T.sibling;
            var N = f(g, T, y[I], x);
            if (N === null) {
                T === null && (T = z);
                break
            }
            t && T && N.alternate === null && e(g, T),
            m = i(N, m, I),
            C === null ? k = N : C.sibling = N,
            C = N,
            T = z
        }
        if (I === y.length)
            return r(g, T),
            ye && Zr(g, I),
            k;
        if (T === null) {
            for (; I < y.length; I++)
                T = h(g, y[I], x),
                T !== null && (m = i(T, m, I),
                C === null ? k = T : C.sibling = T,
                C = T);
            return ye && Zr(g, I),
            k
        }
        for (T = n(g, T); I < y.length; I++)
            z = p(T, g, I, y[I], x),
            z !== null && (t && z.alternate !== null && T.delete(z.key === null ? I : z.key),
            m = i(z, m, I),
            C === null ? k = z : C.sibling = z,
            C = z);
        return t && T.forEach(function(Z) {
            return e(g, Z)
        }),
        ye && Zr(g, I),
        k
    }
    function w(g, m, y, x) {
        var k = Us(y);
        if (typeof k != "function")
            throw Error(A(150));
        if (y = k.call(y),
        y == null)
            throw Error(A(151));
        for (var C = k = null, T = m, I = m = 0, z = null, N = y.next(); T !== null && !N.done; I++,
        N = y.next()) {
            T.index > I ? (z = T,
            T = null) : z = T.sibling;
            var Z = f(g, T, N.value, x);
            if (Z === null) {
                T === null && (T = z);
                break
            }
            t && T && Z.alternate === null && e(g, T),
            m = i(Z, m, I),
            C === null ? k = Z : C.sibling = Z,
            C = Z,
            T = z
        }
        if (N.done)
            return r(g, T),
            ye && Zr(g, I),
            k;
        if (T === null) {
            for (; !N.done; I++,
            N = y.next())
                N = h(g, N.value, x),
                N !== null && (m = i(N, m, I),
                C === null ? k = N : C.sibling = N,
                C = N);
            return ye && Zr(g, I),
            k
        }
        for (T = n(g, T); !N.done; I++,
        N = y.next())
            N = p(T, g, I, N.value, x),
            N !== null && (t && N.alternate !== null && T.delete(N.key === null ? I : N.key),
            m = i(N, m, I),
            C === null ? k = N : C.sibling = N,
            C = N);
        return t && T.forEach(function(V) {
            return e(g, V)
        }),
        ye && Zr(g, I),
        k
    }
    function b(g, m, y, x) {
        if (typeof y == "object" && y !== null && y.type === Wn && y.key === null && (y = y.props.children),
        typeof y == "object" && y !== null) {
            switch (y.$$typeof) {
            case Qi:
                e: {
                    for (var k = y.key, C = m; C !== null; ) {
                        if (C.key === k) {
                            if (k = y.type,
                            k === Wn) {
                                if (C.tag === 7) {
                                    r(g, C.sibling),
                                    m = s(C, y.props.children),
                                    m.return = g,
                                    g = m;
                                    break e
                                }
                            } else if (C.elementType === k || typeof k == "object" && k !== null && k.$$typeof === yr && eh(k) === C.type) {
                                r(g, C.sibling),
                                m = s(C, y.props),
                                m.ref = Ws(g, C, y),
                                m.return = g,
                                g = m;
                                break e
                            }
                            r(g, C);
                            break
                        } else
                            e(g, C);
                        C = C.sibling
                    }
                    y.type === Wn ? (m = _n(y.props.children, g.mode, x, y.key),
                    m.return = g,
                    g = m) : (x = Io(y.type, y.key, y.props, null, g.mode, x),
                    x.ref = Ws(g, m, y),
                    x.return = g,
                    g = x)
                }
                return o(g);
            case Mn:
                e: {
                    for (C = y.key; m !== null; ) {
                        if (m.key === C)
                            if (m.tag === 4 && m.stateNode.containerInfo === y.containerInfo && m.stateNode.implementation === y.implementation) {
                                r(g, m.sibling),
                                m = s(m, y.children || []),
                                m.return = g,
                                g = m;
                                break e
                            } else {
                                r(g, m);
                                break
                            }
                        else
                            e(g, m);
                        m = m.sibling
                    }
                    m = bl(y, g.mode, x),
                    m.return = g,
                    g = m
                }
                return o(g);
            case yr:
                return C = y._init,
                b(g, m, C(y._payload), x)
            }
            if (Qs(y))
                return v(g, m, y, x);
            if (Us(y))
                return w(g, m, y, x);
            oo(g, y)
        }
        return typeof y == "string" && y !== "" || typeof y == "number" ? (y = "" + y,
        m !== null && m.tag === 6 ? (r(g, m.sibling),
        m = s(m, y),
        m.return = g,
        g = m) : (r(g, m),
        m = wl(y, g.mode, x),
        m.return = g,
        g = m),
        o(g)) : r(g, m)
    }
    return b
}
var ks = Wp(!0)
  , Gp = Wp(!1)
  , Xo = Hr(null)
  , Yo = null
  , Xn = null
  , Ec = null;
function Cc() {
    Ec = Xn = Yo = null
}
function jc(t) {
    var e = Xo.current;
    ge(Xo),
    t._currentValue = e
}
function iu(t, e, r) {
    for (; t !== null; ) {
        var n = t.alternate;
        if ((t.childLanes & e) !== e ? (t.childLanes |= e,
        n !== null && (n.childLanes |= e)) : n !== null && (n.childLanes & e) !== e && (n.childLanes |= e),
        t === r)
            break;
        t = t.return
    }
}
function ss(t, e) {
    Yo = t,
    Ec = Xn = null,
    t = t.dependencies,
    t !== null && t.firstContext !== null && (t.lanes & e && (ct = !0),
    t.firstContext = null)
}
function jt(t) {
    var e = t._currentValue;
    if (Ec !== t)
        if (t = {
            context: t,
            memoizedValue: e,
            next: null
        },
        Xn === null) {
            if (Yo === null)
                throw Error(A(308));
            Xn = t,
            Yo.dependencies = {
                lanes: 0,
                firstContext: t
            }
        } else
            Xn = Xn.next = t;
    return e
}
var ln = null;
function Tc(t) {
    ln === null ? ln = [t] : ln.push(t)
}
function Vp(t, e, r, n) {
    var s = e.interleaved;
    return s === null ? (r.next = r,
    Tc(e)) : (r.next = s.next,
    s.next = r),
    e.interleaved = r,
    ur(t, n)
}
function ur(t, e) {
    t.lanes |= e;
    var r = t.alternate;
    for (r !== null && (r.lanes |= e),
    r = t,
    t = t.return; t !== null; )
        t.childLanes |= e,
        r = t.alternate,
        r !== null && (r.childLanes |= e),
        r = t,
        t = t.return;
    return r.tag === 3 ? r.stateNode : null
}
var vr = !1;
function Pc(t) {
    t.updateQueue = {
        baseState: t.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function Hp(t, e) {
    t = t.updateQueue,
    e.updateQueue === t && (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects
    })
}
function or(t, e) {
    return {
        eventTime: t,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function $r(t, e, r) {
    var n = t.updateQueue;
    if (n === null)
        return null;
    if (n = n.shared,
    re & 2) {
        var s = n.pending;
        return s === null ? e.next = e : (e.next = s.next,
        s.next = e),
        n.pending = e,
        ur(t, r)
    }
    return s = n.interleaved,
    s === null ? (e.next = e,
    Tc(n)) : (e.next = s.next,
    s.next = e),
    n.interleaved = e,
    ur(t, r)
}
function jo(t, e, r) {
    if (e = e.updateQueue,
    e !== null && (e = e.shared,
    (r & 4194240) !== 0)) {
        var n = e.lanes;
        n &= t.pendingLanes,
        r |= n,
        e.lanes = r,
        pc(t, r)
    }
}
function th(t, e) {
    var r = t.updateQueue
      , n = t.alternate;
    if (n !== null && (n = n.updateQueue,
    r === n)) {
        var s = null
          , i = null;
        if (r = r.firstBaseUpdate,
        r !== null) {
            do {
                var o = {
                    eventTime: r.eventTime,
                    lane: r.lane,
                    tag: r.tag,
                    payload: r.payload,
                    callback: r.callback,
                    next: null
                };
                i === null ? s = i = o : i = i.next = o,
                r = r.next
            } while (r !== null);
            i === null ? s = i = e : i = i.next = e
        } else
            s = i = e;
        r = {
            baseState: n.baseState,
            firstBaseUpdate: s,
            lastBaseUpdate: i,
            shared: n.shared,
            effects: n.effects
        },
        t.updateQueue = r;
        return
    }
    t = r.lastBaseUpdate,
    t === null ? r.firstBaseUpdate = e : t.next = e,
    r.lastBaseUpdate = e
}
function Zo(t, e, r, n) {
    var s = t.updateQueue;
    vr = !1;
    var i = s.firstBaseUpdate
      , o = s.lastBaseUpdate
      , a = s.shared.pending;
    if (a !== null) {
        s.shared.pending = null;
        var l = a
          , c = l.next;
        l.next = null,
        o === null ? i = c : o.next = c,
        o = l;
        var d = t.alternate;
        d !== null && (d = d.updateQueue,
        a = d.lastBaseUpdate,
        a !== o && (a === null ? d.firstBaseUpdate = c : a.next = c,
        d.lastBaseUpdate = l))
    }
    if (i !== null) {
        var h = s.baseState;
        o = 0,
        d = c = l = null,
        a = i;
        do {
            var f = a.lane
              , p = a.eventTime;
            if ((n & f) === f) {
                d !== null && (d = d.next = {
                    eventTime: p,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var v = t
                      , w = a;
                    switch (f = e,
                    p = r,
                    w.tag) {
                    case 1:
                        if (v = w.payload,
                        typeof v == "function") {
                            h = v.call(p, h, f);
                            break e
                        }
                        h = v;
                        break e;
                    case 3:
                        v.flags = v.flags & -65537 | 128;
                    case 0:
                        if (v = w.payload,
                        f = typeof v == "function" ? v.call(p, h, f) : v,
                        f == null)
                            break e;
                        h = _e({}, h, f);
                        break e;
                    case 2:
                        vr = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (t.flags |= 64,
                f = s.effects,
                f === null ? s.effects = [a] : f.push(a))
            } else
                p = {
                    eventTime: p,
                    lane: f,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                },
                d === null ? (c = d = p,
                l = h) : d = d.next = p,
                o |= f;
            if (a = a.next,
            a === null) {
                if (a = s.shared.pending,
                a === null)
                    break;
                f = a,
                a = f.next,
                f.next = null,
                s.lastBaseUpdate = f,
                s.shared.pending = null
            }
        } while (!0);
        if (d === null && (l = h),
        s.baseState = l,
        s.firstBaseUpdate = c,
        s.lastBaseUpdate = d,
        e = s.shared.interleaved,
        e !== null) {
            s = e;
            do
                o |= s.lane,
                s = s.next;
            while (s !== e)
        } else
            i === null && (s.shared.lanes = 0);
        Cn |= o,
        t.lanes = o,
        t.memoizedState = h
    }
}
function rh(t, e, r) {
    if (t = e.effects,
    e.effects = null,
    t !== null)
        for (e = 0; e < t.length; e++) {
            var n = t[e]
              , s = n.callback;
            if (s !== null) {
                if (n.callback = null,
                n = r,
                typeof s != "function")
                    throw Error(A(191, s));
                s.call(n)
            }
        }
}
var Wi = {}
  , Xt = Hr(Wi)
  , Si = Hr(Wi)
  , ki = Hr(Wi);
function un(t) {
    if (t === Wi)
        throw Error(A(174));
    return t
}
function Oc(t, e) {
    switch (de(ki, e),
    de(Si, t),
    de(Xt, Wi),
    t = e.nodeType,
    t) {
    case 9:
    case 11:
        e = (e = e.documentElement) ? e.namespaceURI : Fl(null, "");
        break;
    default:
        t = t === 8 ? e.parentNode : e,
        e = t.namespaceURI || null,
        t = t.tagName,
        e = Fl(e, t)
    }
    ge(Xt),
    de(Xt, e)
}
function Es() {
    ge(Xt),
    ge(Si),
    ge(ki)
}
function qp(t) {
    un(ki.current);
    var e = un(Xt.current)
      , r = Fl(e, t.type);
    e !== r && (de(Si, t),
    de(Xt, r))
}
function Rc(t) {
    Si.current === t && (ge(Xt),
    ge(Si))
}
var be = Hr(0);
function ea(t) {
    for (var e = t; e !== null; ) {
        if (e.tag === 13) {
            var r = e.memoizedState;
            if (r !== null && (r = r.dehydrated,
            r === null || r.data === "$?" || r.data === "$!"))
                return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128)
                return e
        } else if (e.child !== null) {
            e.child.return = e,
            e = e.child;
            continue
        }
        if (e === t)
            break;
        for (; e.sibling === null; ) {
            if (e.return === null || e.return === t)
                return null;
            e = e.return
        }
        e.sibling.return = e.return,
        e = e.sibling
    }
    return null
}
var fl = [];
function Ac() {
    for (var t = 0; t < fl.length; t++)
        fl[t]._workInProgressVersionPrimary = null;
    fl.length = 0
}
var To = dr.ReactCurrentDispatcher
  , pl = dr.ReactCurrentBatchConfig
  , En = 0
  , xe = null
  , Pe = null
  , Ae = null
  , ta = !1
  , li = !1
  , Ei = 0
  , U0 = 0;
function Ve() {
    throw Error(A(321))
}
function Ic(t, e) {
    if (e === null)
        return !1;
    for (var r = 0; r < e.length && r < t.length; r++)
        if (!Bt(t[r], e[r]))
            return !1;
    return !0
}
function Nc(t, e, r, n, s, i) {
    if (En = i,
    xe = e,
    e.memoizedState = null,
    e.updateQueue = null,
    e.lanes = 0,
    To.current = t === null || t.memoizedState === null ? M0 : W0,
    t = r(n, s),
    li) {
        i = 0;
        do {
            if (li = !1,
            Ei = 0,
            25 <= i)
                throw Error(A(301));
            i += 1,
            Ae = Pe = null,
            e.updateQueue = null,
            To.current = G0,
            t = r(n, s)
        } while (li)
    }
    if (To.current = ra,
    e = Pe !== null && Pe.next !== null,
    En = 0,
    Ae = Pe = xe = null,
    ta = !1,
    e)
        throw Error(A(300));
    return t
}
function Lc() {
    var t = Ei !== 0;
    return Ei = 0,
    t
}
function Gt() {
    var t = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return Ae === null ? xe.memoizedState = Ae = t : Ae = Ae.next = t,
    Ae
}
function Tt() {
    if (Pe === null) {
        var t = xe.alternate;
        t = t !== null ? t.memoizedState : null
    } else
        t = Pe.next;
    var e = Ae === null ? xe.memoizedState : Ae.next;
    if (e !== null)
        Ae = e,
        Pe = t;
    else {
        if (t === null)
            throw Error(A(310));
        Pe = t,
        t = {
            memoizedState: Pe.memoizedState,
            baseState: Pe.baseState,
            baseQueue: Pe.baseQueue,
            queue: Pe.queue,
            next: null
        },
        Ae === null ? xe.memoizedState = Ae = t : Ae = Ae.next = t
    }
    return Ae
}
function Ci(t, e) {
    return typeof e == "function" ? e(t) : e
}
function gl(t) {
    var e = Tt()
      , r = e.queue;
    if (r === null)
        throw Error(A(311));
    r.lastRenderedReducer = t;
    var n = Pe
      , s = n.baseQueue
      , i = r.pending;
    if (i !== null) {
        if (s !== null) {
            var o = s.next;
            s.next = i.next,
            i.next = o
        }
        n.baseQueue = s = i,
        r.pending = null
    }
    if (s !== null) {
        i = s.next,
        n = n.baseState;
        var a = o = null
          , l = null
          , c = i;
        do {
            var d = c.lane;
            if ((En & d) === d)
                l !== null && (l = l.next = {
                    lane: 0,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                }),
                n = c.hasEagerState ? c.eagerState : t(n, c.action);
            else {
                var h = {
                    lane: d,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                };
                l === null ? (a = l = h,
                o = n) : l = l.next = h,
                xe.lanes |= d,
                Cn |= d
            }
            c = c.next
        } while (c !== null && c !== i);
        l === null ? o = n : l.next = a,
        Bt(n, e.memoizedState) || (ct = !0),
        e.memoizedState = n,
        e.baseState = o,
        e.baseQueue = l,
        r.lastRenderedState = n
    }
    if (t = r.interleaved,
    t !== null) {
        s = t;
        do
            i = s.lane,
            xe.lanes |= i,
            Cn |= i,
            s = s.next;
        while (s !== t)
    } else
        s === null && (r.lanes = 0);
    return [e.memoizedState, r.dispatch]
}
function ml(t) {
    var e = Tt()
      , r = e.queue;
    if (r === null)
        throw Error(A(311));
    r.lastRenderedReducer = t;
    var n = r.dispatch
      , s = r.pending
      , i = e.memoizedState;
    if (s !== null) {
        r.pending = null;
        var o = s = s.next;
        do
            i = t(i, o.action),
            o = o.next;
        while (o !== s);
        Bt(i, e.memoizedState) || (ct = !0),
        e.memoizedState = i,
        e.baseQueue === null && (e.baseState = i),
        r.lastRenderedState = i
    }
    return [i, n]
}
function Kp() {}
function Qp(t, e) {
    var r = xe
      , n = Tt()
      , s = e()
      , i = !Bt(n.memoizedState, s);
    if (i && (n.memoizedState = s,
    ct = !0),
    n = n.queue,
    Dc(Yp.bind(null, r, n, t), [t]),
    n.getSnapshot !== e || i || Ae !== null && Ae.memoizedState.tag & 1) {
        if (r.flags |= 2048,
        ji(9, Xp.bind(null, r, n, s, e), void 0, null),
        Ne === null)
            throw Error(A(349));
        En & 30 || Jp(r, e, s)
    }
    return s
}
function Jp(t, e, r) {
    t.flags |= 16384,
    t = {
        getSnapshot: e,
        value: r
    },
    e = xe.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    xe.updateQueue = e,
    e.stores = [t]) : (r = e.stores,
    r === null ? e.stores = [t] : r.push(t))
}
function Xp(t, e, r, n) {
    e.value = r,
    e.getSnapshot = n,
    Zp(e) && eg(t)
}
function Yp(t, e, r) {
    return r(function() {
        Zp(e) && eg(t)
    })
}
function Zp(t) {
    var e = t.getSnapshot;
    t = t.value;
    try {
        var r = e();
        return !Bt(t, r)
    } catch {
        return !0
    }
}
function eg(t) {
    var e = ur(t, 1);
    e !== null && Ft(e, t, 1, -1)
}
function nh(t) {
    var e = Gt();
    return typeof t == "function" && (t = t()),
    e.memoizedState = e.baseState = t,
    t = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Ci,
        lastRenderedState: t
    },
    e.queue = t,
    t = t.dispatch = z0.bind(null, xe, t),
    [e.memoizedState, t]
}
function ji(t, e, r, n) {
    return t = {
        tag: t,
        create: e,
        destroy: r,
        deps: n,
        next: null
    },
    e = xe.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    xe.updateQueue = e,
    e.lastEffect = t.next = t) : (r = e.lastEffect,
    r === null ? e.lastEffect = t.next = t : (n = r.next,
    r.next = t,
    t.next = n,
    e.lastEffect = t)),
    t
}
function tg() {
    return Tt().memoizedState
}
function Po(t, e, r, n) {
    var s = Gt();
    xe.flags |= t,
    s.memoizedState = ji(1 | e, r, void 0, n === void 0 ? null : n)
}
function ja(t, e, r, n) {
    var s = Tt();
    n = n === void 0 ? null : n;
    var i = void 0;
    if (Pe !== null) {
        var o = Pe.memoizedState;
        if (i = o.destroy,
        n !== null && Ic(n, o.deps)) {
            s.memoizedState = ji(e, r, i, n);
            return
        }
    }
    xe.flags |= t,
    s.memoizedState = ji(1 | e, r, i, n)
}
function sh(t, e) {
    return Po(8390656, 8, t, e)
}
function Dc(t, e) {
    return ja(2048, 8, t, e)
}
function rg(t, e) {
    return ja(4, 2, t, e)
}
function ng(t, e) {
    return ja(4, 4, t, e)
}
function sg(t, e) {
    if (typeof e == "function")
        return t = t(),
        e(t),
        function() {
            e(null)
        }
        ;
    if (e != null)
        return t = t(),
        e.current = t,
        function() {
            e.current = null
        }
}
function ig(t, e, r) {
    return r = r != null ? r.concat([t]) : null,
    ja(4, 4, sg.bind(null, e, t), r)
}
function $c() {}
function og(t, e) {
    var r = Tt();
    e = e === void 0 ? null : e;
    var n = r.memoizedState;
    return n !== null && e !== null && Ic(e, n[1]) ? n[0] : (r.memoizedState = [t, e],
    t)
}
function ag(t, e) {
    var r = Tt();
    e = e === void 0 ? null : e;
    var n = r.memoizedState;
    return n !== null && e !== null && Ic(e, n[1]) ? n[0] : (t = t(),
    r.memoizedState = [t, e],
    t)
}
function lg(t, e, r) {
    return En & 21 ? (Bt(r, e) || (r = fp(),
    xe.lanes |= r,
    Cn |= r,
    t.baseState = !0),
    e) : (t.baseState && (t.baseState = !1,
    ct = !0),
    t.memoizedState = r)
}
function F0(t, e) {
    var r = le;
    le = r !== 0 && 4 > r ? r : 4,
    t(!0);
    var n = pl.transition;
    pl.transition = {};
    try {
        t(!1),
        e()
    } finally {
        le = r,
        pl.transition = n
    }
}
function ug() {
    return Tt().memoizedState
}
function B0(t, e, r) {
    var n = Fr(t);
    if (r = {
        lane: n,
        action: r,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    cg(t))
        dg(e, r);
    else if (r = Vp(t, e, r, n),
    r !== null) {
        var s = tt();
        Ft(r, t, n, s),
        hg(r, e, n)
    }
}
function z0(t, e, r) {
    var n = Fr(t)
      , s = {
        lane: n,
        action: r,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (cg(t))
        dg(e, s);
    else {
        var i = t.alternate;
        if (t.lanes === 0 && (i === null || i.lanes === 0) && (i = e.lastRenderedReducer,
        i !== null))
            try {
                var o = e.lastRenderedState
                  , a = i(o, r);
                if (s.hasEagerState = !0,
                s.eagerState = a,
                Bt(a, o)) {
                    var l = e.interleaved;
                    l === null ? (s.next = s,
                    Tc(e)) : (s.next = l.next,
                    l.next = s),
                    e.interleaved = s;
                    return
                }
            } catch {} finally {}
        r = Vp(t, e, s, n),
        r !== null && (s = tt(),
        Ft(r, t, n, s),
        hg(r, e, n))
    }
}
function cg(t) {
    var e = t.alternate;
    return t === xe || e !== null && e === xe
}
function dg(t, e) {
    li = ta = !0;
    var r = t.pending;
    r === null ? e.next = e : (e.next = r.next,
    r.next = e),
    t.pending = e
}
function hg(t, e, r) {
    if (r & 4194240) {
        var n = e.lanes;
        n &= t.pendingLanes,
        r |= n,
        e.lanes = r,
        pc(t, r)
    }
}
var ra = {
    readContext: jt,
    useCallback: Ve,
    useContext: Ve,
    useEffect: Ve,
    useImperativeHandle: Ve,
    useInsertionEffect: Ve,
    useLayoutEffect: Ve,
    useMemo: Ve,
    useReducer: Ve,
    useRef: Ve,
    useState: Ve,
    useDebugValue: Ve,
    useDeferredValue: Ve,
    useTransition: Ve,
    useMutableSource: Ve,
    useSyncExternalStore: Ve,
    useId: Ve,
    unstable_isNewReconciler: !1
}
  , M0 = {
    readContext: jt,
    useCallback: function(t, e) {
        return Gt().memoizedState = [t, e === void 0 ? null : e],
        t
    },
    useContext: jt,
    useEffect: sh,
    useImperativeHandle: function(t, e, r) {
        return r = r != null ? r.concat([t]) : null,
        Po(4194308, 4, sg.bind(null, e, t), r)
    },
    useLayoutEffect: function(t, e) {
        return Po(4194308, 4, t, e)
    },
    useInsertionEffect: function(t, e) {
        return Po(4, 2, t, e)
    },
    useMemo: function(t, e) {
        var r = Gt();
        return e = e === void 0 ? null : e,
        t = t(),
        r.memoizedState = [t, e],
        t
    },
    useReducer: function(t, e, r) {
        var n = Gt();
        return e = r !== void 0 ? r(e) : e,
        n.memoizedState = n.baseState = e,
        t = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: t,
            lastRenderedState: e
        },
        n.queue = t,
        t = t.dispatch = B0.bind(null, xe, t),
        [n.memoizedState, t]
    },
    useRef: function(t) {
        var e = Gt();
        return t = {
            current: t
        },
        e.memoizedState = t
    },
    useState: nh,
    useDebugValue: $c,
    useDeferredValue: function(t) {
        return Gt().memoizedState = t
    },
    useTransition: function() {
        var t = nh(!1)
          , e = t[0];
        return t = F0.bind(null, t[1]),
        Gt().memoizedState = t,
        [e, t]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(t, e, r) {
        var n = xe
          , s = Gt();
        if (ye) {
            if (r === void 0)
                throw Error(A(407));
            r = r()
        } else {
            if (r = e(),
            Ne === null)
                throw Error(A(349));
            En & 30 || Jp(n, e, r)
        }
        s.memoizedState = r;
        var i = {
            value: r,
            getSnapshot: e
        };
        return s.queue = i,
        sh(Yp.bind(null, n, i, t), [t]),
        n.flags |= 2048,
        ji(9, Xp.bind(null, n, i, r, e), void 0, null),
        r
    },
    useId: function() {
        var t = Gt()
          , e = Ne.identifierPrefix;
        if (ye) {
            var r = ir
              , n = sr;
            r = (n & ~(1 << 32 - Ut(n) - 1)).toString(32) + r,
            e = ":" + e + "R" + r,
            r = Ei++,
            0 < r && (e += "H" + r.toString(32)),
            e += ":"
        } else
            r = U0++,
            e = ":" + e + "r" + r.toString(32) + ":";
        return t.memoizedState = e
    },
    unstable_isNewReconciler: !1
}
  , W0 = {
    readContext: jt,
    useCallback: og,
    useContext: jt,
    useEffect: Dc,
    useImperativeHandle: ig,
    useInsertionEffect: rg,
    useLayoutEffect: ng,
    useMemo: ag,
    useReducer: gl,
    useRef: tg,
    useState: function() {
        return gl(Ci)
    },
    useDebugValue: $c,
    useDeferredValue: function(t) {
        var e = Tt();
        return lg(e, Pe.memoizedState, t)
    },
    useTransition: function() {
        var t = gl(Ci)[0]
          , e = Tt().memoizedState;
        return [t, e]
    },
    useMutableSource: Kp,
    useSyncExternalStore: Qp,
    useId: ug,
    unstable_isNewReconciler: !1
}
  , G0 = {
    readContext: jt,
    useCallback: og,
    useContext: jt,
    useEffect: Dc,
    useImperativeHandle: ig,
    useInsertionEffect: rg,
    useLayoutEffect: ng,
    useMemo: ag,
    useReducer: ml,
    useRef: tg,
    useState: function() {
        return ml(Ci)
    },
    useDebugValue: $c,
    useDeferredValue: function(t) {
        var e = Tt();
        return Pe === null ? e.memoizedState = t : lg(e, Pe.memoizedState, t)
    },
    useTransition: function() {
        var t = ml(Ci)[0]
          , e = Tt().memoizedState;
        return [t, e]
    },
    useMutableSource: Kp,
    useSyncExternalStore: Qp,
    useId: ug,
    unstable_isNewReconciler: !1
};
function Rt(t, e) {
    if (t && t.defaultProps) {
        e = _e({}, e),
        t = t.defaultProps;
        for (var r in t)
            e[r] === void 0 && (e[r] = t[r]);
        return e
    }
    return e
}
function ou(t, e, r, n) {
    e = t.memoizedState,
    r = r(n, e),
    r = r == null ? e : _e({}, e, r),
    t.memoizedState = r,
    t.lanes === 0 && (t.updateQueue.baseState = r)
}
var Ta = {
    isMounted: function(t) {
        return (t = t._reactInternals) ? On(t) === t : !1
    },
    enqueueSetState: function(t, e, r) {
        t = t._reactInternals;
        var n = tt()
          , s = Fr(t)
          , i = or(n, s);
        i.payload = e,
        r != null && (i.callback = r),
        e = $r(t, i, s),
        e !== null && (Ft(e, t, s, n),
        jo(e, t, s))
    },
    enqueueReplaceState: function(t, e, r) {
        t = t._reactInternals;
        var n = tt()
          , s = Fr(t)
          , i = or(n, s);
        i.tag = 1,
        i.payload = e,
        r != null && (i.callback = r),
        e = $r(t, i, s),
        e !== null && (Ft(e, t, s, n),
        jo(e, t, s))
    },
    enqueueForceUpdate: function(t, e) {
        t = t._reactInternals;
        var r = tt()
          , n = Fr(t)
          , s = or(r, n);
        s.tag = 2,
        e != null && (s.callback = e),
        e = $r(t, s, n),
        e !== null && (Ft(e, t, n, r),
        jo(e, t, n))
    }
};
function ih(t, e, r, n, s, i, o) {
    return t = t.stateNode,
    typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(n, i, o) : e.prototype && e.prototype.isPureReactComponent ? !wi(r, n) || !wi(s, i) : !0
}
function fg(t, e, r) {
    var n = !1
      , s = Gr
      , i = e.contextType;
    return typeof i == "object" && i !== null ? i = jt(i) : (s = ht(e) ? Sn : Qe.current,
    n = e.contextTypes,
    i = (n = n != null) ? _s(t, s) : Gr),
    e = new e(r,i),
    t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null,
    e.updater = Ta,
    t.stateNode = e,
    e._reactInternals = t,
    n && (t = t.stateNode,
    t.__reactInternalMemoizedUnmaskedChildContext = s,
    t.__reactInternalMemoizedMaskedChildContext = i),
    e
}
function oh(t, e, r, n) {
    t = e.state,
    typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(r, n),
    typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(r, n),
    e.state !== t && Ta.enqueueReplaceState(e, e.state, null)
}
function au(t, e, r, n) {
    var s = t.stateNode;
    s.props = r,
    s.state = t.memoizedState,
    s.refs = {},
    Pc(t);
    var i = e.contextType;
    typeof i == "object" && i !== null ? s.context = jt(i) : (i = ht(e) ? Sn : Qe.current,
    s.context = _s(t, i)),
    s.state = t.memoizedState,
    i = e.getDerivedStateFromProps,
    typeof i == "function" && (ou(t, e, i, r),
    s.state = t.memoizedState),
    typeof e.getDerivedStateFromProps == "function" || typeof s.getSnapshotBeforeUpdate == "function" || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (e = s.state,
    typeof s.componentWillMount == "function" && s.componentWillMount(),
    typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount(),
    e !== s.state && Ta.enqueueReplaceState(s, s.state, null),
    Zo(t, r, s, n),
    s.state = t.memoizedState),
    typeof s.componentDidMount == "function" && (t.flags |= 4194308)
}
function Cs(t, e) {
    try {
        var r = ""
          , n = e;
        do
            r += vv(n),
            n = n.return;
        while (n);
        var s = r
    } catch (i) {
        s = `
Error generating stack: ` + i.message + `
` + i.stack
    }
    return {
        value: t,
        source: e,
        stack: s,
        digest: null
    }
}
function yl(t, e, r) {
    return {
        value: t,
        source: null,
        stack: r ?? null,
        digest: e ?? null
    }
}
function lu(t, e) {
    try {
        console.error(e.value)
    } catch (r) {
        setTimeout(function() {
            throw r
        })
    }
}
var V0 = typeof WeakMap == "function" ? WeakMap : Map;
function pg(t, e, r) {
    r = or(-1, r),
    r.tag = 3,
    r.payload = {
        element: null
    };
    var n = e.value;
    return r.callback = function() {
        sa || (sa = !0,
        vu = n),
        lu(t, e)
    }
    ,
    r
}
function gg(t, e, r) {
    r = or(-1, r),
    r.tag = 3;
    var n = t.type.getDerivedStateFromError;
    if (typeof n == "function") {
        var s = e.value;
        r.payload = function() {
            return n(s)
        }
        ,
        r.callback = function() {
            lu(t, e)
        }
    }
    var i = t.stateNode;
    return i !== null && typeof i.componentDidCatch == "function" && (r.callback = function() {
        lu(t, e),
        typeof n != "function" && (Ur === null ? Ur = new Set([this]) : Ur.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: o !== null ? o : ""
        })
    }
    ),
    r
}
function ah(t, e, r) {
    var n = t.pingCache;
    if (n === null) {
        n = t.pingCache = new V0;
        var s = new Set;
        n.set(e, s)
    } else
        s = n.get(e),
        s === void 0 && (s = new Set,
        n.set(e, s));
    s.has(r) || (s.add(r),
    t = iw.bind(null, t, e, r),
    e.then(t, t))
}
function lh(t) {
    do {
        var e;
        if ((e = t.tag === 13) && (e = t.memoizedState,
        e = e !== null ? e.dehydrated !== null : !0),
        e)
            return t;
        t = t.return
    } while (t !== null);
    return null
}
function uh(t, e, r, n, s) {
    return t.mode & 1 ? (t.flags |= 65536,
    t.lanes = s,
    t) : (t === e ? t.flags |= 65536 : (t.flags |= 128,
    r.flags |= 131072,
    r.flags &= -52805,
    r.tag === 1 && (r.alternate === null ? r.tag = 17 : (e = or(-1, 1),
    e.tag = 2,
    $r(r, e, 1))),
    r.lanes |= 1),
    t)
}
var H0 = dr.ReactCurrentOwner
  , ct = !1;
function Ye(t, e, r, n) {
    e.child = t === null ? Gp(e, null, r, n) : ks(e, t.child, r, n)
}
function ch(t, e, r, n, s) {
    r = r.render;
    var i = e.ref;
    return ss(e, s),
    n = Nc(t, e, r, n, i, s),
    r = Lc(),
    t !== null && !ct ? (e.updateQueue = t.updateQueue,
    e.flags &= -2053,
    t.lanes &= ~s,
    cr(t, e, s)) : (ye && r && _c(e),
    e.flags |= 1,
    Ye(t, e, n, s),
    e.child)
}
function dh(t, e, r, n, s) {
    if (t === null) {
        var i = r.type;
        return typeof i == "function" && !Vc(i) && i.defaultProps === void 0 && r.compare === null && r.defaultProps === void 0 ? (e.tag = 15,
        e.type = i,
        mg(t, e, i, n, s)) : (t = Io(r.type, null, n, e, e.mode, s),
        t.ref = e.ref,
        t.return = e,
        e.child = t)
    }
    if (i = t.child,
    !(t.lanes & s)) {
        var o = i.memoizedProps;
        if (r = r.compare,
        r = r !== null ? r : wi,
        r(o, n) && t.ref === e.ref)
            return cr(t, e, s)
    }
    return e.flags |= 1,
    t = Br(i, n),
    t.ref = e.ref,
    t.return = e,
    e.child = t
}
function mg(t, e, r, n, s) {
    if (t !== null) {
        var i = t.memoizedProps;
        if (wi(i, n) && t.ref === e.ref)
            if (ct = !1,
            e.pendingProps = n = i,
            (t.lanes & s) !== 0)
                t.flags & 131072 && (ct = !0);
            else
                return e.lanes = t.lanes,
                cr(t, e, s)
    }
    return uu(t, e, r, n, s)
}
function yg(t, e, r) {
    var n = e.pendingProps
      , s = n.children
      , i = t !== null ? t.memoizedState : null;
    if (n.mode === "hidden")
        if (!(e.mode & 1))
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            de(Zn, pt),
            pt |= r;
        else {
            if (!(r & 1073741824))
                return t = i !== null ? i.baseLanes | r : r,
                e.lanes = e.childLanes = 1073741824,
                e.memoizedState = {
                    baseLanes: t,
                    cachePool: null,
                    transitions: null
                },
                e.updateQueue = null,
                de(Zn, pt),
                pt |= t,
                null;
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            n = i !== null ? i.baseLanes : r,
            de(Zn, pt),
            pt |= n
        }
    else
        i !== null ? (n = i.baseLanes | r,
        e.memoizedState = null) : n = r,
        de(Zn, pt),
        pt |= n;
    return Ye(t, e, s, r),
    e.child
}
function vg(t, e) {
    var r = e.ref;
    (t === null && r !== null || t !== null && t.ref !== r) && (e.flags |= 512,
    e.flags |= 2097152)
}
function uu(t, e, r, n, s) {
    var i = ht(r) ? Sn : Qe.current;
    return i = _s(e, i),
    ss(e, s),
    r = Nc(t, e, r, n, i, s),
    n = Lc(),
    t !== null && !ct ? (e.updateQueue = t.updateQueue,
    e.flags &= -2053,
    t.lanes &= ~s,
    cr(t, e, s)) : (ye && n && _c(e),
    e.flags |= 1,
    Ye(t, e, r, s),
    e.child)
}
function hh(t, e, r, n, s) {
    if (ht(r)) {
        var i = !0;
        Ko(e)
    } else
        i = !1;
    if (ss(e, s),
    e.stateNode === null)
        Oo(t, e),
        fg(e, r, n),
        au(e, r, n, s),
        n = !0;
    else if (t === null) {
        var o = e.stateNode
          , a = e.memoizedProps;
        o.props = a;
        var l = o.context
          , c = r.contextType;
        typeof c == "object" && c !== null ? c = jt(c) : (c = ht(r) ? Sn : Qe.current,
        c = _s(e, c));
        var d = r.getDerivedStateFromProps
          , h = typeof d == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        h || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== n || l !== c) && oh(e, o, n, c),
        vr = !1;
        var f = e.memoizedState;
        o.state = f,
        Zo(e, n, o, s),
        l = e.memoizedState,
        a !== n || f !== l || dt.current || vr ? (typeof d == "function" && (ou(e, r, d, n),
        l = e.memoizedState),
        (a = vr || ih(e, r, a, n, f, l, c)) ? (h || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(),
        typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()),
        typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        e.memoizedProps = n,
        e.memoizedState = l),
        o.props = n,
        o.state = l,
        o.context = c,
        n = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        n = !1)
    } else {
        o = e.stateNode,
        Hp(t, e),
        a = e.memoizedProps,
        c = e.type === e.elementType ? a : Rt(e.type, a),
        o.props = c,
        h = e.pendingProps,
        f = o.context,
        l = r.contextType,
        typeof l == "object" && l !== null ? l = jt(l) : (l = ht(r) ? Sn : Qe.current,
        l = _s(e, l));
        var p = r.getDerivedStateFromProps;
        (d = typeof p == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== h || f !== l) && oh(e, o, n, l),
        vr = !1,
        f = e.memoizedState,
        o.state = f,
        Zo(e, n, o, s);
        var v = e.memoizedState;
        a !== h || f !== v || dt.current || vr ? (typeof p == "function" && (ou(e, r, p, n),
        v = e.memoizedState),
        (c = vr || ih(e, r, c, n, f, v, l) || !1) ? (d || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(n, v, l),
        typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(n, v, l)),
        typeof o.componentDidUpdate == "function" && (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && f === t.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && f === t.memoizedState || (e.flags |= 1024),
        e.memoizedProps = n,
        e.memoizedState = v),
        o.props = n,
        o.state = v,
        o.context = l,
        n = c) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && f === t.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && f === t.memoizedState || (e.flags |= 1024),
        n = !1)
    }
    return cu(t, e, r, n, i, s)
}
function cu(t, e, r, n, s, i) {
    vg(t, e);
    var o = (e.flags & 128) !== 0;
    if (!n && !o)
        return s && Xd(e, r, !1),
        cr(t, e, i);
    n = e.stateNode,
    H0.current = e;
    var a = o && typeof r.getDerivedStateFromError != "function" ? null : n.render();
    return e.flags |= 1,
    t !== null && o ? (e.child = ks(e, t.child, null, i),
    e.child = ks(e, null, a, i)) : Ye(t, e, a, i),
    e.memoizedState = n.state,
    s && Xd(e, r, !0),
    e.child
}
function wg(t) {
    var e = t.stateNode;
    e.pendingContext ? Jd(t, e.pendingContext, e.pendingContext !== e.context) : e.context && Jd(t, e.context, !1),
    Oc(t, e.containerInfo)
}
function fh(t, e, r, n, s) {
    return Ss(),
    kc(s),
    e.flags |= 256,
    Ye(t, e, r, n),
    e.child
}
var du = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function hu(t) {
    return {
        baseLanes: t,
        cachePool: null,
        transitions: null
    }
}
function bg(t, e, r) {
    var n = e.pendingProps, s = be.current, i = !1, o = (e.flags & 128) !== 0, a;
    if ((a = o) || (a = t !== null && t.memoizedState === null ? !1 : (s & 2) !== 0),
    a ? (i = !0,
    e.flags &= -129) : (t === null || t.memoizedState !== null) && (s |= 1),
    de(be, s & 1),
    t === null)
        return su(e),
        t = e.memoizedState,
        t !== null && (t = t.dehydrated,
        t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1,
        null) : (o = n.children,
        t = n.fallback,
        i ? (n = e.mode,
        i = e.child,
        o = {
            mode: "hidden",
            children: o
        },
        !(n & 1) && i !== null ? (i.childLanes = 0,
        i.pendingProps = o) : i = Ra(o, n, 0, null),
        t = _n(t, n, r, null),
        i.return = e,
        t.return = e,
        i.sibling = t,
        e.child = i,
        e.child.memoizedState = hu(r),
        e.memoizedState = du,
        t) : Uc(e, o));
    if (s = t.memoizedState,
    s !== null && (a = s.dehydrated,
    a !== null))
        return q0(t, e, o, n, a, s, r);
    if (i) {
        i = n.fallback,
        o = e.mode,
        s = t.child,
        a = s.sibling;
        var l = {
            mode: "hidden",
            children: n.children
        };
        return !(o & 1) && e.child !== s ? (n = e.child,
        n.childLanes = 0,
        n.pendingProps = l,
        e.deletions = null) : (n = Br(s, l),
        n.subtreeFlags = s.subtreeFlags & 14680064),
        a !== null ? i = Br(a, i) : (i = _n(i, o, r, null),
        i.flags |= 2),
        i.return = e,
        n.return = e,
        n.sibling = i,
        e.child = n,
        n = i,
        i = e.child,
        o = t.child.memoizedState,
        o = o === null ? hu(r) : {
            baseLanes: o.baseLanes | r,
            cachePool: null,
            transitions: o.transitions
        },
        i.memoizedState = o,
        i.childLanes = t.childLanes & ~r,
        e.memoizedState = du,
        n
    }
    return i = t.child,
    t = i.sibling,
    n = Br(i, {
        mode: "visible",
        children: n.children
    }),
    !(e.mode & 1) && (n.lanes = r),
    n.return = e,
    n.sibling = null,
    t !== null && (r = e.deletions,
    r === null ? (e.deletions = [t],
    e.flags |= 16) : r.push(t)),
    e.child = n,
    e.memoizedState = null,
    n
}
function Uc(t, e) {
    return e = Ra({
        mode: "visible",
        children: e
    }, t.mode, 0, null),
    e.return = t,
    t.child = e
}
function ao(t, e, r, n) {
    return n !== null && kc(n),
    ks(e, t.child, null, r),
    t = Uc(e, e.pendingProps.children),
    t.flags |= 2,
    e.memoizedState = null,
    t
}
function q0(t, e, r, n, s, i, o) {
    if (r)
        return e.flags & 256 ? (e.flags &= -257,
        n = yl(Error(A(422))),
        ao(t, e, o, n)) : e.memoizedState !== null ? (e.child = t.child,
        e.flags |= 128,
        null) : (i = n.fallback,
        s = e.mode,
        n = Ra({
            mode: "visible",
            children: n.children
        }, s, 0, null),
        i = _n(i, s, o, null),
        i.flags |= 2,
        n.return = e,
        i.return = e,
        n.sibling = i,
        e.child = n,
        e.mode & 1 && ks(e, t.child, null, o),
        e.child.memoizedState = hu(o),
        e.memoizedState = du,
        i);
    if (!(e.mode & 1))
        return ao(t, e, o, null);
    if (s.data === "$!") {
        if (n = s.nextSibling && s.nextSibling.dataset,
        n)
            var a = n.dgst;
        return n = a,
        i = Error(A(419)),
        n = yl(i, n, void 0),
        ao(t, e, o, n)
    }
    if (a = (o & t.childLanes) !== 0,
    ct || a) {
        if (n = Ne,
        n !== null) {
            switch (o & -o) {
            case 4:
                s = 2;
                break;
            case 16:
                s = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                s = 32;
                break;
            case 536870912:
                s = 268435456;
                break;
            default:
                s = 0
            }
            s = s & (n.suspendedLanes | o) ? 0 : s,
            s !== 0 && s !== i.retryLane && (i.retryLane = s,
            ur(t, s),
            Ft(n, t, s, -1))
        }
        return Gc(),
        n = yl(Error(A(421))),
        ao(t, e, o, n)
    }
    return s.data === "$?" ? (e.flags |= 128,
    e.child = t.child,
    e = ow.bind(null, t),
    s._reactRetry = e,
    null) : (t = i.treeContext,
    mt = Dr(s.nextSibling),
    yt = e,
    ye = !0,
    $t = null,
    t !== null && (St[kt++] = sr,
    St[kt++] = ir,
    St[kt++] = kn,
    sr = t.id,
    ir = t.overflow,
    kn = e),
    e = Uc(e, n.children),
    e.flags |= 4096,
    e)
}
function ph(t, e, r) {
    t.lanes |= e;
    var n = t.alternate;
    n !== null && (n.lanes |= e),
    iu(t.return, e, r)
}
function vl(t, e, r, n, s) {
    var i = t.memoizedState;
    i === null ? t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: n,
        tail: r,
        tailMode: s
    } : (i.isBackwards = e,
    i.rendering = null,
    i.renderingStartTime = 0,
    i.last = n,
    i.tail = r,
    i.tailMode = s)
}
function xg(t, e, r) {
    var n = e.pendingProps
      , s = n.revealOrder
      , i = n.tail;
    if (Ye(t, e, n.children, r),
    n = be.current,
    n & 2)
        n = n & 1 | 2,
        e.flags |= 128;
    else {
        if (t !== null && t.flags & 128)
            e: for (t = e.child; t !== null; ) {
                if (t.tag === 13)
                    t.memoizedState !== null && ph(t, r, e);
                else if (t.tag === 19)
                    ph(t, r, e);
                else if (t.child !== null) {
                    t.child.return = t,
                    t = t.child;
                    continue
                }
                if (t === e)
                    break e;
                for (; t.sibling === null; ) {
                    if (t.return === null || t.return === e)
                        break e;
                    t = t.return
                }
                t.sibling.return = t.return,
                t = t.sibling
            }
        n &= 1
    }
    if (de(be, n),
    !(e.mode & 1))
        e.memoizedState = null;
    else
        switch (s) {
        case "forwards":
            for (r = e.child,
            s = null; r !== null; )
                t = r.alternate,
                t !== null && ea(t) === null && (s = r),
                r = r.sibling;
            r = s,
            r === null ? (s = e.child,
            e.child = null) : (s = r.sibling,
            r.sibling = null),
            vl(e, !1, s, r, i);
            break;
        case "backwards":
            for (r = null,
            s = e.child,
            e.child = null; s !== null; ) {
                if (t = s.alternate,
                t !== null && ea(t) === null) {
                    e.child = s;
                    break
                }
                t = s.sibling,
                s.sibling = r,
                r = s,
                s = t
            }
            vl(e, !0, r, null, i);
            break;
        case "together":
            vl(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
        }
    return e.child
}
function Oo(t, e) {
    !(e.mode & 1) && t !== null && (t.alternate = null,
    e.alternate = null,
    e.flags |= 2)
}
function cr(t, e, r) {
    if (t !== null && (e.dependencies = t.dependencies),
    Cn |= e.lanes,
    !(r & e.childLanes))
        return null;
    if (t !== null && e.child !== t.child)
        throw Error(A(153));
    if (e.child !== null) {
        for (t = e.child,
        r = Br(t, t.pendingProps),
        e.child = r,
        r.return = e; t.sibling !== null; )
            t = t.sibling,
            r = r.sibling = Br(t, t.pendingProps),
            r.return = e;
        r.sibling = null
    }
    return e.child
}
function K0(t, e, r) {
    switch (e.tag) {
    case 3:
        wg(e),
        Ss();
        break;
    case 5:
        qp(e);
        break;
    case 1:
        ht(e.type) && Ko(e);
        break;
    case 4:
        Oc(e, e.stateNode.containerInfo);
        break;
    case 10:
        var n = e.type._context
          , s = e.memoizedProps.value;
        de(Xo, n._currentValue),
        n._currentValue = s;
        break;
    case 13:
        if (n = e.memoizedState,
        n !== null)
            return n.dehydrated !== null ? (de(be, be.current & 1),
            e.flags |= 128,
            null) : r & e.child.childLanes ? bg(t, e, r) : (de(be, be.current & 1),
            t = cr(t, e, r),
            t !== null ? t.sibling : null);
        de(be, be.current & 1);
        break;
    case 19:
        if (n = (r & e.childLanes) !== 0,
        t.flags & 128) {
            if (n)
                return xg(t, e, r);
            e.flags |= 128
        }
        if (s = e.memoizedState,
        s !== null && (s.rendering = null,
        s.tail = null,
        s.lastEffect = null),
        de(be, be.current),
        n)
            break;
        return null;
    case 22:
    case 23:
        return e.lanes = 0,
        yg(t, e, r)
    }
    return cr(t, e, r)
}
var _g, fu, Sg, kg;
_g = function(t, e) {
    for (var r = e.child; r !== null; ) {
        if (r.tag === 5 || r.tag === 6)
            t.appendChild(r.stateNode);
        else if (r.tag !== 4 && r.child !== null) {
            r.child.return = r,
            r = r.child;
            continue
        }
        if (r === e)
            break;
        for (; r.sibling === null; ) {
            if (r.return === null || r.return === e)
                return;
            r = r.return
        }
        r.sibling.return = r.return,
        r = r.sibling
    }
}
;
fu = function() {}
;
Sg = function(t, e, r, n) {
    var s = t.memoizedProps;
    if (s !== n) {
        t = e.stateNode,
        un(Xt.current);
        var i = null;
        switch (r) {
        case "input":
            s = Ll(t, s),
            n = Ll(t, n),
            i = [];
            break;
        case "select":
            s = _e({}, s, {
                value: void 0
            }),
            n = _e({}, n, {
                value: void 0
            }),
            i = [];
            break;
        case "textarea":
            s = Ul(t, s),
            n = Ul(t, n),
            i = [];
            break;
        default:
            typeof s.onClick != "function" && typeof n.onClick == "function" && (t.onclick = Ho)
        }
        Bl(r, n);
        var o;
        r = null;
        for (c in s)
            if (!n.hasOwnProperty(c) && s.hasOwnProperty(c) && s[c] != null)
                if (c === "style") {
                    var a = s[c];
                    for (o in a)
                        a.hasOwnProperty(o) && (r || (r = {}),
                        r[o] = "")
                } else
                    c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (hi.hasOwnProperty(c) ? i || (i = []) : (i = i || []).push(c, null));
        for (c in n) {
            var l = n[c];
            if (a = s != null ? s[c] : void 0,
            n.hasOwnProperty(c) && l !== a && (l != null || a != null))
                if (c === "style")
                    if (a) {
                        for (o in a)
                            !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (r || (r = {}),
                            r[o] = "");
                        for (o in l)
                            l.hasOwnProperty(o) && a[o] !== l[o] && (r || (r = {}),
                            r[o] = l[o])
                    } else
                        r || (i || (i = []),
                        i.push(c, r)),
                        r = l;
                else
                    c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                    a = a ? a.__html : void 0,
                    l != null && a !== l && (i = i || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (i = i || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (hi.hasOwnProperty(c) ? (l != null && c === "onScroll" && pe("scroll", t),
                    i || a === l || (i = [])) : (i = i || []).push(c, l))
        }
        r && (i = i || []).push("style", r);
        var c = i;
        (e.updateQueue = c) && (e.flags |= 4)
    }
}
;
kg = function(t, e, r, n) {
    r !== n && (e.flags |= 4)
}
;
function Gs(t, e) {
    if (!ye)
        switch (t.tailMode) {
        case "hidden":
            e = t.tail;
            for (var r = null; e !== null; )
                e.alternate !== null && (r = e),
                e = e.sibling;
            r === null ? t.tail = null : r.sibling = null;
            break;
        case "collapsed":
            r = t.tail;
            for (var n = null; r !== null; )
                r.alternate !== null && (n = r),
                r = r.sibling;
            n === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : n.sibling = null
        }
}
function He(t) {
    var e = t.alternate !== null && t.alternate.child === t.child
      , r = 0
      , n = 0;
    if (e)
        for (var s = t.child; s !== null; )
            r |= s.lanes | s.childLanes,
            n |= s.subtreeFlags & 14680064,
            n |= s.flags & 14680064,
            s.return = t,
            s = s.sibling;
    else
        for (s = t.child; s !== null; )
            r |= s.lanes | s.childLanes,
            n |= s.subtreeFlags,
            n |= s.flags,
            s.return = t,
            s = s.sibling;
    return t.subtreeFlags |= n,
    t.childLanes = r,
    e
}
function Q0(t, e, r) {
    var n = e.pendingProps;
    switch (Sc(e),
    e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return He(e),
        null;
    case 1:
        return ht(e.type) && qo(),
        He(e),
        null;
    case 3:
        return n = e.stateNode,
        Es(),
        ge(dt),
        ge(Qe),
        Ac(),
        n.pendingContext && (n.context = n.pendingContext,
        n.pendingContext = null),
        (t === null || t.child === null) && (io(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024,
        $t !== null && (xu($t),
        $t = null))),
        fu(t, e),
        He(e),
        null;
    case 5:
        Rc(e);
        var s = un(ki.current);
        if (r = e.type,
        t !== null && e.stateNode != null)
            Sg(t, e, r, n, s),
            t.ref !== e.ref && (e.flags |= 512,
            e.flags |= 2097152);
        else {
            if (!n) {
                if (e.stateNode === null)
                    throw Error(A(166));
                return He(e),
                null
            }
            if (t = un(Xt.current),
            io(e)) {
                n = e.stateNode,
                r = e.type;
                var i = e.memoizedProps;
                switch (n[Qt] = e,
                n[_i] = i,
                t = (e.mode & 1) !== 0,
                r) {
                case "dialog":
                    pe("cancel", n),
                    pe("close", n);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    pe("load", n);
                    break;
                case "video":
                case "audio":
                    for (s = 0; s < Xs.length; s++)
                        pe(Xs[s], n);
                    break;
                case "source":
                    pe("error", n);
                    break;
                case "img":
                case "image":
                case "link":
                    pe("error", n),
                    pe("load", n);
                    break;
                case "details":
                    pe("toggle", n);
                    break;
                case "input":
                    Sd(n, i),
                    pe("invalid", n);
                    break;
                case "select":
                    n._wrapperState = {
                        wasMultiple: !!i.multiple
                    },
                    pe("invalid", n);
                    break;
                case "textarea":
                    Ed(n, i),
                    pe("invalid", n)
                }
                Bl(r, i),
                s = null;
                for (var o in i)
                    if (i.hasOwnProperty(o)) {
                        var a = i[o];
                        o === "children" ? typeof a == "string" ? n.textContent !== a && (i.suppressHydrationWarning !== !0 && so(n.textContent, a, t),
                        s = ["children", a]) : typeof a == "number" && n.textContent !== "" + a && (i.suppressHydrationWarning !== !0 && so(n.textContent, a, t),
                        s = ["children", "" + a]) : hi.hasOwnProperty(o) && a != null && o === "onScroll" && pe("scroll", n)
                    }
                switch (r) {
                case "input":
                    Ji(n),
                    kd(n, i, !0);
                    break;
                case "textarea":
                    Ji(n),
                    Cd(n);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof i.onClick == "function" && (n.onclick = Ho)
                }
                n = s,
                e.updateQueue = n,
                n !== null && (e.flags |= 4)
            } else {
                o = s.nodeType === 9 ? s : s.ownerDocument,
                t === "http://www.w3.org/1999/xhtml" && (t = Yf(r)),
                t === "http://www.w3.org/1999/xhtml" ? r === "script" ? (t = o.createElement("div"),
                t.innerHTML = "<script><\/script>",
                t = t.removeChild(t.firstChild)) : typeof n.is == "string" ? t = o.createElement(r, {
                    is: n.is
                }) : (t = o.createElement(r),
                r === "select" && (o = t,
                n.multiple ? o.multiple = !0 : n.size && (o.size = n.size))) : t = o.createElementNS(t, r),
                t[Qt] = e,
                t[_i] = n,
                _g(t, e, !1, !1),
                e.stateNode = t;
                e: {
                    switch (o = zl(r, n),
                    r) {
                    case "dialog":
                        pe("cancel", t),
                        pe("close", t),
                        s = n;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        pe("load", t),
                        s = n;
                        break;
                    case "video":
                    case "audio":
                        for (s = 0; s < Xs.length; s++)
                            pe(Xs[s], t);
                        s = n;
                        break;
                    case "source":
                        pe("error", t),
                        s = n;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        pe("error", t),
                        pe("load", t),
                        s = n;
                        break;
                    case "details":
                        pe("toggle", t),
                        s = n;
                        break;
                    case "input":
                        Sd(t, n),
                        s = Ll(t, n),
                        pe("invalid", t);
                        break;
                    case "option":
                        s = n;
                        break;
                    case "select":
                        t._wrapperState = {
                            wasMultiple: !!n.multiple
                        },
                        s = _e({}, n, {
                            value: void 0
                        }),
                        pe("invalid", t);
                        break;
                    case "textarea":
                        Ed(t, n),
                        s = Ul(t, n),
                        pe("invalid", t);
                        break;
                    default:
                        s = n
                    }
                    Bl(r, s),
                    a = s;
                    for (i in a)
                        if (a.hasOwnProperty(i)) {
                            var l = a[i];
                            i === "style" ? tp(t, l) : i === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                            l != null && Zf(t, l)) : i === "children" ? typeof l == "string" ? (r !== "textarea" || l !== "") && fi(t, l) : typeof l == "number" && fi(t, "" + l) : i !== "suppressContentEditableWarning" && i !== "suppressHydrationWarning" && i !== "autoFocus" && (hi.hasOwnProperty(i) ? l != null && i === "onScroll" && pe("scroll", t) : l != null && lc(t, i, l, o))
                        }
                    switch (r) {
                    case "input":
                        Ji(t),
                        kd(t, n, !1);
                        break;
                    case "textarea":
                        Ji(t),
                        Cd(t);
                        break;
                    case "option":
                        n.value != null && t.setAttribute("value", "" + Wr(n.value));
                        break;
                    case "select":
                        t.multiple = !!n.multiple,
                        i = n.value,
                        i != null ? es(t, !!n.multiple, i, !1) : n.defaultValue != null && es(t, !!n.multiple, n.defaultValue, !0);
                        break;
                    default:
                        typeof s.onClick == "function" && (t.onclick = Ho)
                    }
                    switch (r) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        n = !!n.autoFocus;
                        break e;
                    case "img":
                        n = !0;
                        break e;
                    default:
                        n = !1
                    }
                }
                n && (e.flags |= 4)
            }
            e.ref !== null && (e.flags |= 512,
            e.flags |= 2097152)
        }
        return He(e),
        null;
    case 6:
        if (t && e.stateNode != null)
            kg(t, e, t.memoizedProps, n);
        else {
            if (typeof n != "string" && e.stateNode === null)
                throw Error(A(166));
            if (r = un(ki.current),
            un(Xt.current),
            io(e)) {
                if (n = e.stateNode,
                r = e.memoizedProps,
                n[Qt] = e,
                (i = n.nodeValue !== r) && (t = yt,
                t !== null))
                    switch (t.tag) {
                    case 3:
                        so(n.nodeValue, r, (t.mode & 1) !== 0);
                        break;
                    case 5:
                        t.memoizedProps.suppressHydrationWarning !== !0 && so(n.nodeValue, r, (t.mode & 1) !== 0)
                    }
                i && (e.flags |= 4)
            } else
                n = (r.nodeType === 9 ? r : r.ownerDocument).createTextNode(n),
                n[Qt] = e,
                e.stateNode = n
        }
        return He(e),
        null;
    case 13:
        if (ge(be),
        n = e.memoizedState,
        t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
            if (ye && mt !== null && e.mode & 1 && !(e.flags & 128))
                Mp(),
                Ss(),
                e.flags |= 98560,
                i = !1;
            else if (i = io(e),
            n !== null && n.dehydrated !== null) {
                if (t === null) {
                    if (!i)
                        throw Error(A(318));
                    if (i = e.memoizedState,
                    i = i !== null ? i.dehydrated : null,
                    !i)
                        throw Error(A(317));
                    i[Qt] = e
                } else
                    Ss(),
                    !(e.flags & 128) && (e.memoizedState = null),
                    e.flags |= 4;
                He(e),
                i = !1
            } else
                $t !== null && (xu($t),
                $t = null),
                i = !0;
            if (!i)
                return e.flags & 65536 ? e : null
        }
        return e.flags & 128 ? (e.lanes = r,
        e) : (n = n !== null,
        n !== (t !== null && t.memoizedState !== null) && n && (e.child.flags |= 8192,
        e.mode & 1 && (t === null || be.current & 1 ? Oe === 0 && (Oe = 3) : Gc())),
        e.updateQueue !== null && (e.flags |= 4),
        He(e),
        null);
    case 4:
        return Es(),
        fu(t, e),
        t === null && bi(e.stateNode.containerInfo),
        He(e),
        null;
    case 10:
        return jc(e.type._context),
        He(e),
        null;
    case 17:
        return ht(e.type) && qo(),
        He(e),
        null;
    case 19:
        if (ge(be),
        i = e.memoizedState,
        i === null)
            return He(e),
            null;
        if (n = (e.flags & 128) !== 0,
        o = i.rendering,
        o === null)
            if (n)
                Gs(i, !1);
            else {
                if (Oe !== 0 || t !== null && t.flags & 128)
                    for (t = e.child; t !== null; ) {
                        if (o = ea(t),
                        o !== null) {
                            for (e.flags |= 128,
                            Gs(i, !1),
                            n = o.updateQueue,
                            n !== null && (e.updateQueue = n,
                            e.flags |= 4),
                            e.subtreeFlags = 0,
                            n = r,
                            r = e.child; r !== null; )
                                i = r,
                                t = n,
                                i.flags &= 14680066,
                                o = i.alternate,
                                o === null ? (i.childLanes = 0,
                                i.lanes = t,
                                i.child = null,
                                i.subtreeFlags = 0,
                                i.memoizedProps = null,
                                i.memoizedState = null,
                                i.updateQueue = null,
                                i.dependencies = null,
                                i.stateNode = null) : (i.childLanes = o.childLanes,
                                i.lanes = o.lanes,
                                i.child = o.child,
                                i.subtreeFlags = 0,
                                i.deletions = null,
                                i.memoizedProps = o.memoizedProps,
                                i.memoizedState = o.memoizedState,
                                i.updateQueue = o.updateQueue,
                                i.type = o.type,
                                t = o.dependencies,
                                i.dependencies = t === null ? null : {
                                    lanes: t.lanes,
                                    firstContext: t.firstContext
                                }),
                                r = r.sibling;
                            return de(be, be.current & 1 | 2),
                            e.child
                        }
                        t = t.sibling
                    }
                i.tail !== null && Ee() > js && (e.flags |= 128,
                n = !0,
                Gs(i, !1),
                e.lanes = 4194304)
            }
        else {
            if (!n)
                if (t = ea(o),
                t !== null) {
                    if (e.flags |= 128,
                    n = !0,
                    r = t.updateQueue,
                    r !== null && (e.updateQueue = r,
                    e.flags |= 4),
                    Gs(i, !0),
                    i.tail === null && i.tailMode === "hidden" && !o.alternate && !ye)
                        return He(e),
                        null
                } else
                    2 * Ee() - i.renderingStartTime > js && r !== 1073741824 && (e.flags |= 128,
                    n = !0,
                    Gs(i, !1),
                    e.lanes = 4194304);
            i.isBackwards ? (o.sibling = e.child,
            e.child = o) : (r = i.last,
            r !== null ? r.sibling = o : e.child = o,
            i.last = o)
        }
        return i.tail !== null ? (e = i.tail,
        i.rendering = e,
        i.tail = e.sibling,
        i.renderingStartTime = Ee(),
        e.sibling = null,
        r = be.current,
        de(be, n ? r & 1 | 2 : r & 1),
        e) : (He(e),
        null);
    case 22:
    case 23:
        return Wc(),
        n = e.memoizedState !== null,
        t !== null && t.memoizedState !== null !== n && (e.flags |= 8192),
        n && e.mode & 1 ? pt & 1073741824 && (He(e),
        e.subtreeFlags & 6 && (e.flags |= 8192)) : He(e),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(A(156, e.tag))
}
function J0(t, e) {
    switch (Sc(e),
    e.tag) {
    case 1:
        return ht(e.type) && qo(),
        t = e.flags,
        t & 65536 ? (e.flags = t & -65537 | 128,
        e) : null;
    case 3:
        return Es(),
        ge(dt),
        ge(Qe),
        Ac(),
        t = e.flags,
        t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128,
        e) : null;
    case 5:
        return Rc(e),
        null;
    case 13:
        if (ge(be),
        t = e.memoizedState,
        t !== null && t.dehydrated !== null) {
            if (e.alternate === null)
                throw Error(A(340));
            Ss()
        }
        return t = e.flags,
        t & 65536 ? (e.flags = t & -65537 | 128,
        e) : null;
    case 19:
        return ge(be),
        null;
    case 4:
        return Es(),
        null;
    case 10:
        return jc(e.type._context),
        null;
    case 22:
    case 23:
        return Wc(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var lo = !1
  , qe = !1
  , X0 = typeof WeakSet == "function" ? WeakSet : Set
  , U = null;
function Yn(t, e) {
    var r = t.ref;
    if (r !== null)
        if (typeof r == "function")
            try {
                r(null)
            } catch (n) {
                ke(t, e, n)
            }
        else
            r.current = null
}
function pu(t, e, r) {
    try {
        r()
    } catch (n) {
        ke(t, e, n)
    }
}
var gh = !1;
function Y0(t, e) {
    if (Xl = Wo,
    t = Pp(),
    xc(t)) {
        if ("selectionStart"in t)
            var r = {
                start: t.selectionStart,
                end: t.selectionEnd
            };
        else
            e: {
                r = (r = t.ownerDocument) && r.defaultView || window;
                var n = r.getSelection && r.getSelection();
                if (n && n.rangeCount !== 0) {
                    r = n.anchorNode;
                    var s = n.anchorOffset
                      , i = n.focusNode;
                    n = n.focusOffset;
                    try {
                        r.nodeType,
                        i.nodeType
                    } catch {
                        r = null;
                        break e
                    }
                    var o = 0
                      , a = -1
                      , l = -1
                      , c = 0
                      , d = 0
                      , h = t
                      , f = null;
                    t: for (; ; ) {
                        for (var p; h !== r || s !== 0 && h.nodeType !== 3 || (a = o + s),
                        h !== i || n !== 0 && h.nodeType !== 3 || (l = o + n),
                        h.nodeType === 3 && (o += h.nodeValue.length),
                        (p = h.firstChild) !== null; )
                            f = h,
                            h = p;
                        for (; ; ) {
                            if (h === t)
                                break t;
                            if (f === r && ++c === s && (a = o),
                            f === i && ++d === n && (l = o),
                            (p = h.nextSibling) !== null)
                                break;
                            h = f,
                            f = h.parentNode
                        }
                        h = p
                    }
                    r = a === -1 || l === -1 ? null : {
                        start: a,
                        end: l
                    }
                } else
                    r = null
            }
        r = r || {
            start: 0,
            end: 0
        }
    } else
        r = null;
    for (Yl = {
        focusedElem: t,
        selectionRange: r
    },
    Wo = !1,
    U = e; U !== null; )
        if (e = U,
        t = e.child,
        (e.subtreeFlags & 1028) !== 0 && t !== null)
            t.return = e,
            U = t;
        else
            for (; U !== null; ) {
                e = U;
                try {
                    var v = e.alternate;
                    if (e.flags & 1024)
                        switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (v !== null) {
                                var w = v.memoizedProps
                                  , b = v.memoizedState
                                  , g = e.stateNode
                                  , m = g.getSnapshotBeforeUpdate(e.elementType === e.type ? w : Rt(e.type, w), b);
                                g.__reactInternalSnapshotBeforeUpdate = m
                            }
                            break;
                        case 3:
                            var y = e.stateNode.containerInfo;
                            y.nodeType === 1 ? y.textContent = "" : y.nodeType === 9 && y.documentElement && y.removeChild(y.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(A(163))
                        }
                } catch (x) {
                    ke(e, e.return, x)
                }
                if (t = e.sibling,
                t !== null) {
                    t.return = e.return,
                    U = t;
                    break
                }
                U = e.return
            }
    return v = gh,
    gh = !1,
    v
}
function ui(t, e, r) {
    var n = e.updateQueue;
    if (n = n !== null ? n.lastEffect : null,
    n !== null) {
        var s = n = n.next;
        do {
            if ((s.tag & t) === t) {
                var i = s.destroy;
                s.destroy = void 0,
                i !== void 0 && pu(e, r, i)
            }
            s = s.next
        } while (s !== n)
    }
}
function Pa(t, e) {
    if (e = e.updateQueue,
    e = e !== null ? e.lastEffect : null,
    e !== null) {
        var r = e = e.next;
        do {
            if ((r.tag & t) === t) {
                var n = r.create;
                r.destroy = n()
            }
            r = r.next
        } while (r !== e)
    }
}
function gu(t) {
    var e = t.ref;
    if (e !== null) {
        var r = t.stateNode;
        switch (t.tag) {
        case 5:
            t = r;
            break;
        default:
            t = r
        }
        typeof e == "function" ? e(t) : e.current = t
    }
}
function Eg(t) {
    var e = t.alternate;
    e !== null && (t.alternate = null,
    Eg(e)),
    t.child = null,
    t.deletions = null,
    t.sibling = null,
    t.tag === 5 && (e = t.stateNode,
    e !== null && (delete e[Qt],
    delete e[_i],
    delete e[tu],
    delete e[N0],
    delete e[L0])),
    t.stateNode = null,
    t.return = null,
    t.dependencies = null,
    t.memoizedProps = null,
    t.memoizedState = null,
    t.pendingProps = null,
    t.stateNode = null,
    t.updateQueue = null
}
function Cg(t) {
    return t.tag === 5 || t.tag === 3 || t.tag === 4
}
function mh(t) {
    e: for (; ; ) {
        for (; t.sibling === null; ) {
            if (t.return === null || Cg(t.return))
                return null;
            t = t.return
        }
        for (t.sibling.return = t.return,
        t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
            if (t.flags & 2 || t.child === null || t.tag === 4)
                continue e;
            t.child.return = t,
            t = t.child
        }
        if (!(t.flags & 2))
            return t.stateNode
    }
}
function mu(t, e, r) {
    var n = t.tag;
    if (n === 5 || n === 6)
        t = t.stateNode,
        e ? r.nodeType === 8 ? r.parentNode.insertBefore(t, e) : r.insertBefore(t, e) : (r.nodeType === 8 ? (e = r.parentNode,
        e.insertBefore(t, r)) : (e = r,
        e.appendChild(t)),
        r = r._reactRootContainer,
        r != null || e.onclick !== null || (e.onclick = Ho));
    else if (n !== 4 && (t = t.child,
    t !== null))
        for (mu(t, e, r),
        t = t.sibling; t !== null; )
            mu(t, e, r),
            t = t.sibling
}
function yu(t, e, r) {
    var n = t.tag;
    if (n === 5 || n === 6)
        t = t.stateNode,
        e ? r.insertBefore(t, e) : r.appendChild(t);
    else if (n !== 4 && (t = t.child,
    t !== null))
        for (yu(t, e, r),
        t = t.sibling; t !== null; )
            yu(t, e, r),
            t = t.sibling
}
var Ue = null
  , Lt = !1;
function fr(t, e, r) {
    for (r = r.child; r !== null; )
        jg(t, e, r),
        r = r.sibling
}
function jg(t, e, r) {
    if (Jt && typeof Jt.onCommitFiberUnmount == "function")
        try {
            Jt.onCommitFiberUnmount(xa, r)
        } catch {}
    switch (r.tag) {
    case 5:
        qe || Yn(r, e);
    case 6:
        var n = Ue
          , s = Lt;
        Ue = null,
        fr(t, e, r),
        Ue = n,
        Lt = s,
        Ue !== null && (Lt ? (t = Ue,
        r = r.stateNode,
        t.nodeType === 8 ? t.parentNode.removeChild(r) : t.removeChild(r)) : Ue.removeChild(r.stateNode));
        break;
    case 18:
        Ue !== null && (Lt ? (t = Ue,
        r = r.stateNode,
        t.nodeType === 8 ? dl(t.parentNode, r) : t.nodeType === 1 && dl(t, r),
        yi(t)) : dl(Ue, r.stateNode));
        break;
    case 4:
        n = Ue,
        s = Lt,
        Ue = r.stateNode.containerInfo,
        Lt = !0,
        fr(t, e, r),
        Ue = n,
        Lt = s;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!qe && (n = r.updateQueue,
        n !== null && (n = n.lastEffect,
        n !== null))) {
            s = n = n.next;
            do {
                var i = s
                  , o = i.destroy;
                i = i.tag,
                o !== void 0 && (i & 2 || i & 4) && pu(r, e, o),
                s = s.next
            } while (s !== n)
        }
        fr(t, e, r);
        break;
    case 1:
        if (!qe && (Yn(r, e),
        n = r.stateNode,
        typeof n.componentWillUnmount == "function"))
            try {
                n.props = r.memoizedProps,
                n.state = r.memoizedState,
                n.componentWillUnmount()
            } catch (a) {
                ke(r, e, a)
            }
        fr(t, e, r);
        break;
    case 21:
        fr(t, e, r);
        break;
    case 22:
        r.mode & 1 ? (qe = (n = qe) || r.memoizedState !== null,
        fr(t, e, r),
        qe = n) : fr(t, e, r);
        break;
    default:
        fr(t, e, r)
    }
}
function yh(t) {
    var e = t.updateQueue;
    if (e !== null) {
        t.updateQueue = null;
        var r = t.stateNode;
        r === null && (r = t.stateNode = new X0),
        e.forEach(function(n) {
            var s = aw.bind(null, t, n);
            r.has(n) || (r.add(n),
            n.then(s, s))
        })
    }
}
function Pt(t, e) {
    var r = e.deletions;
    if (r !== null)
        for (var n = 0; n < r.length; n++) {
            var s = r[n];
            try {
                var i = t
                  , o = e
                  , a = o;
                e: for (; a !== null; ) {
                    switch (a.tag) {
                    case 5:
                        Ue = a.stateNode,
                        Lt = !1;
                        break e;
                    case 3:
                        Ue = a.stateNode.containerInfo,
                        Lt = !0;
                        break e;
                    case 4:
                        Ue = a.stateNode.containerInfo,
                        Lt = !0;
                        break e
                    }
                    a = a.return
                }
                if (Ue === null)
                    throw Error(A(160));
                jg(i, o, s),
                Ue = null,
                Lt = !1;
                var l = s.alternate;
                l !== null && (l.return = null),
                s.return = null
            } catch (c) {
                ke(s, e, c)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null; )
            Tg(e, t),
            e = e.sibling
}
function Tg(t, e) {
    var r = t.alternate
      , n = t.flags;
    switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (Pt(e, t),
        Wt(t),
        n & 4) {
            try {
                ui(3, t, t.return),
                Pa(3, t)
            } catch (w) {
                ke(t, t.return, w)
            }
            try {
                ui(5, t, t.return)
            } catch (w) {
                ke(t, t.return, w)
            }
        }
        break;
    case 1:
        Pt(e, t),
        Wt(t),
        n & 512 && r !== null && Yn(r, r.return);
        break;
    case 5:
        if (Pt(e, t),
        Wt(t),
        n & 512 && r !== null && Yn(r, r.return),
        t.flags & 32) {
            var s = t.stateNode;
            try {
                fi(s, "")
            } catch (w) {
                ke(t, t.return, w)
            }
        }
        if (n & 4 && (s = t.stateNode,
        s != null)) {
            var i = t.memoizedProps
              , o = r !== null ? r.memoizedProps : i
              , a = t.type
              , l = t.updateQueue;
            if (t.updateQueue = null,
            l !== null)
                try {
                    a === "input" && i.type === "radio" && i.name != null && Jf(s, i),
                    zl(a, o);
                    var c = zl(a, i);
                    for (o = 0; o < l.length; o += 2) {
                        var d = l[o]
                          , h = l[o + 1];
                        d === "style" ? tp(s, h) : d === "dangerouslySetInnerHTML" ? Zf(s, h) : d === "children" ? fi(s, h) : lc(s, d, h, c)
                    }
                    switch (a) {
                    case "input":
                        Dl(s, i);
                        break;
                    case "textarea":
                        Xf(s, i);
                        break;
                    case "select":
                        var f = s._wrapperState.wasMultiple;
                        s._wrapperState.wasMultiple = !!i.multiple;
                        var p = i.value;
                        p != null ? es(s, !!i.multiple, p, !1) : f !== !!i.multiple && (i.defaultValue != null ? es(s, !!i.multiple, i.defaultValue, !0) : es(s, !!i.multiple, i.multiple ? [] : "", !1))
                    }
                    s[_i] = i
                } catch (w) {
                    ke(t, t.return, w)
                }
        }
        break;
    case 6:
        if (Pt(e, t),
        Wt(t),
        n & 4) {
            if (t.stateNode === null)
                throw Error(A(162));
            s = t.stateNode,
            i = t.memoizedProps;
            try {
                s.nodeValue = i
            } catch (w) {
                ke(t, t.return, w)
            }
        }
        break;
    case 3:
        if (Pt(e, t),
        Wt(t),
        n & 4 && r !== null && r.memoizedState.isDehydrated)
            try {
                yi(e.containerInfo)
            } catch (w) {
                ke(t, t.return, w)
            }
        break;
    case 4:
        Pt(e, t),
        Wt(t);
        break;
    case 13:
        Pt(e, t),
        Wt(t),
        s = t.child,
        s.flags & 8192 && (i = s.memoizedState !== null,
        s.stateNode.isHidden = i,
        !i || s.alternate !== null && s.alternate.memoizedState !== null || (zc = Ee())),
        n & 4 && yh(t);
        break;
    case 22:
        if (d = r !== null && r.memoizedState !== null,
        t.mode & 1 ? (qe = (c = qe) || d,
        Pt(e, t),
        qe = c) : Pt(e, t),
        Wt(t),
        n & 8192) {
            if (c = t.memoizedState !== null,
            (t.stateNode.isHidden = c) && !d && t.mode & 1)
                for (U = t,
                d = t.child; d !== null; ) {
                    for (h = U = d; U !== null; ) {
                        switch (f = U,
                        p = f.child,
                        f.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            ui(4, f, f.return);
                            break;
                        case 1:
                            Yn(f, f.return);
                            var v = f.stateNode;
                            if (typeof v.componentWillUnmount == "function") {
                                n = f,
                                r = f.return;
                                try {
                                    e = n,
                                    v.props = e.memoizedProps,
                                    v.state = e.memoizedState,
                                    v.componentWillUnmount()
                                } catch (w) {
                                    ke(n, r, w)
                                }
                            }
                            break;
                        case 5:
                            Yn(f, f.return);
                            break;
                        case 22:
                            if (f.memoizedState !== null) {
                                wh(h);
                                continue
                            }
                        }
                        p !== null ? (p.return = f,
                        U = p) : wh(h)
                    }
                    d = d.sibling
                }
            e: for (d = null,
            h = t; ; ) {
                if (h.tag === 5) {
                    if (d === null) {
                        d = h;
                        try {
                            s = h.stateNode,
                            c ? (i = s.style,
                            typeof i.setProperty == "function" ? i.setProperty("display", "none", "important") : i.display = "none") : (a = h.stateNode,
                            l = h.memoizedProps.style,
                            o = l != null && l.hasOwnProperty("display") ? l.display : null,
                            a.style.display = ep("display", o))
                        } catch (w) {
                            ke(t, t.return, w)
                        }
                    }
                } else if (h.tag === 6) {
                    if (d === null)
                        try {
                            h.stateNode.nodeValue = c ? "" : h.memoizedProps
                        } catch (w) {
                            ke(t, t.return, w)
                        }
                } else if ((h.tag !== 22 && h.tag !== 23 || h.memoizedState === null || h === t) && h.child !== null) {
                    h.child.return = h,
                    h = h.child;
                    continue
                }
                if (h === t)
                    break e;
                for (; h.sibling === null; ) {
                    if (h.return === null || h.return === t)
                        break e;
                    d === h && (d = null),
                    h = h.return
                }
                d === h && (d = null),
                h.sibling.return = h.return,
                h = h.sibling
            }
        }
        break;
    case 19:
        Pt(e, t),
        Wt(t),
        n & 4 && yh(t);
        break;
    case 21:
        break;
    default:
        Pt(e, t),
        Wt(t)
    }
}
function Wt(t) {
    var e = t.flags;
    if (e & 2) {
        try {
            e: {
                for (var r = t.return; r !== null; ) {
                    if (Cg(r)) {
                        var n = r;
                        break e
                    }
                    r = r.return
                }
                throw Error(A(160))
            }
            switch (n.tag) {
            case 5:
                var s = n.stateNode;
                n.flags & 32 && (fi(s, ""),
                n.flags &= -33);
                var i = mh(t);
                yu(t, i, s);
                break;
            case 3:
            case 4:
                var o = n.stateNode.containerInfo
                  , a = mh(t);
                mu(t, a, o);
                break;
            default:
                throw Error(A(161))
            }
        } catch (l) {
            ke(t, t.return, l)
        }
        t.flags &= -3
    }
    e & 4096 && (t.flags &= -4097)
}
function Z0(t, e, r) {
    U = t,
    Pg(t)
}
function Pg(t, e, r) {
    for (var n = (t.mode & 1) !== 0; U !== null; ) {
        var s = U
          , i = s.child;
        if (s.tag === 22 && n) {
            var o = s.memoizedState !== null || lo;
            if (!o) {
                var a = s.alternate
                  , l = a !== null && a.memoizedState !== null || qe;
                a = lo;
                var c = qe;
                if (lo = o,
                (qe = l) && !c)
                    for (U = s; U !== null; )
                        o = U,
                        l = o.child,
                        o.tag === 22 && o.memoizedState !== null ? bh(s) : l !== null ? (l.return = o,
                        U = l) : bh(s);
                for (; i !== null; )
                    U = i,
                    Pg(i),
                    i = i.sibling;
                U = s,
                lo = a,
                qe = c
            }
            vh(t)
        } else
            s.subtreeFlags & 8772 && i !== null ? (i.return = s,
            U = i) : vh(t)
    }
}
function vh(t) {
    for (; U !== null; ) {
        var e = U;
        if (e.flags & 8772) {
            var r = e.alternate;
            try {
                if (e.flags & 8772)
                    switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        qe || Pa(5, e);
                        break;
                    case 1:
                        var n = e.stateNode;
                        if (e.flags & 4 && !qe)
                            if (r === null)
                                n.componentDidMount();
                            else {
                                var s = e.elementType === e.type ? r.memoizedProps : Rt(e.type, r.memoizedProps);
                                n.componentDidUpdate(s, r.memoizedState, n.__reactInternalSnapshotBeforeUpdate)
                            }
                        var i = e.updateQueue;
                        i !== null && rh(e, i, n);
                        break;
                    case 3:
                        var o = e.updateQueue;
                        if (o !== null) {
                            if (r = null,
                            e.child !== null)
                                switch (e.child.tag) {
                                case 5:
                                    r = e.child.stateNode;
                                    break;
                                case 1:
                                    r = e.child.stateNode
                                }
                            rh(e, o, r)
                        }
                        break;
                    case 5:
                        var a = e.stateNode;
                        if (r === null && e.flags & 4) {
                            r = a;
                            var l = e.memoizedProps;
                            switch (e.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                l.autoFocus && r.focus();
                                break;
                            case "img":
                                l.src && (r.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var c = e.alternate;
                            if (c !== null) {
                                var d = c.memoizedState;
                                if (d !== null) {
                                    var h = d.dehydrated;
                                    h !== null && yi(h)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(A(163))
                    }
                qe || e.flags & 512 && gu(e)
            } catch (f) {
                ke(e, e.return, f)
            }
        }
        if (e === t) {
            U = null;
            break
        }
        if (r = e.sibling,
        r !== null) {
            r.return = e.return,
            U = r;
            break
        }
        U = e.return
    }
}
function wh(t) {
    for (; U !== null; ) {
        var e = U;
        if (e === t) {
            U = null;
            break
        }
        var r = e.sibling;
        if (r !== null) {
            r.return = e.return,
            U = r;
            break
        }
        U = e.return
    }
}
function bh(t) {
    for (; U !== null; ) {
        var e = U;
        try {
            switch (e.tag) {
            case 0:
            case 11:
            case 15:
                var r = e.return;
                try {
                    Pa(4, e)
                } catch (l) {
                    ke(e, r, l)
                }
                break;
            case 1:
                var n = e.stateNode;
                if (typeof n.componentDidMount == "function") {
                    var s = e.return;
                    try {
                        n.componentDidMount()
                    } catch (l) {
                        ke(e, s, l)
                    }
                }
                var i = e.return;
                try {
                    gu(e)
                } catch (l) {
                    ke(e, i, l)
                }
                break;
            case 5:
                var o = e.return;
                try {
                    gu(e)
                } catch (l) {
                    ke(e, o, l)
                }
            }
        } catch (l) {
            ke(e, e.return, l)
        }
        if (e === t) {
            U = null;
            break
        }
        var a = e.sibling;
        if (a !== null) {
            a.return = e.return,
            U = a;
            break
        }
        U = e.return
    }
}
var ew = Math.ceil
  , na = dr.ReactCurrentDispatcher
  , Fc = dr.ReactCurrentOwner
  , Ct = dr.ReactCurrentBatchConfig
  , re = 0
  , Ne = null
  , Te = null
  , Be = 0
  , pt = 0
  , Zn = Hr(0)
  , Oe = 0
  , Ti = null
  , Cn = 0
  , Oa = 0
  , Bc = 0
  , ci = null
  , lt = null
  , zc = 0
  , js = 1 / 0
  , er = null
  , sa = !1
  , vu = null
  , Ur = null
  , uo = !1
  , Ar = null
  , ia = 0
  , di = 0
  , wu = null
  , Ro = -1
  , Ao = 0;
function tt() {
    return re & 6 ? Ee() : Ro !== -1 ? Ro : Ro = Ee()
}
function Fr(t) {
    return t.mode & 1 ? re & 2 && Be !== 0 ? Be & -Be : $0.transition !== null ? (Ao === 0 && (Ao = fp()),
    Ao) : (t = le,
    t !== 0 || (t = window.event,
    t = t === void 0 ? 16 : bp(t.type)),
    t) : 1
}
function Ft(t, e, r, n) {
    if (50 < di)
        throw di = 0,
        wu = null,
        Error(A(185));
    Bi(t, r, n),
    (!(re & 2) || t !== Ne) && (t === Ne && (!(re & 2) && (Oa |= r),
    Oe === 4 && br(t, Be)),
    ft(t, n),
    r === 1 && re === 0 && !(e.mode & 1) && (js = Ee() + 500,
    Ca && qr()))
}
function ft(t, e) {
    var r = t.callbackNode;
    $v(t, e);
    var n = Mo(t, t === Ne ? Be : 0);
    if (n === 0)
        r !== null && Pd(r),
        t.callbackNode = null,
        t.callbackPriority = 0;
    else if (e = n & -n,
    t.callbackPriority !== e) {
        if (r != null && Pd(r),
        e === 1)
            t.tag === 0 ? D0(xh.bind(null, t)) : Fp(xh.bind(null, t)),
            A0(function() {
                !(re & 6) && qr()
            }),
            r = null;
        else {
            switch (pp(n)) {
            case 1:
                r = fc;
                break;
            case 4:
                r = dp;
                break;
            case 16:
                r = zo;
                break;
            case 536870912:
                r = hp;
                break;
            default:
                r = zo
            }
            r = $g(r, Og.bind(null, t))
        }
        t.callbackPriority = e,
        t.callbackNode = r
    }
}
function Og(t, e) {
    if (Ro = -1,
    Ao = 0,
    re & 6)
        throw Error(A(327));
    var r = t.callbackNode;
    if (is() && t.callbackNode !== r)
        return null;
    var n = Mo(t, t === Ne ? Be : 0);
    if (n === 0)
        return null;
    if (n & 30 || n & t.expiredLanes || e)
        e = oa(t, n);
    else {
        e = n;
        var s = re;
        re |= 2;
        var i = Ag();
        (Ne !== t || Be !== e) && (er = null,
        js = Ee() + 500,
        xn(t, e));
        do
            try {
                nw();
                break
            } catch (a) {
                Rg(t, a)
            }
        while (!0);
        Cc(),
        na.current = i,
        re = s,
        Te !== null ? e = 0 : (Ne = null,
        Be = 0,
        e = Oe)
    }
    if (e !== 0) {
        if (e === 2 && (s = Hl(t),
        s !== 0 && (n = s,
        e = bu(t, s))),
        e === 1)
            throw r = Ti,
            xn(t, 0),
            br(t, n),
            ft(t, Ee()),
            r;
        if (e === 6)
            br(t, n);
        else {
            if (s = t.current.alternate,
            !(n & 30) && !tw(s) && (e = oa(t, n),
            e === 2 && (i = Hl(t),
            i !== 0 && (n = i,
            e = bu(t, i))),
            e === 1))
                throw r = Ti,
                xn(t, 0),
                br(t, n),
                ft(t, Ee()),
                r;
            switch (t.finishedWork = s,
            t.finishedLanes = n,
            e) {
            case 0:
            case 1:
                throw Error(A(345));
            case 2:
                en(t, lt, er);
                break;
            case 3:
                if (br(t, n),
                (n & 130023424) === n && (e = zc + 500 - Ee(),
                10 < e)) {
                    if (Mo(t, 0) !== 0)
                        break;
                    if (s = t.suspendedLanes,
                    (s & n) !== n) {
                        tt(),
                        t.pingedLanes |= t.suspendedLanes & s;
                        break
                    }
                    t.timeoutHandle = eu(en.bind(null, t, lt, er), e);
                    break
                }
                en(t, lt, er);
                break;
            case 4:
                if (br(t, n),
                (n & 4194240) === n)
                    break;
                for (e = t.eventTimes,
                s = -1; 0 < n; ) {
                    var o = 31 - Ut(n);
                    i = 1 << o,
                    o = e[o],
                    o > s && (s = o),
                    n &= ~i
                }
                if (n = s,
                n = Ee() - n,
                n = (120 > n ? 120 : 480 > n ? 480 : 1080 > n ? 1080 : 1920 > n ? 1920 : 3e3 > n ? 3e3 : 4320 > n ? 4320 : 1960 * ew(n / 1960)) - n,
                10 < n) {
                    t.timeoutHandle = eu(en.bind(null, t, lt, er), n);
                    break
                }
                en(t, lt, er);
                break;
            case 5:
                en(t, lt, er);
                break;
            default:
                throw Error(A(329))
            }
        }
    }
    return ft(t, Ee()),
    t.callbackNode === r ? Og.bind(null, t) : null
}
function bu(t, e) {
    var r = ci;
    return t.current.memoizedState.isDehydrated && (xn(t, e).flags |= 256),
    t = oa(t, e),
    t !== 2 && (e = lt,
    lt = r,
    e !== null && xu(e)),
    t
}
function xu(t) {
    lt === null ? lt = t : lt.push.apply(lt, t)
}
function tw(t) {
    for (var e = t; ; ) {
        if (e.flags & 16384) {
            var r = e.updateQueue;
            if (r !== null && (r = r.stores,
            r !== null))
                for (var n = 0; n < r.length; n++) {
                    var s = r[n]
                      , i = s.getSnapshot;
                    s = s.value;
                    try {
                        if (!Bt(i(), s))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (r = e.child,
        e.subtreeFlags & 16384 && r !== null)
            r.return = e,
            e = r;
        else {
            if (e === t)
                break;
            for (; e.sibling === null; ) {
                if (e.return === null || e.return === t)
                    return !0;
                e = e.return
            }
            e.sibling.return = e.return,
            e = e.sibling
        }
    }
    return !0
}
function br(t, e) {
    for (e &= ~Bc,
    e &= ~Oa,
    t.suspendedLanes |= e,
    t.pingedLanes &= ~e,
    t = t.expirationTimes; 0 < e; ) {
        var r = 31 - Ut(e)
          , n = 1 << r;
        t[r] = -1,
        e &= ~n
    }
}
function xh(t) {
    if (re & 6)
        throw Error(A(327));
    is();
    var e = Mo(t, 0);
    if (!(e & 1))
        return ft(t, Ee()),
        null;
    var r = oa(t, e);
    if (t.tag !== 0 && r === 2) {
        var n = Hl(t);
        n !== 0 && (e = n,
        r = bu(t, n))
    }
    if (r === 1)
        throw r = Ti,
        xn(t, 0),
        br(t, e),
        ft(t, Ee()),
        r;
    if (r === 6)
        throw Error(A(345));
    return t.finishedWork = t.current.alternate,
    t.finishedLanes = e,
    en(t, lt, er),
    ft(t, Ee()),
    null
}
function Mc(t, e) {
    var r = re;
    re |= 1;
    try {
        return t(e)
    } finally {
        re = r,
        re === 0 && (js = Ee() + 500,
        Ca && qr())
    }
}
function jn(t) {
    Ar !== null && Ar.tag === 0 && !(re & 6) && is();
    var e = re;
    re |= 1;
    var r = Ct.transition
      , n = le;
    try {
        if (Ct.transition = null,
        le = 1,
        t)
            return t()
    } finally {
        le = n,
        Ct.transition = r,
        re = e,
        !(re & 6) && qr()
    }
}
function Wc() {
    pt = Zn.current,
    ge(Zn)
}
function xn(t, e) {
    t.finishedWork = null,
    t.finishedLanes = 0;
    var r = t.timeoutHandle;
    if (r !== -1 && (t.timeoutHandle = -1,
    R0(r)),
    Te !== null)
        for (r = Te.return; r !== null; ) {
            var n = r;
            switch (Sc(n),
            n.tag) {
            case 1:
                n = n.type.childContextTypes,
                n != null && qo();
                break;
            case 3:
                Es(),
                ge(dt),
                ge(Qe),
                Ac();
                break;
            case 5:
                Rc(n);
                break;
            case 4:
                Es();
                break;
            case 13:
                ge(be);
                break;
            case 19:
                ge(be);
                break;
            case 10:
                jc(n.type._context);
                break;
            case 22:
            case 23:
                Wc()
            }
            r = r.return
        }
    if (Ne = t,
    Te = t = Br(t.current, null),
    Be = pt = e,
    Oe = 0,
    Ti = null,
    Bc = Oa = Cn = 0,
    lt = ci = null,
    ln !== null) {
        for (e = 0; e < ln.length; e++)
            if (r = ln[e],
            n = r.interleaved,
            n !== null) {
                r.interleaved = null;
                var s = n.next
                  , i = r.pending;
                if (i !== null) {
                    var o = i.next;
                    i.next = s,
                    n.next = o
                }
                r.pending = n
            }
        ln = null
    }
    return t
}
function Rg(t, e) {
    do {
        var r = Te;
        try {
            if (Cc(),
            To.current = ra,
            ta) {
                for (var n = xe.memoizedState; n !== null; ) {
                    var s = n.queue;
                    s !== null && (s.pending = null),
                    n = n.next
                }
                ta = !1
            }
            if (En = 0,
            Ae = Pe = xe = null,
            li = !1,
            Ei = 0,
            Fc.current = null,
            r === null || r.return === null) {
                Oe = 1,
                Ti = e,
                Te = null;
                break
            }
            e: {
                var i = t
                  , o = r.return
                  , a = r
                  , l = e;
                if (e = Be,
                a.flags |= 32768,
                l !== null && typeof l == "object" && typeof l.then == "function") {
                    var c = l
                      , d = a
                      , h = d.tag;
                    if (!(d.mode & 1) && (h === 0 || h === 11 || h === 15)) {
                        var f = d.alternate;
                        f ? (d.updateQueue = f.updateQueue,
                        d.memoizedState = f.memoizedState,
                        d.lanes = f.lanes) : (d.updateQueue = null,
                        d.memoizedState = null)
                    }
                    var p = lh(o);
                    if (p !== null) {
                        p.flags &= -257,
                        uh(p, o, a, i, e),
                        p.mode & 1 && ah(i, c, e),
                        e = p,
                        l = c;
                        var v = e.updateQueue;
                        if (v === null) {
                            var w = new Set;
                            w.add(l),
                            e.updateQueue = w
                        } else
                            v.add(l);
                        break e
                    } else {
                        if (!(e & 1)) {
                            ah(i, c, e),
                            Gc();
                            break e
                        }
                        l = Error(A(426))
                    }
                } else if (ye && a.mode & 1) {
                    var b = lh(o);
                    if (b !== null) {
                        !(b.flags & 65536) && (b.flags |= 256),
                        uh(b, o, a, i, e),
                        kc(Cs(l, a));
                        break e
                    }
                }
                i = l = Cs(l, a),
                Oe !== 4 && (Oe = 2),
                ci === null ? ci = [i] : ci.push(i),
                i = o;
                do {
                    switch (i.tag) {
                    case 3:
                        i.flags |= 65536,
                        e &= -e,
                        i.lanes |= e;
                        var g = pg(i, l, e);
                        th(i, g);
                        break e;
                    case 1:
                        a = l;
                        var m = i.type
                          , y = i.stateNode;
                        if (!(i.flags & 128) && (typeof m.getDerivedStateFromError == "function" || y !== null && typeof y.componentDidCatch == "function" && (Ur === null || !Ur.has(y)))) {
                            i.flags |= 65536,
                            e &= -e,
                            i.lanes |= e;
                            var x = gg(i, a, e);
                            th(i, x);
                            break e
                        }
                    }
                    i = i.return
                } while (i !== null)
            }
            Ng(r)
        } catch (k) {
            e = k,
            Te === r && r !== null && (Te = r = r.return);
            continue
        }
        break
    } while (!0)
}
function Ag() {
    var t = na.current;
    return na.current = ra,
    t === null ? ra : t
}
function Gc() {
    (Oe === 0 || Oe === 3 || Oe === 2) && (Oe = 4),
    Ne === null || !(Cn & 268435455) && !(Oa & 268435455) || br(Ne, Be)
}
function oa(t, e) {
    var r = re;
    re |= 2;
    var n = Ag();
    (Ne !== t || Be !== e) && (er = null,
    xn(t, e));
    do
        try {
            rw();
            break
        } catch (s) {
            Rg(t, s)
        }
    while (!0);
    if (Cc(),
    re = r,
    na.current = n,
    Te !== null)
        throw Error(A(261));
    return Ne = null,
    Be = 0,
    Oe
}
function rw() {
    for (; Te !== null; )
        Ig(Te)
}
function nw() {
    for (; Te !== null && !Tv(); )
        Ig(Te)
}
function Ig(t) {
    var e = Dg(t.alternate, t, pt);
    t.memoizedProps = t.pendingProps,
    e === null ? Ng(t) : Te = e,
    Fc.current = null
}
function Ng(t) {
    var e = t;
    do {
        var r = e.alternate;
        if (t = e.return,
        e.flags & 32768) {
            if (r = J0(r, e),
            r !== null) {
                r.flags &= 32767,
                Te = r;
                return
            }
            if (t !== null)
                t.flags |= 32768,
                t.subtreeFlags = 0,
                t.deletions = null;
            else {
                Oe = 6,
                Te = null;
                return
            }
        } else if (r = Q0(r, e, pt),
        r !== null) {
            Te = r;
            return
        }
        if (e = e.sibling,
        e !== null) {
            Te = e;
            return
        }
        Te = e = t
    } while (e !== null);
    Oe === 0 && (Oe = 5)
}
function en(t, e, r) {
    var n = le
      , s = Ct.transition;
    try {
        Ct.transition = null,
        le = 1,
        sw(t, e, r, n)
    } finally {
        Ct.transition = s,
        le = n
    }
    return null
}
function sw(t, e, r, n) {
    do
        is();
    while (Ar !== null);
    if (re & 6)
        throw Error(A(327));
    r = t.finishedWork;
    var s = t.finishedLanes;
    if (r === null)
        return null;
    if (t.finishedWork = null,
    t.finishedLanes = 0,
    r === t.current)
        throw Error(A(177));
    t.callbackNode = null,
    t.callbackPriority = 0;
    var i = r.lanes | r.childLanes;
    if (Uv(t, i),
    t === Ne && (Te = Ne = null,
    Be = 0),
    !(r.subtreeFlags & 2064) && !(r.flags & 2064) || uo || (uo = !0,
    $g(zo, function() {
        return is(),
        null
    })),
    i = (r.flags & 15990) !== 0,
    r.subtreeFlags & 15990 || i) {
        i = Ct.transition,
        Ct.transition = null;
        var o = le;
        le = 1;
        var a = re;
        re |= 4,
        Fc.current = null,
        Y0(t, r),
        Tg(r, t),
        k0(Yl),
        Wo = !!Xl,
        Yl = Xl = null,
        t.current = r,
        Z0(r),
        Pv(),
        re = a,
        le = o,
        Ct.transition = i
    } else
        t.current = r;
    if (uo && (uo = !1,
    Ar = t,
    ia = s),
    i = t.pendingLanes,
    i === 0 && (Ur = null),
    Av(r.stateNode),
    ft(t, Ee()),
    e !== null)
        for (n = t.onRecoverableError,
        r = 0; r < e.length; r++)
            s = e[r],
            n(s.value, {
                componentStack: s.stack,
                digest: s.digest
            });
    if (sa)
        throw sa = !1,
        t = vu,
        vu = null,
        t;
    return ia & 1 && t.tag !== 0 && is(),
    i = t.pendingLanes,
    i & 1 ? t === wu ? di++ : (di = 0,
    wu = t) : di = 0,
    qr(),
    null
}
function is() {
    if (Ar !== null) {
        var t = pp(ia)
          , e = Ct.transition
          , r = le;
        try {
            if (Ct.transition = null,
            le = 16 > t ? 16 : t,
            Ar === null)
                var n = !1;
            else {
                if (t = Ar,
                Ar = null,
                ia = 0,
                re & 6)
                    throw Error(A(331));
                var s = re;
                for (re |= 4,
                U = t.current; U !== null; ) {
                    var i = U
                      , o = i.child;
                    if (U.flags & 16) {
                        var a = i.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var c = a[l];
                                for (U = c; U !== null; ) {
                                    var d = U;
                                    switch (d.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        ui(8, d, i)
                                    }
                                    var h = d.child;
                                    if (h !== null)
                                        h.return = d,
                                        U = h;
                                    else
                                        for (; U !== null; ) {
                                            d = U;
                                            var f = d.sibling
                                              , p = d.return;
                                            if (Eg(d),
                                            d === c) {
                                                U = null;
                                                break
                                            }
                                            if (f !== null) {
                                                f.return = p,
                                                U = f;
                                                break
                                            }
                                            U = p
                                        }
                                }
                            }
                            var v = i.alternate;
                            if (v !== null) {
                                var w = v.child;
                                if (w !== null) {
                                    v.child = null;
                                    do {
                                        var b = w.sibling;
                                        w.sibling = null,
                                        w = b
                                    } while (w !== null)
                                }
                            }
                            U = i
                        }
                    }
                    if (i.subtreeFlags & 2064 && o !== null)
                        o.return = i,
                        U = o;
                    else
                        e: for (; U !== null; ) {
                            if (i = U,
                            i.flags & 2048)
                                switch (i.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    ui(9, i, i.return)
                                }
                            var g = i.sibling;
                            if (g !== null) {
                                g.return = i.return,
                                U = g;
                                break e
                            }
                            U = i.return
                        }
                }
                var m = t.current;
                for (U = m; U !== null; ) {
                    o = U;
                    var y = o.child;
                    if (o.subtreeFlags & 2064 && y !== null)
                        y.return = o,
                        U = y;
                    else
                        e: for (o = m; U !== null; ) {
                            if (a = U,
                            a.flags & 2048)
                                try {
                                    switch (a.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Pa(9, a)
                                    }
                                } catch (k) {
                                    ke(a, a.return, k)
                                }
                            if (a === o) {
                                U = null;
                                break e
                            }
                            var x = a.sibling;
                            if (x !== null) {
                                x.return = a.return,
                                U = x;
                                break e
                            }
                            U = a.return
                        }
                }
                if (re = s,
                qr(),
                Jt && typeof Jt.onPostCommitFiberRoot == "function")
                    try {
                        Jt.onPostCommitFiberRoot(xa, t)
                    } catch {}
                n = !0
            }
            return n
        } finally {
            le = r,
            Ct.transition = e
        }
    }
    return !1
}
function _h(t, e, r) {
    e = Cs(r, e),
    e = pg(t, e, 1),
    t = $r(t, e, 1),
    e = tt(),
    t !== null && (Bi(t, 1, e),
    ft(t, e))
}
function ke(t, e, r) {
    if (t.tag === 3)
        _h(t, t, r);
    else
        for (; e !== null; ) {
            if (e.tag === 3) {
                _h(e, t, r);
                break
            } else if (e.tag === 1) {
                var n = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof n.componentDidCatch == "function" && (Ur === null || !Ur.has(n))) {
                    t = Cs(r, t),
                    t = gg(e, t, 1),
                    e = $r(e, t, 1),
                    t = tt(),
                    e !== null && (Bi(e, 1, t),
                    ft(e, t));
                    break
                }
            }
            e = e.return
        }
}
function iw(t, e, r) {
    var n = t.pingCache;
    n !== null && n.delete(e),
    e = tt(),
    t.pingedLanes |= t.suspendedLanes & r,
    Ne === t && (Be & r) === r && (Oe === 4 || Oe === 3 && (Be & 130023424) === Be && 500 > Ee() - zc ? xn(t, 0) : Bc |= r),
    ft(t, e)
}
function Lg(t, e) {
    e === 0 && (t.mode & 1 ? (e = Zi,
    Zi <<= 1,
    !(Zi & 130023424) && (Zi = 4194304)) : e = 1);
    var r = tt();
    t = ur(t, e),
    t !== null && (Bi(t, e, r),
    ft(t, r))
}
function ow(t) {
    var e = t.memoizedState
      , r = 0;
    e !== null && (r = e.retryLane),
    Lg(t, r)
}
function aw(t, e) {
    var r = 0;
    switch (t.tag) {
    case 13:
        var n = t.stateNode
          , s = t.memoizedState;
        s !== null && (r = s.retryLane);
        break;
    case 19:
        n = t.stateNode;
        break;
    default:
        throw Error(A(314))
    }
    n !== null && n.delete(e),
    Lg(t, r)
}
var Dg;
Dg = function(t, e, r) {
    if (t !== null)
        if (t.memoizedProps !== e.pendingProps || dt.current)
            ct = !0;
        else {
            if (!(t.lanes & r) && !(e.flags & 128))
                return ct = !1,
                K0(t, e, r);
            ct = !!(t.flags & 131072)
        }
    else
        ct = !1,
        ye && e.flags & 1048576 && Bp(e, Jo, e.index);
    switch (e.lanes = 0,
    e.tag) {
    case 2:
        var n = e.type;
        Oo(t, e),
        t = e.pendingProps;
        var s = _s(e, Qe.current);
        ss(e, r),
        s = Nc(null, e, n, t, s, r);
        var i = Lc();
        return e.flags |= 1,
        typeof s == "object" && s !== null && typeof s.render == "function" && s.$$typeof === void 0 ? (e.tag = 1,
        e.memoizedState = null,
        e.updateQueue = null,
        ht(n) ? (i = !0,
        Ko(e)) : i = !1,
        e.memoizedState = s.state !== null && s.state !== void 0 ? s.state : null,
        Pc(e),
        s.updater = Ta,
        e.stateNode = s,
        s._reactInternals = e,
        au(e, n, t, r),
        e = cu(null, e, n, !0, i, r)) : (e.tag = 0,
        ye && i && _c(e),
        Ye(null, e, s, r),
        e = e.child),
        e;
    case 16:
        n = e.elementType;
        e: {
            switch (Oo(t, e),
            t = e.pendingProps,
            s = n._init,
            n = s(n._payload),
            e.type = n,
            s = e.tag = uw(n),
            t = Rt(n, t),
            s) {
            case 0:
                e = uu(null, e, n, t, r);
                break e;
            case 1:
                e = hh(null, e, n, t, r);
                break e;
            case 11:
                e = ch(null, e, n, t, r);
                break e;
            case 14:
                e = dh(null, e, n, Rt(n.type, t), r);
                break e
            }
            throw Error(A(306, n, ""))
        }
        return e;
    case 0:
        return n = e.type,
        s = e.pendingProps,
        s = e.elementType === n ? s : Rt(n, s),
        uu(t, e, n, s, r);
    case 1:
        return n = e.type,
        s = e.pendingProps,
        s = e.elementType === n ? s : Rt(n, s),
        hh(t, e, n, s, r);
    case 3:
        e: {
            if (wg(e),
            t === null)
                throw Error(A(387));
            n = e.pendingProps,
            i = e.memoizedState,
            s = i.element,
            Hp(t, e),
            Zo(e, n, null, r);
            var o = e.memoizedState;
            if (n = o.element,
            i.isDehydrated)
                if (i = {
                    element: n,
                    isDehydrated: !1,
                    cache: o.cache,
                    pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                    transitions: o.transitions
                },
                e.updateQueue.baseState = i,
                e.memoizedState = i,
                e.flags & 256) {
                    s = Cs(Error(A(423)), e),
                    e = fh(t, e, n, r, s);
                    break e
                } else if (n !== s) {
                    s = Cs(Error(A(424)), e),
                    e = fh(t, e, n, r, s);
                    break e
                } else
                    for (mt = Dr(e.stateNode.containerInfo.firstChild),
                    yt = e,
                    ye = !0,
                    $t = null,
                    r = Gp(e, null, n, r),
                    e.child = r; r; )
                        r.flags = r.flags & -3 | 4096,
                        r = r.sibling;
            else {
                if (Ss(),
                n === s) {
                    e = cr(t, e, r);
                    break e
                }
                Ye(t, e, n, r)
            }
            e = e.child
        }
        return e;
    case 5:
        return qp(e),
        t === null && su(e),
        n = e.type,
        s = e.pendingProps,
        i = t !== null ? t.memoizedProps : null,
        o = s.children,
        Zl(n, s) ? o = null : i !== null && Zl(n, i) && (e.flags |= 32),
        vg(t, e),
        Ye(t, e, o, r),
        e.child;
    case 6:
        return t === null && su(e),
        null;
    case 13:
        return bg(t, e, r);
    case 4:
        return Oc(e, e.stateNode.containerInfo),
        n = e.pendingProps,
        t === null ? e.child = ks(e, null, n, r) : Ye(t, e, n, r),
        e.child;
    case 11:
        return n = e.type,
        s = e.pendingProps,
        s = e.elementType === n ? s : Rt(n, s),
        ch(t, e, n, s, r);
    case 7:
        return Ye(t, e, e.pendingProps, r),
        e.child;
    case 8:
        return Ye(t, e, e.pendingProps.children, r),
        e.child;
    case 12:
        return Ye(t, e, e.pendingProps.children, r),
        e.child;
    case 10:
        e: {
            if (n = e.type._context,
            s = e.pendingProps,
            i = e.memoizedProps,
            o = s.value,
            de(Xo, n._currentValue),
            n._currentValue = o,
            i !== null)
                if (Bt(i.value, o)) {
                    if (i.children === s.children && !dt.current) {
                        e = cr(t, e, r);
                        break e
                    }
                } else
                    for (i = e.child,
                    i !== null && (i.return = e); i !== null; ) {
                        var a = i.dependencies;
                        if (a !== null) {
                            o = i.child;
                            for (var l = a.firstContext; l !== null; ) {
                                if (l.context === n) {
                                    if (i.tag === 1) {
                                        l = or(-1, r & -r),
                                        l.tag = 2;
                                        var c = i.updateQueue;
                                        if (c !== null) {
                                            c = c.shared;
                                            var d = c.pending;
                                            d === null ? l.next = l : (l.next = d.next,
                                            d.next = l),
                                            c.pending = l
                                        }
                                    }
                                    i.lanes |= r,
                                    l = i.alternate,
                                    l !== null && (l.lanes |= r),
                                    iu(i.return, r, e),
                                    a.lanes |= r;
                                    break
                                }
                                l = l.next
                            }
                        } else if (i.tag === 10)
                            o = i.type === e.type ? null : i.child;
                        else if (i.tag === 18) {
                            if (o = i.return,
                            o === null)
                                throw Error(A(341));
                            o.lanes |= r,
                            a = o.alternate,
                            a !== null && (a.lanes |= r),
                            iu(o, r, e),
                            o = i.sibling
                        } else
                            o = i.child;
                        if (o !== null)
                            o.return = i;
                        else
                            for (o = i; o !== null; ) {
                                if (o === e) {
                                    o = null;
                                    break
                                }
                                if (i = o.sibling,
                                i !== null) {
                                    i.return = o.return,
                                    o = i;
                                    break
                                }
                                o = o.return
                            }
                        i = o
                    }
            Ye(t, e, s.children, r),
            e = e.child
        }
        return e;
    case 9:
        return s = e.type,
        n = e.pendingProps.children,
        ss(e, r),
        s = jt(s),
        n = n(s),
        e.flags |= 1,
        Ye(t, e, n, r),
        e.child;
    case 14:
        return n = e.type,
        s = Rt(n, e.pendingProps),
        s = Rt(n.type, s),
        dh(t, e, n, s, r);
    case 15:
        return mg(t, e, e.type, e.pendingProps, r);
    case 17:
        return n = e.type,
        s = e.pendingProps,
        s = e.elementType === n ? s : Rt(n, s),
        Oo(t, e),
        e.tag = 1,
        ht(n) ? (t = !0,
        Ko(e)) : t = !1,
        ss(e, r),
        fg(e, n, s),
        au(e, n, s, r),
        cu(null, e, n, !0, t, r);
    case 19:
        return xg(t, e, r);
    case 22:
        return yg(t, e, r)
    }
    throw Error(A(156, e.tag))
}
;
function $g(t, e) {
    return cp(t, e)
}
function lw(t, e, r, n) {
    this.tag = t,
    this.key = r,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = e,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = n,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function Et(t, e, r, n) {
    return new lw(t,e,r,n)
}
function Vc(t) {
    return t = t.prototype,
    !(!t || !t.isReactComponent)
}
function uw(t) {
    if (typeof t == "function")
        return Vc(t) ? 1 : 0;
    if (t != null) {
        if (t = t.$$typeof,
        t === cc)
            return 11;
        if (t === dc)
            return 14
    }
    return 2
}
function Br(t, e) {
    var r = t.alternate;
    return r === null ? (r = Et(t.tag, e, t.key, t.mode),
    r.elementType = t.elementType,
    r.type = t.type,
    r.stateNode = t.stateNode,
    r.alternate = t,
    t.alternate = r) : (r.pendingProps = e,
    r.type = t.type,
    r.flags = 0,
    r.subtreeFlags = 0,
    r.deletions = null),
    r.flags = t.flags & 14680064,
    r.childLanes = t.childLanes,
    r.lanes = t.lanes,
    r.child = t.child,
    r.memoizedProps = t.memoizedProps,
    r.memoizedState = t.memoizedState,
    r.updateQueue = t.updateQueue,
    e = t.dependencies,
    r.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    },
    r.sibling = t.sibling,
    r.index = t.index,
    r.ref = t.ref,
    r
}
function Io(t, e, r, n, s, i) {
    var o = 2;
    if (n = t,
    typeof t == "function")
        Vc(t) && (o = 1);
    else if (typeof t == "string")
        o = 5;
    else
        e: switch (t) {
        case Wn:
            return _n(r.children, s, i, e);
        case uc:
            o = 8,
            s |= 8;
            break;
        case Rl:
            return t = Et(12, r, e, s | 2),
            t.elementType = Rl,
            t.lanes = i,
            t;
        case Al:
            return t = Et(13, r, e, s),
            t.elementType = Al,
            t.lanes = i,
            t;
        case Il:
            return t = Et(19, r, e, s),
            t.elementType = Il,
            t.lanes = i,
            t;
        case qf:
            return Ra(r, s, i, e);
        default:
            if (typeof t == "object" && t !== null)
                switch (t.$$typeof) {
                case Vf:
                    o = 10;
                    break e;
                case Hf:
                    o = 9;
                    break e;
                case cc:
                    o = 11;
                    break e;
                case dc:
                    o = 14;
                    break e;
                case yr:
                    o = 16,
                    n = null;
                    break e
                }
            throw Error(A(130, t == null ? t : typeof t, ""))
        }
    return e = Et(o, r, e, s),
    e.elementType = t,
    e.type = n,
    e.lanes = i,
    e
}
function _n(t, e, r, n) {
    return t = Et(7, t, n, e),
    t.lanes = r,
    t
}
function Ra(t, e, r, n) {
    return t = Et(22, t, n, e),
    t.elementType = qf,
    t.lanes = r,
    t.stateNode = {
        isHidden: !1
    },
    t
}
function wl(t, e, r) {
    return t = Et(6, t, null, e),
    t.lanes = r,
    t
}
function bl(t, e, r) {
    return e = Et(4, t.children !== null ? t.children : [], t.key, e),
    e.lanes = r,
    e.stateNode = {
        containerInfo: t.containerInfo,
        pendingChildren: null,
        implementation: t.implementation
    },
    e
}
function cw(t, e, r, n, s) {
    this.tag = e,
    this.containerInfo = t,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = el(0),
    this.expirationTimes = el(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = el(0),
    this.identifierPrefix = n,
    this.onRecoverableError = s,
    this.mutableSourceEagerHydrationData = null
}
function Hc(t, e, r, n, s, i, o, a, l) {
    return t = new cw(t,e,r,a,l),
    e === 1 ? (e = 1,
    i === !0 && (e |= 8)) : e = 0,
    i = Et(3, null, null, e),
    t.current = i,
    i.stateNode = t,
    i.memoizedState = {
        element: n,
        isDehydrated: r,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    Pc(i),
    t
}
function dw(t, e, r) {
    var n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: Mn,
        key: n == null ? null : "" + n,
        children: t,
        containerInfo: e,
        implementation: r
    }
}
function Ug(t) {
    if (!t)
        return Gr;
    t = t._reactInternals;
    e: {
        if (On(t) !== t || t.tag !== 1)
            throw Error(A(170));
        var e = t;
        do {
            switch (e.tag) {
            case 3:
                e = e.stateNode.context;
                break e;
            case 1:
                if (ht(e.type)) {
                    e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            e = e.return
        } while (e !== null);
        throw Error(A(171))
    }
    if (t.tag === 1) {
        var r = t.type;
        if (ht(r))
            return Up(t, r, e)
    }
    return e
}
function Fg(t, e, r, n, s, i, o, a, l) {
    return t = Hc(r, n, !0, t, s, i, o, a, l),
    t.context = Ug(null),
    r = t.current,
    n = tt(),
    s = Fr(r),
    i = or(n, s),
    i.callback = e ?? null,
    $r(r, i, s),
    t.current.lanes = s,
    Bi(t, s, n),
    ft(t, n),
    t
}
function Aa(t, e, r, n) {
    var s = e.current
      , i = tt()
      , o = Fr(s);
    return r = Ug(r),
    e.context === null ? e.context = r : e.pendingContext = r,
    e = or(i, o),
    e.payload = {
        element: t
    },
    n = n === void 0 ? null : n,
    n !== null && (e.callback = n),
    t = $r(s, e, o),
    t !== null && (Ft(t, s, o, i),
    jo(t, s, o)),
    o
}
function aa(t) {
    if (t = t.current,
    !t.child)
        return null;
    switch (t.child.tag) {
    case 5:
        return t.child.stateNode;
    default:
        return t.child.stateNode
    }
}
function Sh(t, e) {
    if (t = t.memoizedState,
    t !== null && t.dehydrated !== null) {
        var r = t.retryLane;
        t.retryLane = r !== 0 && r < e ? r : e
    }
}
function qc(t, e) {
    Sh(t, e),
    (t = t.alternate) && Sh(t, e)
}
function hw() {
    return null
}
var Bg = typeof reportError == "function" ? reportError : function(t) {
    console.error(t)
}
;
function Kc(t) {
    this._internalRoot = t
}
Ia.prototype.render = Kc.prototype.render = function(t) {
    var e = this._internalRoot;
    if (e === null)
        throw Error(A(409));
    Aa(t, e, null, null)
}
;
Ia.prototype.unmount = Kc.prototype.unmount = function() {
    var t = this._internalRoot;
    if (t !== null) {
        this._internalRoot = null;
        var e = t.containerInfo;
        jn(function() {
            Aa(null, t, null, null)
        }),
        e[lr] = null
    }
}
;
function Ia(t) {
    this._internalRoot = t
}
Ia.prototype.unstable_scheduleHydration = function(t) {
    if (t) {
        var e = yp();
        t = {
            blockedOn: null,
            target: t,
            priority: e
        };
        for (var r = 0; r < wr.length && e !== 0 && e < wr[r].priority; r++)
            ;
        wr.splice(r, 0, t),
        r === 0 && wp(t)
    }
}
;
function Qc(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11)
}
function Na(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
}
function kh() {}
function fw(t, e, r, n, s) {
    if (s) {
        if (typeof n == "function") {
            var i = n;
            n = function() {
                var c = aa(o);
                i.call(c)
            }
        }
        var o = Fg(e, n, t, 0, null, !1, !1, "", kh);
        return t._reactRootContainer = o,
        t[lr] = o.current,
        bi(t.nodeType === 8 ? t.parentNode : t),
        jn(),
        o
    }
    for (; s = t.lastChild; )
        t.removeChild(s);
    if (typeof n == "function") {
        var a = n;
        n = function() {
            var c = aa(l);
            a.call(c)
        }
    }
    var l = Hc(t, 0, !1, null, null, !1, !1, "", kh);
    return t._reactRootContainer = l,
    t[lr] = l.current,
    bi(t.nodeType === 8 ? t.parentNode : t),
    jn(function() {
        Aa(e, l, r, n)
    }),
    l
}
function La(t, e, r, n, s) {
    var i = r._reactRootContainer;
    if (i) {
        var o = i;
        if (typeof s == "function") {
            var a = s;
            s = function() {
                var l = aa(o);
                a.call(l)
            }
        }
        Aa(e, o, t, s)
    } else
        o = fw(r, e, t, s, n);
    return aa(o)
}
gp = function(t) {
    switch (t.tag) {
    case 3:
        var e = t.stateNode;
        if (e.current.memoizedState.isDehydrated) {
            var r = Js(e.pendingLanes);
            r !== 0 && (pc(e, r | 1),
            ft(e, Ee()),
            !(re & 6) && (js = Ee() + 500,
            qr()))
        }
        break;
    case 13:
        jn(function() {
            var n = ur(t, 1);
            if (n !== null) {
                var s = tt();
                Ft(n, t, 1, s)
            }
        }),
        qc(t, 1)
    }
}
;
gc = function(t) {
    if (t.tag === 13) {
        var e = ur(t, 134217728);
        if (e !== null) {
            var r = tt();
            Ft(e, t, 134217728, r)
        }
        qc(t, 134217728)
    }
}
;
mp = function(t) {
    if (t.tag === 13) {
        var e = Fr(t)
          , r = ur(t, e);
        if (r !== null) {
            var n = tt();
            Ft(r, t, e, n)
        }
        qc(t, e)
    }
}
;
yp = function() {
    return le
}
;
vp = function(t, e) {
    var r = le;
    try {
        return le = t,
        e()
    } finally {
        le = r
    }
}
;
Wl = function(t, e, r) {
    switch (e) {
    case "input":
        if (Dl(t, r),
        e = r.name,
        r.type === "radio" && e != null) {
            for (r = t; r.parentNode; )
                r = r.parentNode;
            for (r = r.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'),
            e = 0; e < r.length; e++) {
                var n = r[e];
                if (n !== t && n.form === t.form) {
                    var s = Ea(n);
                    if (!s)
                        throw Error(A(90));
                    Qf(n),
                    Dl(n, s)
                }
            }
        }
        break;
    case "textarea":
        Xf(t, r);
        break;
    case "select":
        e = r.value,
        e != null && es(t, !!r.multiple, e, !1)
    }
}
;
sp = Mc;
ip = jn;
var pw = {
    usingClientEntryPoint: !1,
    Events: [Mi, qn, Ea, rp, np, Mc]
}
  , Vs = {
    findFiberByHostInstance: an,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom"
}
  , gw = {
    bundleType: Vs.bundleType,
    version: Vs.version,
    rendererPackageName: Vs.rendererPackageName,
    rendererConfig: Vs.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: dr.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(t) {
        return t = lp(t),
        t === null ? null : t.stateNode
    },
    findFiberByHostInstance: Vs.findFiberByHostInstance || hw,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var co = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!co.isDisabled && co.supportsFiber)
        try {
            xa = co.inject(gw),
            Jt = co
        } catch {}
}
wt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = pw;
wt.createPortal = function(t, e) {
    var r = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Qc(e))
        throw Error(A(200));
    return dw(t, e, null, r)
}
;
wt.createRoot = function(t, e) {
    if (!Qc(t))
        throw Error(A(299));
    var r = !1
      , n = ""
      , s = Bg;
    return e != null && (e.unstable_strictMode === !0 && (r = !0),
    e.identifierPrefix !== void 0 && (n = e.identifierPrefix),
    e.onRecoverableError !== void 0 && (s = e.onRecoverableError)),
    e = Hc(t, 1, !1, null, null, r, !1, n, s),
    t[lr] = e.current,
    bi(t.nodeType === 8 ? t.parentNode : t),
    new Kc(e)
}
;
wt.findDOMNode = function(t) {
    if (t == null)
        return null;
    if (t.nodeType === 1)
        return t;
    var e = t._reactInternals;
    if (e === void 0)
        throw typeof t.render == "function" ? Error(A(188)) : (t = Object.keys(t).join(","),
        Error(A(268, t)));
    return t = lp(e),
    t = t === null ? null : t.stateNode,
    t
}
;
wt.flushSync = function(t) {
    return jn(t)
}
;
wt.hydrate = function(t, e, r) {
    if (!Na(e))
        throw Error(A(200));
    return La(null, t, e, !0, r)
}
;
wt.hydrateRoot = function(t, e, r) {
    if (!Qc(t))
        throw Error(A(405));
    var n = r != null && r.hydratedSources || null
      , s = !1
      , i = ""
      , o = Bg;
    if (r != null && (r.unstable_strictMode === !0 && (s = !0),
    r.identifierPrefix !== void 0 && (i = r.identifierPrefix),
    r.onRecoverableError !== void 0 && (o = r.onRecoverableError)),
    e = Fg(e, null, t, 1, r ?? null, s, !1, i, o),
    t[lr] = e.current,
    bi(t),
    n)
        for (t = 0; t < n.length; t++)
            r = n[t],
            s = r._getVersion,
            s = s(r._source),
            e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [r, s] : e.mutableSourceEagerHydrationData.push(r, s);
    return new Ia(e)
}
;
wt.render = function(t, e, r) {
    if (!Na(e))
        throw Error(A(200));
    return La(null, t, e, !1, r)
}
;
wt.unmountComponentAtNode = function(t) {
    if (!Na(t))
        throw Error(A(40));
    return t._reactRootContainer ? (jn(function() {
        La(null, null, t, !1, function() {
            t._reactRootContainer = null,
            t[lr] = null
        })
    }),
    !0) : !1
}
;
wt.unstable_batchedUpdates = Mc;
wt.unstable_renderSubtreeIntoContainer = function(t, e, r, n) {
    if (!Na(r))
        throw Error(A(200));
    if (t == null || t._reactInternals === void 0)
        throw Error(A(38));
    return La(t, e, r, !1, n)
}
;
wt.version = "18.3.1-next-f1338f8080-20240426";
function zg() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(zg)
        } catch (t) {
            console.error(t)
        }
}
zg(),
zf.exports = wt;
var mw = zf.exports
  , Eh = mw;
Pl.createRoot = Eh.createRoot,
Pl.hydrateRoot = Eh.hydrateRoot;
function yw(t, e) {
    if (t instanceof RegExp)
        return {
            keys: !1,
            pattern: t
        };
    var r, n, s, i, o = [], a = "", l = t.split("/");
    for (l[0] || l.shift(); s = l.shift(); )
        r = s[0],
        r === "*" ? (o.push(r),
        a += s[1] === "?" ? "(?:/(.*))?" : "/(.*)") : r === ":" ? (n = s.indexOf("?", 1),
        i = s.indexOf(".", 1),
        o.push(s.substring(1, ~n ? n : ~i ? i : s.length)),
        a += ~n && !~i ? "(?:/([^/]+?))?" : "/([^/]+?)",
        ~i && (a += (~n ? "?" : "") + "\\" + s.substring(i))) : a += "/" + s;
    return {
        keys: o,
        pattern: new RegExp("^" + a + (e ? "(?=$|/)" : "/?$"),"i")
    }
}
var Mg = {
    exports: {}
}
  , Wg = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ts = j;
function vw(t, e) {
    return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
}
var ww = typeof Object.is == "function" ? Object.is : vw
  , bw = Ts.useState
  , xw = Ts.useEffect
  , _w = Ts.useLayoutEffect
  , Sw = Ts.useDebugValue;
function kw(t, e) {
    var r = e()
      , n = bw({
        inst: {
            value: r,
            getSnapshot: e
        }
    })
      , s = n[0].inst
      , i = n[1];
    return _w(function() {
        s.value = r,
        s.getSnapshot = e,
        xl(s) && i({
            inst: s
        })
    }, [t, r, e]),
    xw(function() {
        return xl(s) && i({
            inst: s
        }),
        t(function() {
            xl(s) && i({
                inst: s
            })
        })
    }, [t]),
    Sw(r),
    r
}
function xl(t) {
    var e = t.getSnapshot;
    t = t.value;
    try {
        var r = e();
        return !ww(t, r)
    } catch {
        return !0
    }
}
function Ew(t, e) {
    return e()
}
var Cw = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? Ew : kw;
Wg.useSyncExternalStore = Ts.useSyncExternalStore !== void 0 ? Ts.useSyncExternalStore : Cw;
Mg.exports = Wg;
var jw = Mg.exports;
const Tw = iv.useInsertionEffect
  , Pw = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , Ow = Pw ? j.useLayoutEffect : j.useEffect
  , Rw = Tw || Ow
  , Gg = t => {
    const e = j.useRef([t, (...r) => e[0](...r)]).current;
    return Rw( () => {
        e[0] = t
    }
    ),
    e[1]
}
  , Aw = "popstate"
  , Jc = "pushState"
  , Xc = "replaceState"
  , Iw = "hashchange"
  , Ch = [Aw, Jc, Xc, Iw]
  , Nw = t => {
    for (const e of Ch)
        addEventListener(e, t);
    return () => {
        for (const e of Ch)
            removeEventListener(e, t)
    }
}
  , Vg = (t, e) => jw.useSyncExternalStore(Nw, t, e)
  , jh = () => location.search
  , Lw = ({ssrSearch: t}={}) => Vg(jh, t != null ? () => t : jh)
  , Th = () => location.pathname
  , Dw = ({ssrPath: t}={}) => Vg(Th, t != null ? () => t : Th)
  , $w = (t, {replace: e=!1, state: r=null}={}) => history[e ? Xc : Jc](r, "", t)
  , Uw = (t={}) => [Dw(t), $w]
  , Ph = Symbol.for("wouter_v3");
if (typeof history < "u" && typeof window[Ph] > "u") {
    for (const t of [Jc, Xc]) {
        const e = history[t];
        history[t] = function() {
            const r = e.apply(this, arguments)
              , n = new Event(t);
            return n.arguments = arguments,
            dispatchEvent(n),
            r
        }
    }
    Object.defineProperty(window, Ph, {
        value: !0
    })
}
const Fw = (t, e) => e.toLowerCase().indexOf(t.toLowerCase()) ? "~" + e : e.slice(t.length) || "/"
  , Hg = (t="") => t === "/" ? "" : t
  , Bw = (t, e) => t[0] === "~" ? t.slice(1) : Hg(e) + t
  , zw = (t="", e) => Fw(Oh(Hg(t)), Oh(e))
  , Oh = t => {
    try {
        return decodeURI(t)
    } catch {
        return t
    }
}
  , qg = {
    hook: Uw,
    searchHook: Lw,
    parser: yw,
    base: "",
    ssrPath: void 0,
    ssrSearch: void 0,
    ssrContext: void 0,
    hrefs: t => t
}
  , Kg = j.createContext(qg)
  , Da = () => j.useContext(Kg)
  , Qg = {}
  , Jg = j.createContext(Qg)
  , Mw = () => j.useContext(Jg)
  , Yc = t => {
    const [e,r] = t.hook(t);
    return [zw(t.base, e), Gg( (n, s) => r(Bw(n, t.base), s))]
}
  , Rn = () => Yc(Da())
  , Ww = (t, e, r, n) => {
    const {pattern: s, keys: i} = e instanceof RegExp ? {
        keys: !1,
        pattern: e
    } : t(e || "*", n)
      , o = s.exec(r) || []
      , [a,...l] = o;
    return a !== void 0 ? [!0, ( () => {
        const c = i !== !1 ? Object.fromEntries(i.map( (h, f) => [h, l[f]])) : o.groups;
        let d = {
            ...l
        };
        return c && Object.assign(d, c),
        d
    }
    )(), ...n ? [a] : []] : [!1, null]
}
  , Xg = ({children: t, ...e}) => {
    var d, h, f;
    const r = Da()
      , n = e.hook ? qg : r;
    let s = n;
    const [i,o=e.ssrSearch ?? ""] = ((d = e.ssrPath) == null ? void 0 : d.split("?")) ?? [];
    i && (e.ssrSearch = o,
    e.ssrPath = i),
    e.hrefs = e.hrefs ?? ((h = e.hook) == null ? void 0 : h.hrefs),
    e.searchHook = e.searchHook ?? ((f = e.hook) == null ? void 0 : f.searchHook);
    let a = j.useRef({})
      , l = a.current
      , c = l;
    for (let p in n) {
        const v = p === "base" ? n[p] + (e[p] ?? "") : e[p] ?? n[p];
        l === c && v !== c[p] && (a.current = c = {
            ...c
        }),
        c[p] = v,
        (v !== n[p] || v !== s[p]) && (s = c)
    }
    return j.createElement(Kg.Provider, {
        value: s,
        children: t
    })
}
  , Rh = ({children: t, component: e}, r) => e ? j.createElement(e, {
    params: r
}) : typeof t == "function" ? t(r) : t
  , Gw = t => {
    let e = j.useRef(Qg);
    const r = e.current;
    return e.current = Object.keys(t).length !== Object.keys(r).length || Object.entries(t).some( ([n,s]) => s !== r[n]) ? t : r
}
  , Jr = ({path: t, nest: e, match: r, ...n}) => {
    const s = Da()
      , [i] = Yc(s)
      , [o,a,l] = r ?? Ww(s.parser, t, i, e)
      , c = Gw({
        ...Mw(),
        ...a
    });
    if (!o)
        return null;
    const d = l ? j.createElement(Xg, {
        base: l
    }, Rh(n, c)) : Rh(n, c);
    return j.createElement(Jg.Provider, {
        value: c,
        children: d
    })
}
;
j.forwardRef( (t, e) => {
    const r = Da()
      , [n,s] = Yc(r)
      , {to: i="", href: o=i, onClick: a, asChild: l, children: c, className: d, replace: h, state: f, ...p} = t
      , v = Gg(b => {
        b.ctrlKey || b.metaKey || b.altKey || b.shiftKey || b.button !== 0 || (a == null || a(b),
        b.defaultPrevented || (b.preventDefault(),
        s(o, t)))
    }
    )
      , w = r.hrefs(o[0] === "~" ? o.slice(1) : r.base + o, r);
    return l && j.isValidElement(c) ? j.cloneElement(c, {
        onClick: v,
        href: w
    }) : j.createElement("a", {
        ...p,
        onClick: v,
        href: w,
        className: d != null && d.call ? d(n === o) : d,
        children: c,
        ref: e
    })
}
);
var Gi = class {
    constructor() {
        this.listeners = new Set,
        this.subscribe = this.subscribe.bind(this)
    }
    subscribe(t) {
        return this.listeners.add(t),
        this.onSubscribe(),
        () => {
            this.listeners.delete(t),
            this.onUnsubscribe()
        }
    }
    hasListeners() {
        return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
}
, Vw = {
    setTimeout: (t, e) => setTimeout(t, e),
    clearTimeout: t => clearTimeout(t),
    setInterval: (t, e) => setInterval(t, e),
    clearInterval: t => clearInterval(t)
}, Sr, tc, yf, Hw = (yf = class {
    constructor() {
        G(this, Sr, Vw);
        G(this, tc, !1)
    }
    setTimeoutProvider(t) {
        $(this, Sr, t)
    }
    setTimeout(t, e) {
        return _(this, Sr).setTimeout(t, e)
    }
    clearTimeout(t) {
        _(this, Sr).clearTimeout(t)
    }
    setInterval(t, e) {
        return _(this, Sr).setInterval(t, e)
    }
    clearInterval(t) {
        _(this, Sr).clearInterval(t)
    }
}
,
Sr = new WeakMap,
tc = new WeakMap,
yf), cn = new Hw;
function qw(t) {
    setTimeout(t, 0)
}
var Tn = typeof window > "u" || "Deno"in globalThis;
function at() {}
function Kw(t, e) {
    return typeof t == "function" ? t(e) : t
}
function _u(t) {
    return typeof t == "number" && t >= 0 && t !== 1 / 0
}
function Yg(t, e) {
    return Math.max(t + (e || 0) - Date.now(), 0)
}
function zr(t, e) {
    return typeof t == "function" ? t(e) : t
}
function _t(t, e) {
    return typeof t == "function" ? t(e) : t
}
function Ah(t, e) {
    const {type: r="all", exact: n, fetchStatus: s, predicate: i, queryKey: o, stale: a} = t;
    if (o) {
        if (n) {
            if (e.queryHash !== Zc(o, e.options))
                return !1
        } else if (!Oi(e.queryKey, o))
            return !1
    }
    if (r !== "all") {
        const l = e.isActive();
        if (r === "active" && !l || r === "inactive" && l)
            return !1
    }
    return !(typeof a == "boolean" && e.isStale() !== a || s && s !== e.state.fetchStatus || i && !i(e))
}
function Ih(t, e) {
    const {exact: r, status: n, predicate: s, mutationKey: i} = t;
    if (i) {
        if (!e.options.mutationKey)
            return !1;
        if (r) {
            if (Pi(e.options.mutationKey) !== Pi(i))
                return !1
        } else if (!Oi(e.options.mutationKey, i))
            return !1
    }
    return !(n && e.state.status !== n || s && !s(e))
}
function Zc(t, e) {
    return ((e == null ? void 0 : e.queryKeyHashFn) || Pi)(t)
}
function Pi(t) {
    return JSON.stringify(t, (e, r) => ku(r) ? Object.keys(r).sort().reduce( (n, s) => (n[s] = r[s],
    n), {}) : r)
}
function Oi(t, e) {
    return t === e ? !0 : typeof t != typeof e ? !1 : t && e && typeof t == "object" && typeof e == "object" ? Object.keys(e).every(r => Oi(t[r], e[r])) : !1
}
var Qw = Object.prototype.hasOwnProperty;
function Zg(t, e) {
    if (t === e)
        return t;
    const r = Nh(t) && Nh(e);
    if (!r && !(ku(t) && ku(e)))
        return e;
    const s = (r ? t : Object.keys(t)).length
      , i = r ? e : Object.keys(e)
      , o = i.length
      , a = r ? new Array(o) : {};
    let l = 0;
    for (let c = 0; c < o; c++) {
        const d = r ? c : i[c]
          , h = t[d]
          , f = e[d];
        if (h === f) {
            a[d] = h,
            (r ? c < s : Qw.call(t, d)) && l++;
            continue
        }
        if (h === null || f === null || typeof h != "object" || typeof f != "object") {
            a[d] = f;
            continue
        }
        const p = Zg(h, f);
        a[d] = p,
        p === h && l++
    }
    return s === o && l === s ? t : a
}
function Su(t, e) {
    if (!e || Object.keys(t).length !== Object.keys(e).length)
        return !1;
    for (const r in t)
        if (t[r] !== e[r])
            return !1;
    return !0
}
function Nh(t) {
    return Array.isArray(t) && t.length === Object.keys(t).length
}
function ku(t) {
    if (!Lh(t))
        return !1;
    const e = t.constructor;
    if (e === void 0)
        return !0;
    const r = e.prototype;
    return !(!Lh(r) || !r.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype)
}
function Lh(t) {
    return Object.prototype.toString.call(t) === "[object Object]"
}
function Jw(t) {
    return new Promise(e => {
        cn.setTimeout(e, t)
    }
    )
}
function Eu(t, e, r) {
    return typeof r.structuralSharing == "function" ? r.structuralSharing(t, e) : r.structuralSharing !== !1 ? Zg(t, e) : e
}
function Xw(t, e, r=0) {
    const n = [...t, e];
    return r && n.length > r ? n.slice(1) : n
}
function Yw(t, e, r=0) {
    const n = [e, ...t];
    return r && n.length > r ? n.slice(0, -1) : n
}
var ed = Symbol();
function em(t, e) {
    return !t.queryFn && (e != null && e.initialPromise) ? () => e.initialPromise : !t.queryFn || t.queryFn === ed ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn
}
function Zw(t, e) {
    return typeof t == "function" ? t(...e) : !!t
}
var hn, kr, us, vf, eb = (vf = class extends Gi {
    constructor() {
        super();
        G(this, hn);
        G(this, kr);
        G(this, us);
        $(this, us, e => {
            if (!Tn && window.addEventListener) {
                const r = () => e();
                return window.addEventListener("visibilitychange", r, !1),
                () => {
                    window.removeEventListener("visibilitychange", r)
                }
            }
        }
        )
    }
    onSubscribe() {
        _(this, kr) || this.setEventListener(_(this, us))
    }
    onUnsubscribe() {
        var e;
        this.hasListeners() || ((e = _(this, kr)) == null || e.call(this),
        $(this, kr, void 0))
    }
    setEventListener(e) {
        var r;
        $(this, us, e),
        (r = _(this, kr)) == null || r.call(this),
        $(this, kr, e(n => {
            typeof n == "boolean" ? this.setFocused(n) : this.onFocus()
        }
        ))
    }
    setFocused(e) {
        _(this, hn) !== e && ($(this, hn, e),
        this.onFocus())
    }
    onFocus() {
        const e = this.isFocused();
        this.listeners.forEach(r => {
            r(e)
        }
        )
    }
    isFocused() {
        var e;
        return typeof _(this, hn) == "boolean" ? _(this, hn) : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== "hidden"
    }
}
,
hn = new WeakMap,
kr = new WeakMap,
us = new WeakMap,
vf), td = new eb;
function Cu() {
    let t, e;
    const r = new Promise( (s, i) => {
        t = s,
        e = i
    }
    );
    r.status = "pending",
    r.catch( () => {}
    );
    function n(s) {
        Object.assign(r, s),
        delete r.resolve,
        delete r.reject
    }
    return r.resolve = s => {
        n({
            status: "fulfilled",
            value: s
        }),
        t(s)
    }
    ,
    r.reject = s => {
        n({
            status: "rejected",
            reason: s
        }),
        e(s)
    }
    ,
    r
}
var tb = qw;
function rb() {
    let t = []
      , e = 0
      , r = a => {
        a()
    }
      , n = a => {
        a()
    }
      , s = tb;
    const i = a => {
        e ? t.push(a) : s( () => {
            r(a)
        }
        )
    }
      , o = () => {
        const a = t;
        t = [],
        a.length && s( () => {
            n( () => {
                a.forEach(l => {
                    r(l)
                }
                )
            }
            )
        }
        )
    }
    ;
    return {
        batch: a => {
            let l;
            e++;
            try {
                l = a()
            } finally {
                e--,
                e || o()
            }
            return l
        }
        ,
        batchCalls: a => (...l) => {
            i( () => {
                a(...l)
            }
            )
        }
        ,
        schedule: i,
        setNotifyFunction: a => {
            r = a
        }
        ,
        setBatchNotifyFunction: a => {
            n = a
        }
        ,
        setScheduler: a => {
            s = a
        }
    }
}
var Fe = rb(), cs, Er, ds, wf, nb = (wf = class extends Gi {
    constructor() {
        super();
        G(this, cs, !0);
        G(this, Er);
        G(this, ds);
        $(this, ds, e => {
            if (!Tn && window.addEventListener) {
                const r = () => e(!0)
                  , n = () => e(!1);
                return window.addEventListener("online", r, !1),
                window.addEventListener("offline", n, !1),
                () => {
                    window.removeEventListener("online", r),
                    window.removeEventListener("offline", n)
                }
            }
        }
        )
    }
    onSubscribe() {
        _(this, Er) || this.setEventListener(_(this, ds))
    }
    onUnsubscribe() {
        var e;
        this.hasListeners() || ((e = _(this, Er)) == null || e.call(this),
        $(this, Er, void 0))
    }
    setEventListener(e) {
        var r;
        $(this, ds, e),
        (r = _(this, Er)) == null || r.call(this),
        $(this, Er, e(this.setOnline.bind(this)))
    }
    setOnline(e) {
        _(this, cs) !== e && ($(this, cs, e),
        this.listeners.forEach(n => {
            n(e)
        }
        ))
    }
    isOnline() {
        return _(this, cs)
    }
}
,
cs = new WeakMap,
Er = new WeakMap,
ds = new WeakMap,
wf), la = new nb;
function sb(t) {
    return Math.min(1e3 * 2 ** t, 3e4)
}
function tm(t) {
    return (t ?? "online") === "online" ? la.isOnline() : !0
}
var ju = class extends Error {
    constructor(t) {
        super("CancelledError"),
        this.revert = t == null ? void 0 : t.revert,
        this.silent = t == null ? void 0 : t.silent
    }
}
;
function rm(t) {
    let e = !1, r = 0, n;
    const s = Cu()
      , i = () => s.status !== "pending"
      , o = w => {
        var b;
        if (!i()) {
            const g = new ju(w);
            f(g),
            (b = t.onCancel) == null || b.call(t, g)
        }
    }
      , a = () => {
        e = !0
    }
      , l = () => {
        e = !1
    }
      , c = () => td.isFocused() && (t.networkMode === "always" || la.isOnline()) && t.canRun()
      , d = () => tm(t.networkMode) && t.canRun()
      , h = w => {
        i() || (n == null || n(),
        s.resolve(w))
    }
      , f = w => {
        i() || (n == null || n(),
        s.reject(w))
    }
      , p = () => new Promise(w => {
        var b;
        n = g => {
            (i() || c()) && w(g)
        }
        ,
        (b = t.onPause) == null || b.call(t)
    }
    ).then( () => {
        var w;
        n = void 0,
        i() || (w = t.onContinue) == null || w.call(t)
    }
    )
      , v = () => {
        if (i())
            return;
        let w;
        const b = r === 0 ? t.initialPromise : void 0;
        try {
            w = b ?? t.fn()
        } catch (g) {
            w = Promise.reject(g)
        }
        Promise.resolve(w).then(h).catch(g => {
            var C;
            if (i())
                return;
            const m = t.retry ?? (Tn ? 0 : 3)
              , y = t.retryDelay ?? sb
              , x = typeof y == "function" ? y(r, g) : y
              , k = m === !0 || typeof m == "number" && r < m || typeof m == "function" && m(r, g);
            if (e || !k) {
                f(g);
                return
            }
            r++,
            (C = t.onFail) == null || C.call(t, r, g),
            Jw(x).then( () => c() ? void 0 : p()).then( () => {
                e ? f(g) : v()
            }
            )
        }
        )
    }
    ;
    return {
        promise: s,
        status: () => s.status,
        cancel: o,
        continue: () => (n == null || n(),
        s),
        cancelRetry: a,
        continueRetry: l,
        canStart: d,
        start: () => (d() ? v() : p().then(v),
        s)
    }
}
var fn, bf, nm = (bf = class {
    constructor() {
        G(this, fn)
    }
    destroy() {
        this.clearGcTimeout()
    }
    scheduleGc() {
        this.clearGcTimeout(),
        _u(this.gcTime) && $(this, fn, cn.setTimeout( () => {
            this.optionalRemove()
        }
        , this.gcTime))
    }
    updateGcTime(t) {
        this.gcTime = Math.max(this.gcTime || 0, t ?? (Tn ? 1 / 0 : 5 * 60 * 1e3))
    }
    clearGcTimeout() {
        _(this, fn) && (cn.clearTimeout(_(this, fn)),
        $(this, fn, void 0))
    }
}
,
fn = new WeakMap,
bf), pn, hs, xt, gn, Re, Ii, mn, It, Zt, xf, ib = (xf = class extends nm {
    constructor(e) {
        super();
        G(this, It);
        G(this, pn);
        G(this, hs);
        G(this, xt);
        G(this, gn);
        G(this, Re);
        G(this, Ii);
        G(this, mn);
        $(this, mn, !1),
        $(this, Ii, e.defaultOptions),
        this.setOptions(e.options),
        this.observers = [],
        $(this, gn, e.client),
        $(this, xt, _(this, gn).getQueryCache()),
        this.queryKey = e.queryKey,
        this.queryHash = e.queryHash,
        $(this, pn, $h(this.options)),
        this.state = e.state ?? _(this, pn),
        this.scheduleGc()
    }
    get meta() {
        return this.options.meta
    }
    get promise() {
        var e;
        return (e = _(this, Re)) == null ? void 0 : e.promise
    }
    setOptions(e) {
        if (this.options = {
            ..._(this, Ii),
            ...e
        },
        this.updateGcTime(this.options.gcTime),
        this.state && this.state.data === void 0) {
            const r = $h(this.options);
            r.data !== void 0 && (this.setState(Dh(r.data, r.dataUpdatedAt)),
            $(this, pn, r))
        }
    }
    optionalRemove() {
        !this.observers.length && this.state.fetchStatus === "idle" && _(this, xt).remove(this)
    }
    setData(e, r) {
        const n = Eu(this.state.data, e, this.options);
        return ee(this, It, Zt).call(this, {
            data: n,
            type: "success",
            dataUpdatedAt: r == null ? void 0 : r.updatedAt,
            manual: r == null ? void 0 : r.manual
        }),
        n
    }
    setState(e, r) {
        ee(this, It, Zt).call(this, {
            type: "setState",
            state: e,
            setStateOptions: r
        })
    }
    cancel(e) {
        var n, s;
        const r = (n = _(this, Re)) == null ? void 0 : n.promise;
        return (s = _(this, Re)) == null || s.cancel(e),
        r ? r.then(at).catch(at) : Promise.resolve()
    }
    destroy() {
        super.destroy(),
        this.cancel({
            silent: !0
        })
    }
    reset() {
        this.destroy(),
        this.setState(_(this, pn))
    }
    isActive() {
        return this.observers.some(e => _t(e.options.enabled, this) !== !1)
    }
    isDisabled() {
        return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === ed || this.state.dataUpdateCount + this.state.errorUpdateCount === 0
    }
    isStatic() {
        return this.getObserversCount() > 0 ? this.observers.some(e => zr(e.options.staleTime, this) === "static") : !1
    }
    isStale() {
        return this.getObserversCount() > 0 ? this.observers.some(e => e.getCurrentResult().isStale) : this.state.data === void 0 || this.state.isInvalidated
    }
    isStaleByTime(e=0) {
        return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !Yg(this.state.dataUpdatedAt, e)
    }
    onFocus() {
        var r;
        const e = this.observers.find(n => n.shouldFetchOnWindowFocus());
        e == null || e.refetch({
            cancelRefetch: !1
        }),
        (r = _(this, Re)) == null || r.continue()
    }
    onOnline() {
        var r;
        const e = this.observers.find(n => n.shouldFetchOnReconnect());
        e == null || e.refetch({
            cancelRefetch: !1
        }),
        (r = _(this, Re)) == null || r.continue()
    }
    addObserver(e) {
        this.observers.includes(e) || (this.observers.push(e),
        this.clearGcTimeout(),
        _(this, xt).notify({
            type: "observerAdded",
            query: this,
            observer: e
        }))
    }
    removeObserver(e) {
        this.observers.includes(e) && (this.observers = this.observers.filter(r => r !== e),
        this.observers.length || (_(this, Re) && (_(this, mn) ? _(this, Re).cancel({
            revert: !0
        }) : _(this, Re).cancelRetry()),
        this.scheduleGc()),
        _(this, xt).notify({
            type: "observerRemoved",
            query: this,
            observer: e
        }))
    }
    getObserversCount() {
        return this.observers.length
    }
    invalidate() {
        this.state.isInvalidated || ee(this, It, Zt).call(this, {
            type: "invalidate"
        })
    }
    async fetch(e, r) {
        var l, c, d, h, f, p, v, w, b, g, m, y;
        if (this.state.fetchStatus !== "idle" && ((l = _(this, Re)) == null ? void 0 : l.status()) !== "rejected") {
            if (this.state.data !== void 0 && (r != null && r.cancelRefetch))
                this.cancel({
                    silent: !0
                });
            else if (_(this, Re))
                return _(this, Re).continueRetry(),
                _(this, Re).promise
        }
        if (e && this.setOptions(e),
        !this.options.queryFn) {
            const x = this.observers.find(k => k.options.queryFn);
            x && this.setOptions(x.options)
        }
        const n = new AbortController
          , s = x => {
            Object.defineProperty(x, "signal", {
                enumerable: !0,
                get: () => ($(this, mn, !0),
                n.signal)
            })
        }
          , i = () => {
            const x = em(this.options, r)
              , C = ( () => {
                const T = {
                    client: _(this, gn),
                    queryKey: this.queryKey,
                    meta: this.meta
                };
                return s(T),
                T
            }
            )();
            return $(this, mn, !1),
            this.options.persister ? this.options.persister(x, C, this) : x(C)
        }
          , a = ( () => {
            const x = {
                fetchOptions: r,
                options: this.options,
                queryKey: this.queryKey,
                client: _(this, gn),
                state: this.state,
                fetchFn: i
            };
            return s(x),
            x
        }
        )();
        (c = this.options.behavior) == null || c.onFetch(a, this),
        $(this, hs, this.state),
        (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((d = a.fetchOptions) == null ? void 0 : d.meta)) && ee(this, It, Zt).call(this, {
            type: "fetch",
            meta: (h = a.fetchOptions) == null ? void 0 : h.meta
        }),
        $(this, Re, rm({
            initialPromise: r == null ? void 0 : r.initialPromise,
            fn: a.fetchFn,
            onCancel: x => {
                x instanceof ju && x.revert && this.setState({
                    ..._(this, hs),
                    fetchStatus: "idle"
                }),
                n.abort()
            }
            ,
            onFail: (x, k) => {
                ee(this, It, Zt).call(this, {
                    type: "failed",
                    failureCount: x,
                    error: k
                })
            }
            ,
            onPause: () => {
                ee(this, It, Zt).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: () => {
                ee(this, It, Zt).call(this, {
                    type: "continue"
                })
            }
            ,
            retry: a.options.retry,
            retryDelay: a.options.retryDelay,
            networkMode: a.options.networkMode,
            canRun: () => !0
        }));
        try {
            const x = await _(this, Re).start();
            if (x === void 0)
                throw new Error(`${this.queryHash} data is undefined`);
            return this.setData(x),
            (p = (f = _(this, xt).config).onSuccess) == null || p.call(f, x, this),
            (w = (v = _(this, xt).config).onSettled) == null || w.call(v, x, this.state.error, this),
            x
        } catch (x) {
            if (x instanceof ju) {
                if (x.silent)
                    return _(this, Re).promise;
                if (x.revert) {
                    if (this.state.data === void 0)
                        throw x;
                    return this.state.data
                }
            }
            throw ee(this, It, Zt).call(this, {
                type: "error",
                error: x
            }),
            (g = (b = _(this, xt).config).onError) == null || g.call(b, x, this),
            (y = (m = _(this, xt).config).onSettled) == null || y.call(m, this.state.data, x, this),
            x
        } finally {
            this.scheduleGc()
        }
    }
}
,
pn = new WeakMap,
hs = new WeakMap,
xt = new WeakMap,
gn = new WeakMap,
Re = new WeakMap,
Ii = new WeakMap,
mn = new WeakMap,
It = new WeakSet,
Zt = function(e) {
    const r = n => {
        switch (e.type) {
        case "failed":
            return {
                ...n,
                fetchFailureCount: e.failureCount,
                fetchFailureReason: e.error
            };
        case "pause":
            return {
                ...n,
                fetchStatus: "paused"
            };
        case "continue":
            return {
                ...n,
                fetchStatus: "fetching"
            };
        case "fetch":
            return {
                ...n,
                ...sm(n.data, this.options),
                fetchMeta: e.meta ?? null
            };
        case "success":
            const s = {
                ...n,
                ...Dh(e.data, e.dataUpdatedAt),
                dataUpdateCount: n.dataUpdateCount + 1,
                ...!e.manual && {
                    fetchStatus: "idle",
                    fetchFailureCount: 0,
                    fetchFailureReason: null
                }
            };
            return $(this, hs, e.manual ? s : void 0),
            s;
        case "error":
            const i = e.error;
            return {
                ...n,
                error: i,
                errorUpdateCount: n.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: n.fetchFailureCount + 1,
                fetchFailureReason: i,
                fetchStatus: "idle",
                status: "error"
            };
        case "invalidate":
            return {
                ...n,
                isInvalidated: !0
            };
        case "setState":
            return {
                ...n,
                ...e.state
            }
        }
    }
    ;
    this.state = r(this.state),
    Fe.batch( () => {
        this.observers.forEach(n => {
            n.onQueryUpdate()
        }
        ),
        _(this, xt).notify({
            query: this,
            type: "updated",
            action: e
        })
    }
    )
}
,
xf);
function sm(t, e) {
    return {
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchStatus: tm(e.networkMode) ? "fetching" : "paused",
        ...t === void 0 && {
            error: null,
            status: "pending"
        }
    }
}
function Dh(t, e) {
    return {
        data: t,
        dataUpdatedAt: e ?? Date.now(),
        error: null,
        isInvalidated: !1,
        status: "success"
    }
}
function $h(t) {
    const e = typeof t.initialData == "function" ? t.initialData() : t.initialData
      , r = e !== void 0
      , n = r ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0;
    return {
        data: e,
        dataUpdateCount: 0,
        dataUpdatedAt: r ? n ?? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: !1,
        status: r ? "success" : "pending",
        fetchStatus: "idle"
    }
}
var ot, te, Ni, Je, yn, fs, rr, Cr, Li, ps, gs, vn, wn, jr, ms, oe, Ys, Tu, Pu, Ou, Ru, Au, Iu, Nu, im, _f, ob = (_f = class extends Gi {
    constructor(e, r) {
        super();
        G(this, oe);
        G(this, ot);
        G(this, te);
        G(this, Ni);
        G(this, Je);
        G(this, yn);
        G(this, fs);
        G(this, rr);
        G(this, Cr);
        G(this, Li);
        G(this, ps);
        G(this, gs);
        G(this, vn);
        G(this, wn);
        G(this, jr);
        G(this, ms, new Set);
        this.options = r,
        $(this, ot, e),
        $(this, Cr, null),
        $(this, rr, Cu()),
        this.bindMethods(),
        this.setOptions(r)
    }
    bindMethods() {
        this.refetch = this.refetch.bind(this)
    }
    onSubscribe() {
        this.listeners.size === 1 && (_(this, te).addObserver(this),
        Uh(_(this, te), this.options) ? ee(this, oe, Ys).call(this) : this.updateResult(),
        ee(this, oe, Ru).call(this))
    }
    onUnsubscribe() {
        this.hasListeners() || this.destroy()
    }
    shouldFetchOnReconnect() {
        return Lu(_(this, te), this.options, this.options.refetchOnReconnect)
    }
    shouldFetchOnWindowFocus() {
        return Lu(_(this, te), this.options, this.options.refetchOnWindowFocus)
    }
    destroy() {
        this.listeners = new Set,
        ee(this, oe, Au).call(this),
        ee(this, oe, Iu).call(this),
        _(this, te).removeObserver(this)
    }
    setOptions(e) {
        const r = this.options
          , n = _(this, te);
        if (this.options = _(this, ot).defaultQueryOptions(e),
        this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof _t(this.options.enabled, _(this, te)) != "boolean")
            throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");
        ee(this, oe, Nu).call(this),
        _(this, te).setOptions(this.options),
        r._defaulted && !Su(this.options, r) && _(this, ot).getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: _(this, te),
            observer: this
        });
        const s = this.hasListeners();
        s && Fh(_(this, te), n, this.options, r) && ee(this, oe, Ys).call(this),
        this.updateResult(),
        s && (_(this, te) !== n || _t(this.options.enabled, _(this, te)) !== _t(r.enabled, _(this, te)) || zr(this.options.staleTime, _(this, te)) !== zr(r.staleTime, _(this, te))) && ee(this, oe, Tu).call(this);
        const i = ee(this, oe, Pu).call(this);
        s && (_(this, te) !== n || _t(this.options.enabled, _(this, te)) !== _t(r.enabled, _(this, te)) || i !== _(this, jr)) && ee(this, oe, Ou).call(this, i)
    }
    getOptimisticResult(e) {
        const r = _(this, ot).getQueryCache().build(_(this, ot), e)
          , n = this.createResult(r, e);
        return lb(this, n) && ($(this, Je, n),
        $(this, fs, this.options),
        $(this, yn, _(this, te).state)),
        n
    }
    getCurrentResult() {
        return _(this, Je)
    }
    trackResult(e, r) {
        return new Proxy(e,{
            get: (n, s) => (this.trackProp(s),
            r == null || r(s),
            s === "promise" && (this.trackProp("data"),
            !this.options.experimental_prefetchInRender && _(this, rr).status === "pending" && _(this, rr).reject(new Error("experimental_prefetchInRender feature flag is not enabled"))),
            Reflect.get(n, s))
        })
    }
    trackProp(e) {
        _(this, ms).add(e)
    }
    getCurrentQuery() {
        return _(this, te)
    }
    refetch({...e}={}) {
        return this.fetch({
            ...e
        })
    }
    fetchOptimistic(e) {
        const r = _(this, ot).defaultQueryOptions(e)
          , n = _(this, ot).getQueryCache().build(_(this, ot), r);
        return n.fetch().then( () => this.createResult(n, r))
    }
    fetch(e) {
        return ee(this, oe, Ys).call(this, {
            ...e,
            cancelRefetch: e.cancelRefetch ?? !0
        }).then( () => (this.updateResult(),
        _(this, Je)))
    }
    createResult(e, r) {
        var z;
        const n = _(this, te)
          , s = this.options
          , i = _(this, Je)
          , o = _(this, yn)
          , a = _(this, fs)
          , c = e !== n ? e.state : _(this, Ni)
          , {state: d} = e;
        let h = {
            ...d
        }, f = !1, p;
        if (r._optimisticResults) {
            const N = this.hasListeners()
              , Z = !N && Uh(e, r)
              , V = N && Fh(e, n, r, s);
            (Z || V) && (h = {
                ...h,
                ...sm(d.data, e.options)
            }),
            r._optimisticResults === "isRestoring" && (h.fetchStatus = "idle")
        }
        let {error: v, errorUpdatedAt: w, status: b} = h;
        p = h.data;
        let g = !1;
        if (r.placeholderData !== void 0 && p === void 0 && b === "pending") {
            let N;
            i != null && i.isPlaceholderData && r.placeholderData === (a == null ? void 0 : a.placeholderData) ? (N = i.data,
            g = !0) : N = typeof r.placeholderData == "function" ? r.placeholderData((z = _(this, gs)) == null ? void 0 : z.state.data, _(this, gs)) : r.placeholderData,
            N !== void 0 && (b = "success",
            p = Eu(i == null ? void 0 : i.data, N, r),
            f = !0)
        }
        if (r.select && p !== void 0 && !g)
            if (i && p === (o == null ? void 0 : o.data) && r.select === _(this, Li))
                p = _(this, ps);
            else
                try {
                    $(this, Li, r.select),
                    p = r.select(p),
                    p = Eu(i == null ? void 0 : i.data, p, r),
                    $(this, ps, p),
                    $(this, Cr, null)
                } catch (N) {
                    $(this, Cr, N)
                }
        _(this, Cr) && (v = _(this, Cr),
        p = _(this, ps),
        w = Date.now(),
        b = "error");
        const m = h.fetchStatus === "fetching"
          , y = b === "pending"
          , x = b === "error"
          , k = y && m
          , C = p !== void 0
          , I = {
            status: b,
            fetchStatus: h.fetchStatus,
            isPending: y,
            isSuccess: b === "success",
            isError: x,
            isInitialLoading: k,
            isLoading: k,
            data: p,
            dataUpdatedAt: h.dataUpdatedAt,
            error: v,
            errorUpdatedAt: w,
            failureCount: h.fetchFailureCount,
            failureReason: h.fetchFailureReason,
            errorUpdateCount: h.errorUpdateCount,
            isFetched: h.dataUpdateCount > 0 || h.errorUpdateCount > 0,
            isFetchedAfterMount: h.dataUpdateCount > c.dataUpdateCount || h.errorUpdateCount > c.errorUpdateCount,
            isFetching: m,
            isRefetching: m && !y,
            isLoadingError: x && !C,
            isPaused: h.fetchStatus === "paused",
            isPlaceholderData: f,
            isRefetchError: x && C,
            isStale: rd(e, r),
            refetch: this.refetch,
            promise: _(this, rr),
            isEnabled: _t(r.enabled, e) !== !1
        };
        if (this.options.experimental_prefetchInRender) {
            const N = he => {
                I.status === "error" ? he.reject(I.error) : I.data !== void 0 && he.resolve(I.data)
            }
              , Z = () => {
                const he = $(this, rr, I.promise = Cu());
                N(he)
            }
              , V = _(this, rr);
            switch (V.status) {
            case "pending":
                e.queryHash === n.queryHash && N(V);
                break;
            case "fulfilled":
                (I.status === "error" || I.data !== V.value) && Z();
                break;
            case "rejected":
                (I.status !== "error" || I.error !== V.reason) && Z();
                break
            }
        }
        return I
    }
    updateResult() {
        const e = _(this, Je)
          , r = this.createResult(_(this, te), this.options);
        if ($(this, yn, _(this, te).state),
        $(this, fs, this.options),
        _(this, yn).data !== void 0 && $(this, gs, _(this, te)),
        Su(r, e))
            return;
        $(this, Je, r);
        const n = () => {
            if (!e)
                return !0;
            const {notifyOnChangeProps: s} = this.options
              , i = typeof s == "function" ? s() : s;
            if (i === "all" || !i && !_(this, ms).size)
                return !0;
            const o = new Set(i ?? _(this, ms));
            return this.options.throwOnError && o.add("error"),
            Object.keys(_(this, Je)).some(a => {
                const l = a;
                return _(this, Je)[l] !== e[l] && o.has(l)
            }
            )
        }
        ;
        ee(this, oe, im).call(this, {
            listeners: n()
        })
    }
    onQueryUpdate() {
        this.updateResult(),
        this.hasListeners() && ee(this, oe, Ru).call(this)
    }
}
,
ot = new WeakMap,
te = new WeakMap,
Ni = new WeakMap,
Je = new WeakMap,
yn = new WeakMap,
fs = new WeakMap,
rr = new WeakMap,
Cr = new WeakMap,
Li = new WeakMap,
ps = new WeakMap,
gs = new WeakMap,
vn = new WeakMap,
wn = new WeakMap,
jr = new WeakMap,
ms = new WeakMap,
oe = new WeakSet,
Ys = function(e) {
    ee(this, oe, Nu).call(this);
    let r = _(this, te).fetch(this.options, e);
    return e != null && e.throwOnError || (r = r.catch(at)),
    r
}
,
Tu = function() {
    ee(this, oe, Au).call(this);
    const e = zr(this.options.staleTime, _(this, te));
    if (Tn || _(this, Je).isStale || !_u(e))
        return;
    const n = Yg(_(this, Je).dataUpdatedAt, e) + 1;
    $(this, vn, cn.setTimeout( () => {
        _(this, Je).isStale || this.updateResult()
    }
    , n))
}
,
Pu = function() {
    return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(_(this, te)) : this.options.refetchInterval) ?? !1
}
,
Ou = function(e) {
    ee(this, oe, Iu).call(this),
    $(this, jr, e),
    !(Tn || _t(this.options.enabled, _(this, te)) === !1 || !_u(_(this, jr)) || _(this, jr) === 0) && $(this, wn, cn.setInterval( () => {
        (this.options.refetchIntervalInBackground || td.isFocused()) && ee(this, oe, Ys).call(this)
    }
    , _(this, jr)))
}
,
Ru = function() {
    ee(this, oe, Tu).call(this),
    ee(this, oe, Ou).call(this, ee(this, oe, Pu).call(this))
}
,
Au = function() {
    _(this, vn) && (cn.clearTimeout(_(this, vn)),
    $(this, vn, void 0))
}
,
Iu = function() {
    _(this, wn) && (cn.clearInterval(_(this, wn)),
    $(this, wn, void 0))
}
,
Nu = function() {
    const e = _(this, ot).getQueryCache().build(_(this, ot), this.options);
    if (e === _(this, te))
        return;
    const r = _(this, te);
    $(this, te, e),
    $(this, Ni, e.state),
    this.hasListeners() && (r == null || r.removeObserver(this),
    e.addObserver(this))
}
,
im = function(e) {
    Fe.batch( () => {
        e.listeners && this.listeners.forEach(r => {
            r(_(this, Je))
        }
        ),
        _(this, ot).getQueryCache().notify({
            query: _(this, te),
            type: "observerResultsUpdated"
        })
    }
    )
}
,
_f);
function ab(t, e) {
    return _t(e.enabled, t) !== !1 && t.state.data === void 0 && !(t.state.status === "error" && e.retryOnMount === !1)
}
function Uh(t, e) {
    return ab(t, e) || t.state.data !== void 0 && Lu(t, e, e.refetchOnMount)
}
function Lu(t, e, r) {
    if (_t(e.enabled, t) !== !1 && zr(e.staleTime, t) !== "static") {
        const n = typeof r == "function" ? r(t) : r;
        return n === "always" || n !== !1 && rd(t, e)
    }
    return !1
}
function Fh(t, e, r, n) {
    return (t !== e || _t(n.enabled, t) === !1) && (!r.suspense || t.state.status !== "error") && rd(t, r)
}
function rd(t, e) {
    return _t(e.enabled, t) !== !1 && t.isStaleByTime(zr(e.staleTime, t))
}
function lb(t, e) {
    return !Su(t.getCurrentResult(), e)
}
function Bh(t) {
    return {
        onFetch: (e, r) => {
            var d, h, f, p, v;
            const n = e.options
              , s = (f = (h = (d = e.fetchOptions) == null ? void 0 : d.meta) == null ? void 0 : h.fetchMore) == null ? void 0 : f.direction
              , i = ((p = e.state.data) == null ? void 0 : p.pages) || []
              , o = ((v = e.state.data) == null ? void 0 : v.pageParams) || [];
            let a = {
                pages: [],
                pageParams: []
            }
              , l = 0;
            const c = async () => {
                let w = !1;
                const b = y => {
                    Object.defineProperty(y, "signal", {
                        enumerable: !0,
                        get: () => (e.signal.aborted ? w = !0 : e.signal.addEventListener("abort", () => {
                            w = !0
                        }
                        ),
                        e.signal)
                    })
                }
                  , g = em(e.options, e.fetchOptions)
                  , m = async (y, x, k) => {
                    if (w)
                        return Promise.reject();
                    if (x == null && y.pages.length)
                        return Promise.resolve(y);
                    const T = ( () => {
                        const Z = {
                            client: e.client,
                            queryKey: e.queryKey,
                            pageParam: x,
                            direction: k ? "backward" : "forward",
                            meta: e.options.meta
                        };
                        return b(Z),
                        Z
                    }
                    )()
                      , I = await g(T)
                      , {maxPages: z} = e.options
                      , N = k ? Yw : Xw;
                    return {
                        pages: N(y.pages, I, z),
                        pageParams: N(y.pageParams, x, z)
                    }
                }
                ;
                if (s && i.length) {
                    const y = s === "backward"
                      , x = y ? ub : zh
                      , k = {
                        pages: i,
                        pageParams: o
                    }
                      , C = x(n, k);
                    a = await m(k, C, y)
                } else {
                    const y = t ?? i.length;
                    do {
                        const x = l === 0 ? o[0] ?? n.initialPageParam : zh(n, a);
                        if (l > 0 && x == null)
                            break;
                        a = await m(a, x),
                        l++
                    } while (l < y)
                }
                return a
            }
            ;
            e.options.persister ? e.fetchFn = () => {
                var w, b;
                return (b = (w = e.options).persister) == null ? void 0 : b.call(w, c, {
                    client: e.client,
                    queryKey: e.queryKey,
                    meta: e.options.meta,
                    signal: e.signal
                }, r)
            }
            : e.fetchFn = c
        }
    }
}
function zh(t, {pages: e, pageParams: r}) {
    const n = e.length - 1;
    return e.length > 0 ? t.getNextPageParam(e[n], e, r[n], r) : void 0
}
function ub(t, {pages: e, pageParams: r}) {
    var n;
    return e.length > 0 ? (n = t.getPreviousPageParam) == null ? void 0 : n.call(t, e[0], e, r[0], r) : void 0
}
var Di, Ht, Xe, bn, qt, mr, Sf, cb = (Sf = class extends nm {
    constructor(e) {
        super();
        G(this, qt);
        G(this, Di);
        G(this, Ht);
        G(this, Xe);
        G(this, bn);
        $(this, Di, e.client),
        this.mutationId = e.mutationId,
        $(this, Xe, e.mutationCache),
        $(this, Ht, []),
        this.state = e.state || db(),
        this.setOptions(e.options),
        this.scheduleGc()
    }
    setOptions(e) {
        this.options = e,
        this.updateGcTime(this.options.gcTime)
    }
    get meta() {
        return this.options.meta
    }
    addObserver(e) {
        _(this, Ht).includes(e) || (_(this, Ht).push(e),
        this.clearGcTimeout(),
        _(this, Xe).notify({
            type: "observerAdded",
            mutation: this,
            observer: e
        }))
    }
    removeObserver(e) {
        $(this, Ht, _(this, Ht).filter(r => r !== e)),
        this.scheduleGc(),
        _(this, Xe).notify({
            type: "observerRemoved",
            mutation: this,
            observer: e
        })
    }
    optionalRemove() {
        _(this, Ht).length || (this.state.status === "pending" ? this.scheduleGc() : _(this, Xe).remove(this))
    }
    continue() {
        var e;
        return ((e = _(this, bn)) == null ? void 0 : e.continue()) ?? this.execute(this.state.variables)
    }
    async execute(e) {
        var o, a, l, c, d, h, f, p, v, w, b, g, m, y, x, k, C, T, I, z;
        const r = () => {
            ee(this, qt, mr).call(this, {
                type: "continue"
            })
        }
          , n = {
            client: _(this, Di),
            meta: this.options.meta,
            mutationKey: this.options.mutationKey
        };
        $(this, bn, rm({
            fn: () => this.options.mutationFn ? this.options.mutationFn(e, n) : Promise.reject(new Error("No mutationFn found")),
            onFail: (N, Z) => {
                ee(this, qt, mr).call(this, {
                    type: "failed",
                    failureCount: N,
                    error: Z
                })
            }
            ,
            onPause: () => {
                ee(this, qt, mr).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: r,
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => _(this, Xe).canRun(this)
        }));
        const s = this.state.status === "pending"
          , i = !_(this, bn).canStart();
        try {
            if (s)
                r();
            else {
                ee(this, qt, mr).call(this, {
                    type: "pending",
                    variables: e,
                    isPaused: i
                }),
                await ((a = (o = _(this, Xe).config).onMutate) == null ? void 0 : a.call(o, e, this, n));
                const Z = await ((c = (l = this.options).onMutate) == null ? void 0 : c.call(l, e, n));
                Z !== this.state.context && ee(this, qt, mr).call(this, {
                    type: "pending",
                    context: Z,
                    variables: e,
                    isPaused: i
                })
            }
            const N = await _(this, bn).start();
            return await ((h = (d = _(this, Xe).config).onSuccess) == null ? void 0 : h.call(d, N, e, this.state.context, this, n)),
            await ((p = (f = this.options).onSuccess) == null ? void 0 : p.call(f, N, e, this.state.context, n)),
            await ((w = (v = _(this, Xe).config).onSettled) == null ? void 0 : w.call(v, N, null, this.state.variables, this.state.context, this, n)),
            await ((g = (b = this.options).onSettled) == null ? void 0 : g.call(b, N, null, e, this.state.context, n)),
            ee(this, qt, mr).call(this, {
                type: "success",
                data: N
            }),
            N
        } catch (N) {
            try {
                throw await ((y = (m = _(this, Xe).config).onError) == null ? void 0 : y.call(m, N, e, this.state.context, this, n)),
                await ((k = (x = this.options).onError) == null ? void 0 : k.call(x, N, e, this.state.context, n)),
                await ((T = (C = _(this, Xe).config).onSettled) == null ? void 0 : T.call(C, void 0, N, this.state.variables, this.state.context, this, n)),
                await ((z = (I = this.options).onSettled) == null ? void 0 : z.call(I, void 0, N, e, this.state.context, n)),
                N
            } finally {
                ee(this, qt, mr).call(this, {
                    type: "error",
                    error: N
                })
            }
        } finally {
            _(this, Xe).runNext(this)
        }
    }
}
,
Di = new WeakMap,
Ht = new WeakMap,
Xe = new WeakMap,
bn = new WeakMap,
qt = new WeakSet,
mr = function(e) {
    const r = n => {
        switch (e.type) {
        case "failed":
            return {
                ...n,
                failureCount: e.failureCount,
                failureReason: e.error
            };
        case "pause":
            return {
                ...n,
                isPaused: !0
            };
        case "continue":
            return {
                ...n,
                isPaused: !1
            };
        case "pending":
            return {
                ...n,
                context: e.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: e.isPaused,
                status: "pending",
                variables: e.variables,
                submittedAt: Date.now()
            };
        case "success":
            return {
                ...n,
                data: e.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: "success",
                isPaused: !1
            };
        case "error":
            return {
                ...n,
                data: void 0,
                error: e.error,
                failureCount: n.failureCount + 1,
                failureReason: e.error,
                isPaused: !1,
                status: "error"
            }
        }
    }
    ;
    this.state = r(this.state),
    Fe.batch( () => {
        _(this, Ht).forEach(n => {
            n.onMutationUpdate(e)
        }
        ),
        _(this, Xe).notify({
            mutation: this,
            type: "updated",
            action: e
        })
    }
    )
}
,
Sf);
function db() {
    return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: "idle",
        variables: void 0,
        submittedAt: 0
    }
}
var nr, Nt, $i, kf, hb = (kf = class extends Gi {
    constructor(e={}) {
        super();
        G(this, nr);
        G(this, Nt);
        G(this, $i);
        this.config = e,
        $(this, nr, new Set),
        $(this, Nt, new Map),
        $(this, $i, 0)
    }
    build(e, r, n) {
        const s = new cb({
            client: e,
            mutationCache: this,
            mutationId: ++qi(this, $i)._,
            options: e.defaultMutationOptions(r),
            state: n
        });
        return this.add(s),
        s
    }
    add(e) {
        _(this, nr).add(e);
        const r = ho(e);
        if (typeof r == "string") {
            const n = _(this, Nt).get(r);
            n ? n.push(e) : _(this, Nt).set(r, [e])
        }
        this.notify({
            type: "added",
            mutation: e
        })
    }
    remove(e) {
        if (_(this, nr).delete(e)) {
            const r = ho(e);
            if (typeof r == "string") {
                const n = _(this, Nt).get(r);
                if (n)
                    if (n.length > 1) {
                        const s = n.indexOf(e);
                        s !== -1 && n.splice(s, 1)
                    } else
                        n[0] === e && _(this, Nt).delete(r)
            }
        }
        this.notify({
            type: "removed",
            mutation: e
        })
    }
    canRun(e) {
        const r = ho(e);
        if (typeof r == "string") {
            const n = _(this, Nt).get(r)
              , s = n == null ? void 0 : n.find(i => i.state.status === "pending");
            return !s || s === e
        } else
            return !0
    }
    runNext(e) {
        var n;
        const r = ho(e);
        if (typeof r == "string") {
            const s = (n = _(this, Nt).get(r)) == null ? void 0 : n.find(i => i !== e && i.state.isPaused);
            return (s == null ? void 0 : s.continue()) ?? Promise.resolve()
        } else
            return Promise.resolve()
    }
    clear() {
        Fe.batch( () => {
            _(this, nr).forEach(e => {
                this.notify({
                    type: "removed",
                    mutation: e
                })
            }
            ),
            _(this, nr).clear(),
            _(this, Nt).clear()
        }
        )
    }
    getAll() {
        return Array.from(_(this, nr))
    }
    find(e) {
        const r = {
            exact: !0,
            ...e
        };
        return this.getAll().find(n => Ih(r, n))
    }
    findAll(e={}) {
        return this.getAll().filter(r => Ih(e, r))
    }
    notify(e) {
        Fe.batch( () => {
            this.listeners.forEach(r => {
                r(e)
            }
            )
        }
        )
    }
    resumePausedMutations() {
        const e = this.getAll().filter(r => r.state.isPaused);
        return Fe.batch( () => Promise.all(e.map(r => r.continue().catch(at))))
    }
}
,
nr = new WeakMap,
Nt = new WeakMap,
$i = new WeakMap,
kf);
function ho(t) {
    var e;
    return (e = t.options.scope) == null ? void 0 : e.id
}
var Kt, Ef, fb = (Ef = class extends Gi {
    constructor(e={}) {
        super();
        G(this, Kt);
        this.config = e,
        $(this, Kt, new Map)
    }
    build(e, r, n) {
        const s = r.queryKey
          , i = r.queryHash ?? Zc(s, r);
        let o = this.get(i);
        return o || (o = new ib({
            client: e,
            queryKey: s,
            queryHash: i,
            options: e.defaultQueryOptions(r),
            state: n,
            defaultOptions: e.getQueryDefaults(s)
        }),
        this.add(o)),
        o
    }
    add(e) {
        _(this, Kt).has(e.queryHash) || (_(this, Kt).set(e.queryHash, e),
        this.notify({
            type: "added",
            query: e
        }))
    }
    remove(e) {
        const r = _(this, Kt).get(e.queryHash);
        r && (e.destroy(),
        r === e && _(this, Kt).delete(e.queryHash),
        this.notify({
            type: "removed",
            query: e
        }))
    }
    clear() {
        Fe.batch( () => {
            this.getAll().forEach(e => {
                this.remove(e)
            }
            )
        }
        )
    }
    get(e) {
        return _(this, Kt).get(e)
    }
    getAll() {
        return [..._(this, Kt).values()]
    }
    find(e) {
        const r = {
            exact: !0,
            ...e
        };
        return this.getAll().find(n => Ah(r, n))
    }
    findAll(e={}) {
        const r = this.getAll();
        return Object.keys(e).length > 0 ? r.filter(n => Ah(e, n)) : r
    }
    notify(e) {
        Fe.batch( () => {
            this.listeners.forEach(r => {
                r(e)
            }
            )
        }
        )
    }
    onFocus() {
        Fe.batch( () => {
            this.getAll().forEach(e => {
                e.onFocus()
            }
            )
        }
        )
    }
    onOnline() {
        Fe.batch( () => {
            this.getAll().forEach(e => {
                e.onOnline()
            }
            )
        }
        )
    }
}
,
Kt = new WeakMap,
Ef), Se, Tr, Pr, ys, vs, Or, ws, bs, Cf, pb = (Cf = class {
    constructor(t={}) {
        G(this, Se);
        G(this, Tr);
        G(this, Pr);
        G(this, ys);
        G(this, vs);
        G(this, Or);
        G(this, ws);
        G(this, bs);
        $(this, Se, t.queryCache || new fb),
        $(this, Tr, t.mutationCache || new hb),
        $(this, Pr, t.defaultOptions || {}),
        $(this, ys, new Map),
        $(this, vs, new Map),
        $(this, Or, 0)
    }
    mount() {
        qi(this, Or)._++,
        _(this, Or) === 1 && ($(this, ws, td.subscribe(async t => {
            t && (await this.resumePausedMutations(),
            _(this, Se).onFocus())
        }
        )),
        $(this, bs, la.subscribe(async t => {
            t && (await this.resumePausedMutations(),
            _(this, Se).onOnline())
        }
        )))
    }
    unmount() {
        var t, e;
        qi(this, Or)._--,
        _(this, Or) === 0 && ((t = _(this, ws)) == null || t.call(this),
        $(this, ws, void 0),
        (e = _(this, bs)) == null || e.call(this),
        $(this, bs, void 0))
    }
    isFetching(t) {
        return _(this, Se).findAll({
            ...t,
            fetchStatus: "fetching"
        }).length
    }
    isMutating(t) {
        return _(this, Tr).findAll({
            ...t,
            status: "pending"
        }).length
    }
    getQueryData(t) {
        var r;
        const e = this.defaultQueryOptions({
            queryKey: t
        });
        return (r = _(this, Se).get(e.queryHash)) == null ? void 0 : r.state.data
    }
    ensureQueryData(t) {
        const e = this.defaultQueryOptions(t)
          , r = _(this, Se).build(this, e)
          , n = r.state.data;
        return n === void 0 ? this.fetchQuery(t) : (t.revalidateIfStale && r.isStaleByTime(zr(e.staleTime, r)) && this.prefetchQuery(e),
        Promise.resolve(n))
    }
    getQueriesData(t) {
        return _(this, Se).findAll(t).map( ({queryKey: e, state: r}) => {
            const n = r.data;
            return [e, n]
        }
        )
    }
    setQueryData(t, e, r) {
        const n = this.defaultQueryOptions({
            queryKey: t
        })
          , s = _(this, Se).get(n.queryHash)
          , i = s == null ? void 0 : s.state.data
          , o = Kw(e, i);
        if (o !== void 0)
            return _(this, Se).build(this, n).setData(o, {
                ...r,
                manual: !0
            })
    }
    setQueriesData(t, e, r) {
        return Fe.batch( () => _(this, Se).findAll(t).map( ({queryKey: n}) => [n, this.setQueryData(n, e, r)]))
    }
    getQueryState(t) {
        var r;
        const e = this.defaultQueryOptions({
            queryKey: t
        });
        return (r = _(this, Se).get(e.queryHash)) == null ? void 0 : r.state
    }
    removeQueries(t) {
        const e = _(this, Se);
        Fe.batch( () => {
            e.findAll(t).forEach(r => {
                e.remove(r)
            }
            )
        }
        )
    }
    resetQueries(t, e) {
        const r = _(this, Se);
        return Fe.batch( () => (r.findAll(t).forEach(n => {
            n.reset()
        }
        ),
        this.refetchQueries({
            type: "active",
            ...t
        }, e)))
    }
    cancelQueries(t, e={}) {
        const r = {
            revert: !0,
            ...e
        }
          , n = Fe.batch( () => _(this, Se).findAll(t).map(s => s.cancel(r)));
        return Promise.all(n).then(at).catch(at)
    }
    invalidateQueries(t, e={}) {
        return Fe.batch( () => (_(this, Se).findAll(t).forEach(r => {
            r.invalidate()
        }
        ),
        (t == null ? void 0 : t.refetchType) === "none" ? Promise.resolve() : this.refetchQueries({
            ...t,
            type: (t == null ? void 0 : t.refetchType) ?? (t == null ? void 0 : t.type) ?? "active"
        }, e)))
    }
    refetchQueries(t, e={}) {
        const r = {
            ...e,
            cancelRefetch: e.cancelRefetch ?? !0
        }
          , n = Fe.batch( () => _(this, Se).findAll(t).filter(s => !s.isDisabled() && !s.isStatic()).map(s => {
            let i = s.fetch(void 0, r);
            return r.throwOnError || (i = i.catch(at)),
            s.state.fetchStatus === "paused" ? Promise.resolve() : i
        }
        ));
        return Promise.all(n).then(at)
    }
    fetchQuery(t) {
        const e = this.defaultQueryOptions(t);
        e.retry === void 0 && (e.retry = !1);
        const r = _(this, Se).build(this, e);
        return r.isStaleByTime(zr(e.staleTime, r)) ? r.fetch(e) : Promise.resolve(r.state.data)
    }
    prefetchQuery(t) {
        return this.fetchQuery(t).then(at).catch(at)
    }
    fetchInfiniteQuery(t) {
        return t.behavior = Bh(t.pages),
        this.fetchQuery(t)
    }
    prefetchInfiniteQuery(t) {
        return this.fetchInfiniteQuery(t).then(at).catch(at)
    }
    ensureInfiniteQueryData(t) {
        return t.behavior = Bh(t.pages),
        this.ensureQueryData(t)
    }
    resumePausedMutations() {
        return la.isOnline() ? _(this, Tr).resumePausedMutations() : Promise.resolve()
    }
    getQueryCache() {
        return _(this, Se)
    }
    getMutationCache() {
        return _(this, Tr)
    }
    getDefaultOptions() {
        return _(this, Pr)
    }
    setDefaultOptions(t) {
        $(this, Pr, t)
    }
    setQueryDefaults(t, e) {
        _(this, ys).set(Pi(t), {
            queryKey: t,
            defaultOptions: e
        })
    }
    getQueryDefaults(t) {
        const e = [..._(this, ys).values()]
          , r = {};
        return e.forEach(n => {
            Oi(t, n.queryKey) && Object.assign(r, n.defaultOptions)
        }
        ),
        r
    }
    setMutationDefaults(t, e) {
        _(this, vs).set(Pi(t), {
            mutationKey: t,
            defaultOptions: e
        })
    }
    getMutationDefaults(t) {
        const e = [..._(this, vs).values()]
          , r = {};
        return e.forEach(n => {
            Oi(t, n.mutationKey) && Object.assign(r, n.defaultOptions)
        }
        ),
        r
    }
    defaultQueryOptions(t) {
        if (t._defaulted)
            return t;
        const e = {
            ..._(this, Pr).queries,
            ...this.getQueryDefaults(t.queryKey),
            ...t,
            _defaulted: !0
        };
        return e.queryHash || (e.queryHash = Zc(e.queryKey, e)),
        e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"),
        e.throwOnError === void 0 && (e.throwOnError = !!e.suspense),
        !e.networkMode && e.persister && (e.networkMode = "offlineFirst"),
        e.queryFn === ed && (e.enabled = !1),
        e
    }
    defaultMutationOptions(t) {
        return t != null && t._defaulted ? t : {
            ..._(this, Pr).mutations,
            ...(t == null ? void 0 : t.mutationKey) && this.getMutationDefaults(t.mutationKey),
            ...t,
            _defaulted: !0
        }
    }
    clear() {
        _(this, Se).clear(),
        _(this, Tr).clear()
    }
}
,
Se = new WeakMap,
Tr = new WeakMap,
Pr = new WeakMap,
ys = new WeakMap,
vs = new WeakMap,
Or = new WeakMap,
ws = new WeakMap,
bs = new WeakMap,
Cf), om = j.createContext(void 0), gb = t => {
    const e = j.useContext(om);
    if (!e)
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return e
}
, mb = ({client: t, children: e}) => (j.useEffect( () => (t.mount(),
() => {
    t.unmount()
}
), [t]),
u.jsx(om.Provider, {
    value: t,
    children: e
})), am = j.createContext(!1), yb = () => j.useContext(am);
am.Provider;
function vb() {
    let t = !1;
    return {
        clearReset: () => {
            t = !1
        }
        ,
        reset: () => {
            t = !0
        }
        ,
        isReset: () => t
    }
}
var wb = j.createContext(vb())
  , bb = () => j.useContext(wb)
  , xb = (t, e) => {
    (t.suspense || t.throwOnError || t.experimental_prefetchInRender) && (e.isReset() || (t.retryOnMount = !1))
}
  , _b = t => {
    j.useEffect( () => {
        t.clearReset()
    }
    , [t])
}
  , Sb = ({result: t, errorResetBoundary: e, throwOnError: r, query: n, suspense: s}) => t.isError && !e.isReset() && !t.isFetching && n && (s && t.data === void 0 || Zw(r, [t.error, n]))
  , kb = t => {
    if (t.suspense) {
        const r = s => s === "static" ? s : Math.max(s ?? 1e3, 1e3)
          , n = t.staleTime;
        t.staleTime = typeof n == "function" ? (...s) => r(n(...s)) : r(n),
        typeof t.gcTime == "number" && (t.gcTime = Math.max(t.gcTime, 1e3))
    }
}
  , Eb = (t, e) => t.isLoading && t.isFetching && !e
  , Cb = (t, e) => (t == null ? void 0 : t.suspense) && e.isPending
  , Mh = (t, e, r) => e.fetchOptimistic(t).catch( () => {
    r.clearReset()
}
);
function jb(t, e, r) {
    var h, f, p, v, w;
    const n = yb()
      , s = bb()
      , i = gb()
      , o = i.defaultQueryOptions(t);
    (f = (h = i.getDefaultOptions().queries) == null ? void 0 : h._experimental_beforeQuery) == null || f.call(h, o),
    o._optimisticResults = n ? "isRestoring" : "optimistic",
    kb(o),
    xb(o, s),
    _b(s);
    const a = !i.getQueryCache().get(o.queryHash)
      , [l] = j.useState( () => new e(i,o))
      , c = l.getOptimisticResult(o)
      , d = !n && t.subscribed !== !1;
    if (j.useSyncExternalStore(j.useCallback(b => {
        const g = d ? l.subscribe(Fe.batchCalls(b)) : at;
        return l.updateResult(),
        g
    }
    , [l, d]), () => l.getCurrentResult(), () => l.getCurrentResult()),
    j.useEffect( () => {
        l.setOptions(o)
    }
    , [o, l]),
    Cb(o, c))
        throw Mh(o, l, s);
    if (Sb({
        result: c,
        errorResetBoundary: s,
        throwOnError: o.throwOnError,
        query: i.getQueryCache().get(o.queryHash),
        suspense: o.suspense
    }))
        throw c.error;
    if ((v = (p = i.getDefaultOptions().queries) == null ? void 0 : p._experimental_afterQuery) == null || v.call(p, o, c),
    o.experimental_prefetchInRender && !Tn && Eb(c, n)) {
        const b = a ? Mh(o, l, s) : (w = i.getQueryCache().get(o.queryHash)) == null ? void 0 : w.promise;
        b == null || b.catch(at).finally( () => {
            l.updateResult()
        }
        )
    }
    return o.notifyOnChangeProps ? c : l.trackResult(c)
}
function Tb(t, e) {
    return jb(t, ob)
}
function Pb() {
    return null
}
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ob = t => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()
  , lm = (...t) => t.filter( (e, r, n) => !!e && n.indexOf(e) === r).join(" ");
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Rb = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ab = j.forwardRef( ({color: t="currentColor", size: e=24, strokeWidth: r=2, absoluteStrokeWidth: n, className: s="", children: i, iconNode: o, ...a}, l) => j.createElement("svg", {
    ref: l,
    ...Rb,
    width: e,
    height: e,
    stroke: t,
    strokeWidth: n ? Number(r) * 24 / Number(e) : r,
    className: lm("lucide", s),
    ...a
}, [...o.map( ([c,d]) => j.createElement(c, d)), ...Array.isArray(i) ? i : [i]]));
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const st = (t, e) => {
    const r = j.forwardRef( ({className: n, ...s}, i) => j.createElement(Ab, {
        ref: i,
        iconNode: e,
        className: lm(`lucide-${Ob(t)}`, n),
        ...s
    }));
    return r.displayName = `${t}`,
    r
}
;
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const $a = st("ArrowLeft", [["path", {
    d: "m12 19-7-7 7-7",
    key: "1l729n"
}], ["path", {
    d: "M19 12H5",
    key: "x3x0zl"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ib = st("CircleCheck", [["circle", {
    cx: "12",
    cy: "12",
    r: "10",
    key: "1mglay"
}], ["path", {
    d: "m9 12 2 2 4-4",
    key: "dzmm74"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Nb = st("Clock", [["circle", {
    cx: "12",
    cy: "12",
    r: "10",
    key: "1mglay"
}], ["polyline", {
    points: "12 6 12 12 16 14",
    key: "68esgv"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Lb = st("Download", [["path", {
    d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",
    key: "ih7n3h"
}], ["polyline", {
    points: "7 10 12 15 17 10",
    key: "2ggqvy"
}], ["line", {
    x1: "12",
    x2: "12",
    y1: "15",
    y2: "3",
    key: "1vk2je"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Wh = st("LogOut", [["path", {
    d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",
    key: "1uf3rs"
}], ["polyline", {
    points: "16 17 21 12 16 7",
    key: "1gabdz"
}], ["line", {
    x1: "21",
    x2: "9",
    y1: "12",
    y2: "12",
    key: "1uyos4"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const um = st("Menu", [["line", {
    x1: "4",
    x2: "20",
    y1: "12",
    y2: "12",
    key: "1e0a9i"
}], ["line", {
    x1: "4",
    x2: "20",
    y1: "6",
    y2: "6",
    key: "1owob3"
}], ["line", {
    x1: "4",
    x2: "20",
    y1: "18",
    y2: "18",
    key: "yk5zj1"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nd = st("MessageCircle", [["path", {
    d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z",
    key: "vv11sd"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Db = st("Package", [["path", {
    d: "M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z",
    key: "1a0edw"
}], ["path", {
    d: "M12 22V12",
    key: "d0xqtd"
}], ["path", {
    d: "m3.3 7 7.703 4.734a2 2 0 0 0 1.994 0L20.7 7",
    key: "yx3hmr"
}], ["path", {
    d: "m7.5 4.27 9 5.15",
    key: "1c824w"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const cm = st("Plus", [["path", {
    d: "M5 12h14",
    key: "1ays0h"
}], ["path", {
    d: "M12 5v14",
    key: "s699le"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const $b = st("RefreshCw", [["path", {
    d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8",
    key: "v9h5vc"
}], ["path", {
    d: "M21 3v5h-5",
    key: "1q7to0"
}], ["path", {
    d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16",
    key: "3uifl3"
}], ["path", {
    d: "M8 16H3v5",
    key: "1cv678"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ub = st("Search", [["circle", {
    cx: "11",
    cy: "11",
    r: "8",
    key: "4ej97u"
}], ["path", {
    d: "m21 21-4.3-4.3",
    key: "1qie3q"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Du = st("Settings", [["path", {
    d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
    key: "1qme2f"
}], ["circle", {
    cx: "12",
    cy: "12",
    r: "3",
    key: "1v7zrd"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ua = st("ShoppingCart", [["circle", {
    cx: "8",
    cy: "21",
    r: "1",
    key: "jimo8o"
}], ["circle", {
    cx: "19",
    cy: "21",
    r: "1",
    key: "13723u"
}], ["path", {
    d: "M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12",
    key: "9zh506"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ua = st("Trash2", [["path", {
    d: "M3 6h18",
    key: "d0wm0j"
}], ["path", {
    d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6",
    key: "4alrt4"
}], ["path", {
    d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2",
    key: "v07s0e"
}], ["line", {
    x1: "10",
    x2: "10",
    y1: "11",
    y2: "17",
    key: "1uufr5"
}], ["line", {
    x1: "14",
    x2: "14",
    y1: "11",
    y2: "17",
    key: "xtxkd"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const dm = st("X", [["path", {
    d: "M18 6 6 18",
    key: "1bl5f8"
}], ["path", {
    d: "m6 6 12 12",
    key: "d8bk6v"
}]]);
function hm(t) {
    var e, r, n = "";
    if (typeof t == "string" || typeof t == "number")
        n += t;
    else if (typeof t == "object")
        if (Array.isArray(t)) {
            var s = t.length;
            for (e = 0; e < s; e++)
                t[e] && (r = hm(t[e])) && (n && (n += " "),
                n += r)
        } else
            for (r in t)
                t[r] && (n && (n += " "),
                n += r);
    return n
}
function fm() {
    for (var t, e, r = 0, n = "", s = arguments.length; r < s; r++)
        (t = arguments[r]) && (e = hm(t)) && (n && (n += " "),
        n += e);
    return n
}
const Gh = t => typeof t == "boolean" ? `${t}` : t === 0 ? "0" : t
  , Vh = fm
  , Fb = (t, e) => r => {
    var n;
    if ((e == null ? void 0 : e.variants) == null)
        return Vh(t, r == null ? void 0 : r.class, r == null ? void 0 : r.className);
    const {variants: s, defaultVariants: i} = e
      , o = Object.keys(s).map(c => {
        const d = r == null ? void 0 : r[c]
          , h = i == null ? void 0 : i[c];
        if (d === null)
            return null;
        const f = Gh(d) || Gh(h);
        return s[c][f]
    }
    )
      , a = r && Object.entries(r).reduce( (c, d) => {
        let[h,f] = d;
        return f === void 0 || (c[h] = f),
        c
    }
    , {})
      , l = e == null || (n = e.compoundVariants) === null || n === void 0 ? void 0 : n.reduce( (c, d) => {
        let {class: h, className: f, ...p} = d;
        return Object.entries(p).every(v => {
            let[w,b] = v;
            return Array.isArray(b) ? b.includes({
                ...i,
                ...a
            }[w]) : {
                ...i,
                ...a
            }[w] === b
        }
        ) ? [...c, h, f] : c
    }
    , []);
    return Vh(t, o, l, r == null ? void 0 : r.class, r == null ? void 0 : r.className)
}
  , sd = "-"
  , Bb = t => {
    const e = Mb(t)
      , {conflictingClassGroups: r, conflictingClassGroupModifiers: n} = t;
    return {
        getClassGroupId: o => {
            const a = o.split(sd);
            return a[0] === "" && a.length !== 1 && a.shift(),
            pm(a, e) || zb(o)
        }
        ,
        getConflictingClassGroupIds: (o, a) => {
            const l = r[o] || [];
            return a && n[o] ? [...l, ...n[o]] : l
        }
    }
}
  , pm = (t, e) => {
    var o;
    if (t.length === 0)
        return e.classGroupId;
    const r = t[0]
      , n = e.nextPart.get(r)
      , s = n ? pm(t.slice(1), n) : void 0;
    if (s)
        return s;
    if (e.validators.length === 0)
        return;
    const i = t.join(sd);
    return (o = e.validators.find( ({validator: a}) => a(i))) == null ? void 0 : o.classGroupId
}
  , Hh = /^\[(.+)\]$/
  , zb = t => {
    if (Hh.test(t)) {
        const e = Hh.exec(t)[1]
          , r = e == null ? void 0 : e.substring(0, e.indexOf(":"));
        if (r)
            return "arbitrary.." + r
    }
}
  , Mb = t => {
    const {theme: e, prefix: r} = t
      , n = {
        nextPart: new Map,
        validators: []
    };
    return Gb(Object.entries(t.classGroups), r).forEach( ([i,o]) => {
        $u(o, n, i, e)
    }
    ),
    n
}
  , $u = (t, e, r, n) => {
    t.forEach(s => {
        if (typeof s == "string") {
            const i = s === "" ? e : qh(e, s);
            i.classGroupId = r;
            return
        }
        if (typeof s == "function") {
            if (Wb(s)) {
                $u(s(n), e, r, n);
                return
            }
            e.validators.push({
                validator: s,
                classGroupId: r
            });
            return
        }
        Object.entries(s).forEach( ([i,o]) => {
            $u(o, qh(e, i), r, n)
        }
        )
    }
    )
}
  , qh = (t, e) => {
    let r = t;
    return e.split(sd).forEach(n => {
        r.nextPart.has(n) || r.nextPart.set(n, {
            nextPart: new Map,
            validators: []
        }),
        r = r.nextPart.get(n)
    }
    ),
    r
}
  , Wb = t => t.isThemeGetter
  , Gb = (t, e) => e ? t.map( ([r,n]) => {
    const s = n.map(i => typeof i == "string" ? e + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map( ([o,a]) => [e + o, a])) : i);
    return [r, s]
}
) : t
  , Vb = t => {
    if (t < 1)
        return {
            get: () => {}
            ,
            set: () => {}
        };
    let e = 0
      , r = new Map
      , n = new Map;
    const s = (i, o) => {
        r.set(i, o),
        e++,
        e > t && (e = 0,
        n = r,
        r = new Map)
    }
    ;
    return {
        get(i) {
            let o = r.get(i);
            if (o !== void 0)
                return o;
            if ((o = n.get(i)) !== void 0)
                return s(i, o),
                o
        },
        set(i, o) {
            r.has(i) ? r.set(i, o) : s(i, o)
        }
    }
}
  , gm = "!"
  , Hb = t => {
    const {separator: e, experimentalParseClassName: r} = t
      , n = e.length === 1
      , s = e[0]
      , i = e.length
      , o = a => {
        const l = [];
        let c = 0, d = 0, h;
        for (let b = 0; b < a.length; b++) {
            let g = a[b];
            if (c === 0) {
                if (g === s && (n || a.slice(b, b + i) === e)) {
                    l.push(a.slice(d, b)),
                    d = b + i;
                    continue
                }
                if (g === "/") {
                    h = b;
                    continue
                }
            }
            g === "[" ? c++ : g === "]" && c--
        }
        const f = l.length === 0 ? a : a.substring(d)
          , p = f.startsWith(gm)
          , v = p ? f.substring(1) : f
          , w = h && h > d ? h - d : void 0;
        return {
            modifiers: l,
            hasImportantModifier: p,
            baseClassName: v,
            maybePostfixModifierPosition: w
        }
    }
    ;
    return r ? a => r({
        className: a,
        parseClassName: o
    }) : o
}
  , qb = t => {
    if (t.length <= 1)
        return t;
    const e = [];
    let r = [];
    return t.forEach(n => {
        n[0] === "[" ? (e.push(...r.sort(), n),
        r = []) : r.push(n)
    }
    ),
    e.push(...r.sort()),
    e
}
  , Kb = t => ({
    cache: Vb(t.cacheSize),
    parseClassName: Hb(t),
    ...Bb(t)
})
  , Qb = /\s+/
  , Jb = (t, e) => {
    const {parseClassName: r, getClassGroupId: n, getConflictingClassGroupIds: s} = e
      , i = []
      , o = t.trim().split(Qb);
    let a = "";
    for (let l = o.length - 1; l >= 0; l -= 1) {
        const c = o[l]
          , {modifiers: d, hasImportantModifier: h, baseClassName: f, maybePostfixModifierPosition: p} = r(c);
        let v = !!p
          , w = n(v ? f.substring(0, p) : f);
        if (!w) {
            if (!v) {
                a = c + (a.length > 0 ? " " + a : a);
                continue
            }
            if (w = n(f),
            !w) {
                a = c + (a.length > 0 ? " " + a : a);
                continue
            }
            v = !1
        }
        const b = qb(d).join(":")
          , g = h ? b + gm : b
          , m = g + w;
        if (i.includes(m))
            continue;
        i.push(m);
        const y = s(w, v);
        for (let x = 0; x < y.length; ++x) {
            const k = y[x];
            i.push(g + k)
        }
        a = c + (a.length > 0 ? " " + a : a)
    }
    return a
}
;
function Xb() {
    let t = 0, e, r, n = "";
    for (; t < arguments.length; )
        (e = arguments[t++]) && (r = mm(e)) && (n && (n += " "),
        n += r);
    return n
}
const mm = t => {
    if (typeof t == "string")
        return t;
    let e, r = "";
    for (let n = 0; n < t.length; n++)
        t[n] && (e = mm(t[n])) && (r && (r += " "),
        r += e);
    return r
}
;
function Yb(t, ...e) {
    let r, n, s, i = o;
    function o(l) {
        const c = e.reduce( (d, h) => h(d), t());
        return r = Kb(c),
        n = r.cache.get,
        s = r.cache.set,
        i = a,
        a(l)
    }
    function a(l) {
        const c = n(l);
        if (c)
            return c;
        const d = Jb(l, r);
        return s(l, d),
        d
    }
    return function() {
        return i(Xb.apply(null, arguments))
    }
}
const fe = t => {
    const e = r => r[t] || [];
    return e.isThemeGetter = !0,
    e
}
  , ym = /^\[(?:([a-z-]+):)?(.+)\]$/i
  , Zb = /^\d+\/\d+$/
  , ex = new Set(["px", "full", "screen"])
  , tx = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/
  , rx = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/
  , nx = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/
  , sx = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/
  , ix = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/
  , Yt = t => os(t) || ex.has(t) || Zb.test(t)
  , pr = t => Ns(t, "length", fx)
  , os = t => !!t && !Number.isNaN(Number(t))
  , _l = t => Ns(t, "number", os)
  , Hs = t => !!t && Number.isInteger(Number(t))
  , ox = t => t.endsWith("%") && os(t.slice(0, -1))
  , X = t => ym.test(t)
  , gr = t => tx.test(t)
  , ax = new Set(["length", "size", "percentage"])
  , lx = t => Ns(t, ax, vm)
  , ux = t => Ns(t, "position", vm)
  , cx = new Set(["image", "url"])
  , dx = t => Ns(t, cx, gx)
  , hx = t => Ns(t, "", px)
  , qs = () => !0
  , Ns = (t, e, r) => {
    const n = ym.exec(t);
    return n ? n[1] ? typeof e == "string" ? n[1] === e : e.has(n[1]) : r(n[2]) : !1
}
  , fx = t => rx.test(t) && !nx.test(t)
  , vm = () => !1
  , px = t => sx.test(t)
  , gx = t => ix.test(t)
  , mx = () => {
    const t = fe("colors")
      , e = fe("spacing")
      , r = fe("blur")
      , n = fe("brightness")
      , s = fe("borderColor")
      , i = fe("borderRadius")
      , o = fe("borderSpacing")
      , a = fe("borderWidth")
      , l = fe("contrast")
      , c = fe("grayscale")
      , d = fe("hueRotate")
      , h = fe("invert")
      , f = fe("gap")
      , p = fe("gradientColorStops")
      , v = fe("gradientColorStopPositions")
      , w = fe("inset")
      , b = fe("margin")
      , g = fe("opacity")
      , m = fe("padding")
      , y = fe("saturate")
      , x = fe("scale")
      , k = fe("sepia")
      , C = fe("skew")
      , T = fe("space")
      , I = fe("translate")
      , z = () => ["auto", "contain", "none"]
      , N = () => ["auto", "hidden", "clip", "visible", "scroll"]
      , Z = () => ["auto", X, e]
      , V = () => [X, e]
      , he = () => ["", Yt, pr]
      , Me = () => ["auto", os, X]
      , M = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"]
      , ne = () => ["solid", "dashed", "dotted", "double", "none"]
      , Le = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"]
      , S = () => ["start", "end", "center", "between", "around", "evenly", "stretch"]
      , R = () => ["", "0", X]
      , L = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"]
      , O = () => [os, X];
    return {
        cacheSize: 500,
        separator: ":",
        theme: {
            colors: [qs],
            spacing: [Yt, pr],
            blur: ["none", "", gr, X],
            brightness: O(),
            borderColor: [t],
            borderRadius: ["none", "", "full", gr, X],
            borderSpacing: V(),
            borderWidth: he(),
            contrast: O(),
            grayscale: R(),
            hueRotate: O(),
            invert: R(),
            gap: V(),
            gradientColorStops: [t],
            gradientColorStopPositions: [ox, pr],
            inset: Z(),
            margin: Z(),
            opacity: O(),
            padding: V(),
            saturate: O(),
            scale: O(),
            sepia: R(),
            skew: O(),
            space: V(),
            translate: V()
        },
        classGroups: {
            aspect: [{
                aspect: ["auto", "square", "video", X]
            }],
            container: ["container"],
            columns: [{
                columns: [gr]
            }],
            "break-after": [{
                "break-after": L()
            }],
            "break-before": [{
                "break-before": L()
            }],
            "break-inside": [{
                "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
            }],
            "box-decoration": [{
                "box-decoration": ["slice", "clone"]
            }],
            box: [{
                box: ["border", "content"]
            }],
            display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
            float: [{
                float: ["right", "left", "none", "start", "end"]
            }],
            clear: [{
                clear: ["left", "right", "both", "none", "start", "end"]
            }],
            isolation: ["isolate", "isolation-auto"],
            "object-fit": [{
                object: ["contain", "cover", "fill", "none", "scale-down"]
            }],
            "object-position": [{
                object: [...M(), X]
            }],
            overflow: [{
                overflow: N()
            }],
            "overflow-x": [{
                "overflow-x": N()
            }],
            "overflow-y": [{
                "overflow-y": N()
            }],
            overscroll: [{
                overscroll: z()
            }],
            "overscroll-x": [{
                "overscroll-x": z()
            }],
            "overscroll-y": [{
                "overscroll-y": z()
            }],
            position: ["static", "fixed", "absolute", "relative", "sticky"],
            inset: [{
                inset: [w]
            }],
            "inset-x": [{
                "inset-x": [w]
            }],
            "inset-y": [{
                "inset-y": [w]
            }],
            start: [{
                start: [w]
            }],
            end: [{
                end: [w]
            }],
            top: [{
                top: [w]
            }],
            right: [{
                right: [w]
            }],
            bottom: [{
                bottom: [w]
            }],
            left: [{
                left: [w]
            }],
            visibility: ["visible", "invisible", "collapse"],
            z: [{
                z: ["auto", Hs, X]
            }],
            basis: [{
                basis: Z()
            }],
            "flex-direction": [{
                flex: ["row", "row-reverse", "col", "col-reverse"]
            }],
            "flex-wrap": [{
                flex: ["wrap", "wrap-reverse", "nowrap"]
            }],
            flex: [{
                flex: ["1", "auto", "initial", "none", X]
            }],
            grow: [{
                grow: R()
            }],
            shrink: [{
                shrink: R()
            }],
            order: [{
                order: ["first", "last", "none", Hs, X]
            }],
            "grid-cols": [{
                "grid-cols": [qs]
            }],
            "col-start-end": [{
                col: ["auto", {
                    span: ["full", Hs, X]
                }, X]
            }],
            "col-start": [{
                "col-start": Me()
            }],
            "col-end": [{
                "col-end": Me()
            }],
            "grid-rows": [{
                "grid-rows": [qs]
            }],
            "row-start-end": [{
                row: ["auto", {
                    span: [Hs, X]
                }, X]
            }],
            "row-start": [{
                "row-start": Me()
            }],
            "row-end": [{
                "row-end": Me()
            }],
            "grid-flow": [{
                "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
            }],
            "auto-cols": [{
                "auto-cols": ["auto", "min", "max", "fr", X]
            }],
            "auto-rows": [{
                "auto-rows": ["auto", "min", "max", "fr", X]
            }],
            gap: [{
                gap: [f]
            }],
            "gap-x": [{
                "gap-x": [f]
            }],
            "gap-y": [{
                "gap-y": [f]
            }],
            "justify-content": [{
                justify: ["normal", ...S()]
            }],
            "justify-items": [{
                "justify-items": ["start", "end", "center", "stretch"]
            }],
            "justify-self": [{
                "justify-self": ["auto", "start", "end", "center", "stretch"]
            }],
            "align-content": [{
                content: ["normal", ...S(), "baseline"]
            }],
            "align-items": [{
                items: ["start", "end", "center", "baseline", "stretch"]
            }],
            "align-self": [{
                self: ["auto", "start", "end", "center", "stretch", "baseline"]
            }],
            "place-content": [{
                "place-content": [...S(), "baseline"]
            }],
            "place-items": [{
                "place-items": ["start", "end", "center", "baseline", "stretch"]
            }],
            "place-self": [{
                "place-self": ["auto", "start", "end", "center", "stretch"]
            }],
            p: [{
                p: [m]
            }],
            px: [{
                px: [m]
            }],
            py: [{
                py: [m]
            }],
            ps: [{
                ps: [m]
            }],
            pe: [{
                pe: [m]
            }],
            pt: [{
                pt: [m]
            }],
            pr: [{
                pr: [m]
            }],
            pb: [{
                pb: [m]
            }],
            pl: [{
                pl: [m]
            }],
            m: [{
                m: [b]
            }],
            mx: [{
                mx: [b]
            }],
            my: [{
                my: [b]
            }],
            ms: [{
                ms: [b]
            }],
            me: [{
                me: [b]
            }],
            mt: [{
                mt: [b]
            }],
            mr: [{
                mr: [b]
            }],
            mb: [{
                mb: [b]
            }],
            ml: [{
                ml: [b]
            }],
            "space-x": [{
                "space-x": [T]
            }],
            "space-x-reverse": ["space-x-reverse"],
            "space-y": [{
                "space-y": [T]
            }],
            "space-y-reverse": ["space-y-reverse"],
            w: [{
                w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", X, e]
            }],
            "min-w": [{
                "min-w": [X, e, "min", "max", "fit"]
            }],
            "max-w": [{
                "max-w": [X, e, "none", "full", "min", "max", "fit", "prose", {
                    screen: [gr]
                }, gr]
            }],
            h: [{
                h: [X, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
            }],
            "min-h": [{
                "min-h": [X, e, "min", "max", "fit", "svh", "lvh", "dvh"]
            }],
            "max-h": [{
                "max-h": [X, e, "min", "max", "fit", "svh", "lvh", "dvh"]
            }],
            size: [{
                size: [X, e, "auto", "min", "max", "fit"]
            }],
            "font-size": [{
                text: ["base", gr, pr]
            }],
            "font-smoothing": ["antialiased", "subpixel-antialiased"],
            "font-style": ["italic", "not-italic"],
            "font-weight": [{
                font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", _l]
            }],
            "font-family": [{
                font: [qs]
            }],
            "fvn-normal": ["normal-nums"],
            "fvn-ordinal": ["ordinal"],
            "fvn-slashed-zero": ["slashed-zero"],
            "fvn-figure": ["lining-nums", "oldstyle-nums"],
            "fvn-spacing": ["proportional-nums", "tabular-nums"],
            "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
            tracking: [{
                tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", X]
            }],
            "line-clamp": [{
                "line-clamp": ["none", os, _l]
            }],
            leading: [{
                leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Yt, X]
            }],
            "list-image": [{
                "list-image": ["none", X]
            }],
            "list-style-type": [{
                list: ["none", "disc", "decimal", X]
            }],
            "list-style-position": [{
                list: ["inside", "outside"]
            }],
            "placeholder-color": [{
                placeholder: [t]
            }],
            "placeholder-opacity": [{
                "placeholder-opacity": [g]
            }],
            "text-alignment": [{
                text: ["left", "center", "right", "justify", "start", "end"]
            }],
            "text-color": [{
                text: [t]
            }],
            "text-opacity": [{
                "text-opacity": [g]
            }],
            "text-decoration": ["underline", "overline", "line-through", "no-underline"],
            "text-decoration-style": [{
                decoration: [...ne(), "wavy"]
            }],
            "text-decoration-thickness": [{
                decoration: ["auto", "from-font", Yt, pr]
            }],
            "underline-offset": [{
                "underline-offset": ["auto", Yt, X]
            }],
            "text-decoration-color": [{
                decoration: [t]
            }],
            "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
            "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
            "text-wrap": [{
                text: ["wrap", "nowrap", "balance", "pretty"]
            }],
            indent: [{
                indent: V()
            }],
            "vertical-align": [{
                align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", X]
            }],
            whitespace: [{
                whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
            }],
            break: [{
                break: ["normal", "words", "all", "keep"]
            }],
            hyphens: [{
                hyphens: ["none", "manual", "auto"]
            }],
            content: [{
                content: ["none", X]
            }],
            "bg-attachment": [{
                bg: ["fixed", "local", "scroll"]
            }],
            "bg-clip": [{
                "bg-clip": ["border", "padding", "content", "text"]
            }],
            "bg-opacity": [{
                "bg-opacity": [g]
            }],
            "bg-origin": [{
                "bg-origin": ["border", "padding", "content"]
            }],
            "bg-position": [{
                bg: [...M(), ux]
            }],
            "bg-repeat": [{
                bg: ["no-repeat", {
                    repeat: ["", "x", "y", "round", "space"]
                }]
            }],
            "bg-size": [{
                bg: ["auto", "cover", "contain", lx]
            }],
            "bg-image": [{
                bg: ["none", {
                    "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                }, dx]
            }],
            "bg-color": [{
                bg: [t]
            }],
            "gradient-from-pos": [{
                from: [v]
            }],
            "gradient-via-pos": [{
                via: [v]
            }],
            "gradient-to-pos": [{
                to: [v]
            }],
            "gradient-from": [{
                from: [p]
            }],
            "gradient-via": [{
                via: [p]
            }],
            "gradient-to": [{
                to: [p]
            }],
            rounded: [{
                rounded: [i]
            }],
            "rounded-s": [{
                "rounded-s": [i]
            }],
            "rounded-e": [{
                "rounded-e": [i]
            }],
            "rounded-t": [{
                "rounded-t": [i]
            }],
            "rounded-r": [{
                "rounded-r": [i]
            }],
            "rounded-b": [{
                "rounded-b": [i]
            }],
            "rounded-l": [{
                "rounded-l": [i]
            }],
            "rounded-ss": [{
                "rounded-ss": [i]
            }],
            "rounded-se": [{
                "rounded-se": [i]
            }],
            "rounded-ee": [{
                "rounded-ee": [i]
            }],
            "rounded-es": [{
                "rounded-es": [i]
            }],
            "rounded-tl": [{
                "rounded-tl": [i]
            }],
            "rounded-tr": [{
                "rounded-tr": [i]
            }],
            "rounded-br": [{
                "rounded-br": [i]
            }],
            "rounded-bl": [{
                "rounded-bl": [i]
            }],
            "border-w": [{
                border: [a]
            }],
            "border-w-x": [{
                "border-x": [a]
            }],
            "border-w-y": [{
                "border-y": [a]
            }],
            "border-w-s": [{
                "border-s": [a]
            }],
            "border-w-e": [{
                "border-e": [a]
            }],
            "border-w-t": [{
                "border-t": [a]
            }],
            "border-w-r": [{
                "border-r": [a]
            }],
            "border-w-b": [{
                "border-b": [a]
            }],
            "border-w-l": [{
                "border-l": [a]
            }],
            "border-opacity": [{
                "border-opacity": [g]
            }],
            "border-style": [{
                border: [...ne(), "hidden"]
            }],
            "divide-x": [{
                "divide-x": [a]
            }],
            "divide-x-reverse": ["divide-x-reverse"],
            "divide-y": [{
                "divide-y": [a]
            }],
            "divide-y-reverse": ["divide-y-reverse"],
            "divide-opacity": [{
                "divide-opacity": [g]
            }],
            "divide-style": [{
                divide: ne()
            }],
            "border-color": [{
                border: [s]
            }],
            "border-color-x": [{
                "border-x": [s]
            }],
            "border-color-y": [{
                "border-y": [s]
            }],
            "border-color-s": [{
                "border-s": [s]
            }],
            "border-color-e": [{
                "border-e": [s]
            }],
            "border-color-t": [{
                "border-t": [s]
            }],
            "border-color-r": [{
                "border-r": [s]
            }],
            "border-color-b": [{
                "border-b": [s]
            }],
            "border-color-l": [{
                "border-l": [s]
            }],
            "divide-color": [{
                divide: [s]
            }],
            "outline-style": [{
                outline: ["", ...ne()]
            }],
            "outline-offset": [{
                "outline-offset": [Yt, X]
            }],
            "outline-w": [{
                outline: [Yt, pr]
            }],
            "outline-color": [{
                outline: [t]
            }],
            "ring-w": [{
                ring: he()
            }],
            "ring-w-inset": ["ring-inset"],
            "ring-color": [{
                ring: [t]
            }],
            "ring-opacity": [{
                "ring-opacity": [g]
            }],
            "ring-offset-w": [{
                "ring-offset": [Yt, pr]
            }],
            "ring-offset-color": [{
                "ring-offset": [t]
            }],
            shadow: [{
                shadow: ["", "inner", "none", gr, hx]
            }],
            "shadow-color": [{
                shadow: [qs]
            }],
            opacity: [{
                opacity: [g]
            }],
            "mix-blend": [{
                "mix-blend": [...Le(), "plus-lighter", "plus-darker"]
            }],
            "bg-blend": [{
                "bg-blend": Le()
            }],
            filter: [{
                filter: ["", "none"]
            }],
            blur: [{
                blur: [r]
            }],
            brightness: [{
                brightness: [n]
            }],
            contrast: [{
                contrast: [l]
            }],
            "drop-shadow": [{
                "drop-shadow": ["", "none", gr, X]
            }],
            grayscale: [{
                grayscale: [c]
            }],
            "hue-rotate": [{
                "hue-rotate": [d]
            }],
            invert: [{
                invert: [h]
            }],
            saturate: [{
                saturate: [y]
            }],
            sepia: [{
                sepia: [k]
            }],
            "backdrop-filter": [{
                "backdrop-filter": ["", "none"]
            }],
            "backdrop-blur": [{
                "backdrop-blur": [r]
            }],
            "backdrop-brightness": [{
                "backdrop-brightness": [n]
            }],
            "backdrop-contrast": [{
                "backdrop-contrast": [l]
            }],
            "backdrop-grayscale": [{
                "backdrop-grayscale": [c]
            }],
            "backdrop-hue-rotate": [{
                "backdrop-hue-rotate": [d]
            }],
            "backdrop-invert": [{
                "backdrop-invert": [h]
            }],
            "backdrop-opacity": [{
                "backdrop-opacity": [g]
            }],
            "backdrop-saturate": [{
                "backdrop-saturate": [y]
            }],
            "backdrop-sepia": [{
                "backdrop-sepia": [k]
            }],
            "border-collapse": [{
                border: ["collapse", "separate"]
            }],
            "border-spacing": [{
                "border-spacing": [o]
            }],
            "border-spacing-x": [{
                "border-spacing-x": [o]
            }],
            "border-spacing-y": [{
                "border-spacing-y": [o]
            }],
            "table-layout": [{
                table: ["auto", "fixed"]
            }],
            caption: [{
                caption: ["top", "bottom"]
            }],
            transition: [{
                transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", X]
            }],
            duration: [{
                duration: O()
            }],
            ease: [{
                ease: ["linear", "in", "out", "in-out", X]
            }],
            delay: [{
                delay: O()
            }],
            animate: [{
                animate: ["none", "spin", "ping", "pulse", "bounce", X]
            }],
            transform: [{
                transform: ["", "gpu", "none"]
            }],
            scale: [{
                scale: [x]
            }],
            "scale-x": [{
                "scale-x": [x]
            }],
            "scale-y": [{
                "scale-y": [x]
            }],
            rotate: [{
                rotate: [Hs, X]
            }],
            "translate-x": [{
                "translate-x": [I]
            }],
            "translate-y": [{
                "translate-y": [I]
            }],
            "skew-x": [{
                "skew-x": [C]
            }],
            "skew-y": [{
                "skew-y": [C]
            }],
            "transform-origin": [{
                origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", X]
            }],
            accent: [{
                accent: ["auto", t]
            }],
            appearance: [{
                appearance: ["none", "auto"]
            }],
            cursor: [{
                cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", X]
            }],
            "caret-color": [{
                caret: [t]
            }],
            "pointer-events": [{
                "pointer-events": ["none", "auto"]
            }],
            resize: [{
                resize: ["none", "y", "x", ""]
            }],
            "scroll-behavior": [{
                scroll: ["auto", "smooth"]
            }],
            "scroll-m": [{
                "scroll-m": V()
            }],
            "scroll-mx": [{
                "scroll-mx": V()
            }],
            "scroll-my": [{
                "scroll-my": V()
            }],
            "scroll-ms": [{
                "scroll-ms": V()
            }],
            "scroll-me": [{
                "scroll-me": V()
            }],
            "scroll-mt": [{
                "scroll-mt": V()
            }],
            "scroll-mr": [{
                "scroll-mr": V()
            }],
            "scroll-mb": [{
                "scroll-mb": V()
            }],
            "scroll-ml": [{
                "scroll-ml": V()
            }],
            "scroll-p": [{
                "scroll-p": V()
            }],
            "scroll-px": [{
                "scroll-px": V()
            }],
            "scroll-py": [{
                "scroll-py": V()
            }],
            "scroll-ps": [{
                "scroll-ps": V()
            }],
            "scroll-pe": [{
                "scroll-pe": V()
            }],
            "scroll-pt": [{
                "scroll-pt": V()
            }],
            "scroll-pr": [{
                "scroll-pr": V()
            }],
            "scroll-pb": [{
                "scroll-pb": V()
            }],
            "scroll-pl": [{
                "scroll-pl": V()
            }],
            "snap-align": [{
                snap: ["start", "end", "center", "align-none"]
            }],
            "snap-stop": [{
                snap: ["normal", "always"]
            }],
            "snap-type": [{
                snap: ["none", "x", "y", "both"]
            }],
            "snap-strictness": [{
                snap: ["mandatory", "proximity"]
            }],
            touch: [{
                touch: ["auto", "none", "manipulation"]
            }],
            "touch-x": [{
                "touch-pan": ["x", "left", "right"]
            }],
            "touch-y": [{
                "touch-pan": ["y", "up", "down"]
            }],
            "touch-pz": ["touch-pinch-zoom"],
            select: [{
                select: ["none", "text", "all", "auto"]
            }],
            "will-change": [{
                "will-change": ["auto", "scroll", "contents", "transform", X]
            }],
            fill: [{
                fill: [t, "none"]
            }],
            "stroke-w": [{
                stroke: [Yt, pr, _l]
            }],
            stroke: [{
                stroke: [t, "none"]
            }],
            sr: ["sr-only", "not-sr-only"],
            "forced-color-adjust": [{
                "forced-color-adjust": ["auto", "none"]
            }]
        },
        conflictingClassGroups: {
            overflow: ["overflow-x", "overflow-y"],
            overscroll: ["overscroll-x", "overscroll-y"],
            inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
            "inset-x": ["right", "left"],
            "inset-y": ["top", "bottom"],
            flex: ["basis", "grow", "shrink"],
            gap: ["gap-x", "gap-y"],
            p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
            px: ["pr", "pl"],
            py: ["pt", "pb"],
            m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
            mx: ["mr", "ml"],
            my: ["mt", "mb"],
            size: ["w", "h"],
            "font-size": ["leading"],
            "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
            "fvn-ordinal": ["fvn-normal"],
            "fvn-slashed-zero": ["fvn-normal"],
            "fvn-figure": ["fvn-normal"],
            "fvn-spacing": ["fvn-normal"],
            "fvn-fraction": ["fvn-normal"],
            "line-clamp": ["display", "overflow"],
            rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
            "rounded-s": ["rounded-ss", "rounded-es"],
            "rounded-e": ["rounded-se", "rounded-ee"],
            "rounded-t": ["rounded-tl", "rounded-tr"],
            "rounded-r": ["rounded-tr", "rounded-br"],
            "rounded-b": ["rounded-br", "rounded-bl"],
            "rounded-l": ["rounded-tl", "rounded-bl"],
            "border-spacing": ["border-spacing-x", "border-spacing-y"],
            "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
            "border-w-x": ["border-w-r", "border-w-l"],
            "border-w-y": ["border-w-t", "border-w-b"],
            "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
            "border-color-x": ["border-color-r", "border-color-l"],
            "border-color-y": ["border-color-t", "border-color-b"],
            "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
            "scroll-mx": ["scroll-mr", "scroll-ml"],
            "scroll-my": ["scroll-mt", "scroll-mb"],
            "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
            "scroll-px": ["scroll-pr", "scroll-pl"],
            "scroll-py": ["scroll-pt", "scroll-pb"],
            touch: ["touch-x", "touch-y", "touch-pz"],
            "touch-x": ["touch"],
            "touch-y": ["touch"],
            "touch-pz": ["touch"]
        },
        conflictingClassGroupModifiers: {
            "font-size": ["leading"]
        }
    }
}
  , yx = Yb(mx);
function Kr(...t) {
    return yx(fm(t))
}
const vx = Fb("inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50", {
    variants: {
        variant: {
            default: "bg-primary text-primary-foreground hover:bg-primary/90",
            destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
            outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
            secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
            ghost: "hover:bg-accent hover:text-accent-foreground",
            link: "text-primary underline-offset-4 hover:underline"
        },
        size: {
            default: "h-10 px-4 py-2",
            sm: "h-9 rounded-md px-3",
            lg: "h-11 rounded-md px-8",
            icon: "h-10 w-10"
        }
    },
    defaultVariants: {
        variant: "default",
        size: "default"
    }
})
  , se = j.forwardRef( ({className: t, variant: e, size: r, ...n}, s) => u.jsx("button", {
    className: Kr(vx({
        variant: e,
        size: r,
        className: t
    })),
    ref: s,
    ...n
}));
se.displayName = "Button";
const ve = j.forwardRef( ({className: t, ...e}, r) => u.jsx("div", {
    ref: r,
    className: Kr("rounded-lg border border-border bg-card text-card-foreground shadow-sm", t),
    ...e
}));
ve.displayName = "Card";
const Ze = j.forwardRef( ({className: t, ...e}, r) => u.jsx("div", {
    ref: r,
    className: Kr("flex flex-col space-y-1.5 p-6", t),
    ...e
}));
Ze.displayName = "CardHeader";
const et = j.forwardRef( ({className: t, ...e}, r) => u.jsx("h2", {
    ref: r,
    className: Kr("text-2xl font-semibold leading-none tracking-tight", t),
    ...e
}));
et.displayName = "CardTitle";
const Mr = j.forwardRef( ({className: t, ...e}, r) => u.jsx("p", {
    ref: r,
    className: Kr("text-sm text-muted-foreground", t),
    ...e
}));
Mr.displayName = "CardDescription";
const we = j.forwardRef( ({className: t, ...e}, r) => u.jsx("div", {
    ref: r,
    className: Kr("p-6 pt-0", t),
    ...e
}));
we.displayName = "CardContent";
const wx = j.forwardRef( ({className: t, ...e}, r) => u.jsx("div", {
    ref: r,
    className: Kr("flex items-center p-6 pt-0", t),
    ...e
}));
wx.displayName = "CardFooter";
function bx() {
    const [t,e] = j.useState({
        datagodEnabled: !0,
        fastnetEnabled: !0,
        afaEnabled: !0,
        whatsappLink: "",
        afaLink: ""
    })
      , [r,n] = j.useState(!1)
      , [,s] = Rn();
    j.useEffect( () => {
        i();
        const l = () => i();
        return window.addEventListener("focus", l),
        () => window.removeEventListener("focus", l)
    }
    , []);
    const i = () => {
        try {
            const l = localStorage.getItem("wirenetSettings");
            if (l) {
                const c = JSON.parse(l);
                e(c)
            }
        } catch (l) {
            console.error("Error fetching settings:", l)
        }
    }
      , o = () => {
        t.whatsappLink && window.open(t.whatsappLink, "_blank")
    }
      , a = () => {
        t.afaLink ? window.open(t.afaLink, "_blank") : alert("Registration link not configured yet.")
    }
    ;
    return u.jsxs("div", {
        style: ae.body,
        children: [u.jsxs("header", {
            style: ae.header,
            children: [u.jsxs("div", {
                style: ae.headerContent,
                children: [u.jsx("h1", {
                    style: ae.h1,
                    children: "WireNet"
                }), u.jsx("div", {
                    style: ae.desktopMenu,
                    children: u.jsx(se, {
                        variant: "ghost",
                        onClick: () => s("/admin/login"),
                        children: "Admin"
                    })
                }), u.jsx("button", {
                    style: ae.mobileMenuButton,
                    onClick: () => n(!r),
                    children: r ? u.jsx(dm, {
                        size: 24
                    }) : u.jsx(um, {
                        size: 24
                    })
                })]
            }), r && u.jsx("div", {
                style: ae.mobileMenu,
                children: u.jsx(se, {
                    variant: "ghost",
                    style: ae.mobileMenuButton,
                    onClick: () => {
                        s("/admin/login"),
                        n(!1)
                    }
                    ,
                    children: "Admin"
                })
            })]
        }), u.jsxs("main", {
            style: ae.main,
            children: [u.jsxs("div", {
                style: ae.heroSection,
                children: [u.jsx("h2", {
                    style: ae.heroTitle,
                    children: "All-in-One Data & Internet Solutions"
                }), u.jsx("p", {
                    style: ae.heroSubtitle,
                    children: "Choose from our premium categories for the best deals and fastest service"
                })]
            }), u.jsxs("div", {
                style: ae.categoriesGrid,
                children: [t.datagodEnabled && u.jsxs(ve, {
                    style: ae.categoryCard,
                    children: [u.jsxs(Ze, {
                        children: [u.jsx(et, {
                            style: ae.categoryTitle,
                            children: " DataGod"
                        }), u.jsx(Mr, {
                            children: "Very cheaper or dealership prices"
                        })]
                    }), u.jsxs(we, {
                        children: [u.jsx("p", {
                            style: ae.categoryDescription,
                            children: "Get the best wholesale prices with 24-hour delivery. Perfect for bulk purchases and resellers."
                        }), u.jsx(se, {
                            style: ae.shopButton,
                            onClick: () => s("/datagod"),
                            children: "Shop DataGod"
                        })]
                    })]
                }), t.fastnetEnabled && u.jsxs(ve, {
                    style: ae.categoryCard,
                    children: [u.jsxs(Ze, {
                        children: [u.jsx(et, {
                            style: ae.categoryTitle,
                            children: " FastNet"
                        }), u.jsx(Mr, {
                            children: "Nice or normal prices with super fast delivery"
                        })]
                    }), u.jsxs(we, {
                        children: [u.jsx("p", {
                            style: ae.categoryDescription,
                            children: "Get your data in 5-20 minutes! Premium service with competitive pricing for instant needs."
                        }), u.jsx(se, {
                            style: ae.shopButton,
                            onClick: () => s("/fastnet"),
                            children: "Shop FastNet"
                        })]
                    })]
                }), t.afaEnabled && u.jsxs(ve, {
                    style: ae.categoryCard,
                    children: [u.jsxs(Ze, {
                        children: [u.jsx(et, {
                            style: {
                                ...ae.categoryTitle,
                                color: "#6b21a8"
                            },
                            children: " MTN AFA Registration"
                        }), u.jsx(Mr, {
                            children: "Cheaper calls & free network calls"
                        })]
                    }), u.jsxs(we, {
                        children: [u.jsx("p", {
                            style: ae.categoryDescription,
                            children: "Registration and verification takes 12-72 hours. Get access to cheaper call minutes and free calls to other registered numbers. Register yourself and loved ones today!"
                        }), u.jsx(se, {
                            style: {
                                ...ae.shopButton,
                                backgroundColor: "#6b21a8"
                            },
                            onClick: a,
                            children: "Register Now"
                        })]
                    })]
                })]
            }), !t.datagodEnabled && !t.fastnetEnabled && !t.afaEnabled && u.jsx(ve, {
                style: ae.emptyStateCard,
                children: u.jsx(we, {
                    style: ae.emptyStateContent,
                    children: u.jsx("p", {
                        style: ae.emptyStateText,
                        children: "No categories are currently available. Please check back soon!"
                    })
                })
            })]
        }), t.whatsappLink && u.jsx("button", {
            onClick: o,
            style: ae.whatsappButton,
            title: "Chat on WhatsApp",
            children: u.jsx(nd, {
                size: 24
            })
        })]
    })
}
const ae = {
    body: {
        fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
        margin: 0,
        padding: 0,
        backgroundColor: "#f4f4f9",
        color: "#333"
    },
    header: {
        backgroundColor: "white",
        boxShadow: "0 1px 3px rgba(0, 0, 0, 0.1)",
        position: "sticky",
        top: 0,
        zIndex: 40
    },
    headerContent: {
        maxWidth: "1200px",
        margin: "0 auto",
        padding: "16px 20px",
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center"
    },
    h1: {
        fontSize: "1.5em",
        fontWeight: "bold",
        color: "#1a1a1a",
        margin: 0
    },
    desktopMenu: {
        display: "flex",
        gap: "16px"
    },
    mobileMenuButton: {
        display: "none",
        background: "none",
        border: "none",
        cursor: "pointer",
        "@media (max-width: 768px)": {
            display: "block"
        }
    },
    mobileMenu: {
        display: "none",
        backgroundColor: "white",
        borderTop: "1px solid #ddd",
        padding: "8px 16px",
        "@media (max-width: 768px)": {
            display: "block"
        }
    },
    main: {
        maxWidth: "1200px",
        margin: "0 auto",
        padding: "48px 20px"
    },
    heroSection: {
        textAlign: "center",
        marginBottom: "48px"
    },
    heroTitle: {
        fontSize: "2.25em",
        fontWeight: "bold",
        color: "#1a1a1a",
        marginBottom: "16px"
    },
    heroSubtitle: {
        fontSize: "1.125em",
        color: "#666"
    },
    categoriesGrid: {
        display: "grid",
        gridTemplateColumns: "repeat(auto-fit, minmax(300px, 1fr))",
        gap: "32px",
        marginBottom: "48px"
    },
    categoryCard: {
        borderRadius: "8px",
        boxShadow: "0 1px 3px rgba(0, 0, 0, 0.1)",
        transition: "box-shadow 0.3s",
        cursor: "pointer",
        display: "flex",
        flexDirection: "column",
        height: "100%"
    },
    categoryTitle: {
        fontSize: "1.5em"
    },
    categoryDescription: {
        color: "#666",
        marginBottom: "16px",
        flexGrow: 1
    },
    shopButton: {
        width: "100%",
        padding: "12px",
        backgroundColor: "#007bff",
        color: "white",
        border: "none",
        borderRadius: "5px",
        cursor: "pointer",
        fontWeight: "bold"
    },
    emptyStateCard: {
        textAlign: "center",
        padding: "48px 20px"
    },
    emptyStateContent: {
        padding: "20px"
    },
    emptyStateText: {
        color: "#666"
    },
    whatsappButton: {
        position: "fixed",
        bottom: "24px",
        right: "24px",
        backgroundColor: "#25D366",
        color: "white",
        border: "none",
        borderRadius: "50%",
        width: "56px",
        height: "56px",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        cursor: "pointer",
        boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
        transition: "transform 0.3s",
        zIndex: 50
    }
}
  , Ie = j.forwardRef( ({className: t, type: e, ...r}, n) => u.jsx("input", {
    type: e,
    className: Kr("flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", t),
    ref: n,
    ...r
}));
Ie.displayName = "Input";
function xx() {
    const [,t] = Rn()
      , [e,r] = j.useState("")
      , [n,s] = j.useState({
        datagodEnabled: !0,
        fastnetEnabled: !0,
        afaEnabled: !0,
        whatsappLink: "",
        afaLink: ""
    })
      , [i,o] = j.useState("")
      , [a,l] = j.useState("")
      , [c,d] = j.useState(!1)
      , [h,f] = j.useState("")
      , [p,v] = j.useState(!1);
    j.useEffect( () => {
        const k = sessionStorage.getItem("adminLoggedIn")
          , C = sessionStorage.getItem("adminEmail");
        if (!k || !C) {
            t("/admin/login");
            return
        }
        r(C),
        w()
    }
    , [t]);
    const w = () => {
        try {
            const k = localStorage.getItem("wirenetSettings");
            if (k) {
                const C = JSON.parse(k);
                s(C),
                o(C.whatsappLink || ""),
                l(C.afaLink || "")
            } else {
                const C = {
                    whatsappLink: "",
                    afaLink: "",
                    datagodEnabled: !0,
                    fastnetEnabled: !0,
                    afaEnabled: !0
                };
                localStorage.setItem("wirenetSettings", JSON.stringify(C)),
                s(C)
            }
        } catch (k) {
            console.error("Error loading settings:", k)
        }
    }
      , b = () => {
        const k = {
            ...n,
            datagodEnabled: !n.datagodEnabled
        };
        s(k),
        localStorage.setItem("wirenetSettings", JSON.stringify(k)),
        f(" DataGod toggle updated!"),
        setTimeout( () => f(""), 2e3)
    }
      , g = () => {
        const k = {
            ...n,
            fastnetEnabled: !n.fastnetEnabled
        };
        s(k),
        localStorage.setItem("wirenetSettings", JSON.stringify(k)),
        f(" FastNet toggle updated!"),
        setTimeout( () => f(""), 2e3)
    }
      , m = () => {
        const k = {
            ...n,
            afaEnabled: !n.afaEnabled
        };
        s(k),
        localStorage.setItem("wirenetSettings", JSON.stringify(k)),
        f(" AFA toggle updated!"),
        setTimeout( () => f(""), 2e3)
    }
      , y = async () => {
        d(!0),
        f("");
        try {
            const k = {
                whatsappLink: i,
                afaLink: a,
                datagodEnabled: n.datagodEnabled,
                fastnetEnabled: n.fastnetEnabled,
                afaEnabled: n.afaEnabled
            };
            localStorage.setItem("wirenetSettings", JSON.stringify(k)),
            s(k),
            f(" Settings saved successfully!"),
            setTimeout( () => f(""), 3e3)
        } catch (k) {
            f(" Failed to save settings"),
            console.error(k)
        } finally {
            d(!1)
        }
    }
      , x = () => {
        sessionStorage.removeItem("adminLoggedIn"),
        sessionStorage.removeItem("adminEmail"),
        t("/admin/login")
    }
    ;
    return u.jsxs("div", {
        className: "min-h-screen bg-gradient-to-br from-slate-50 to-slate-100",
        children: [u.jsxs("header", {
            className: "bg-white shadow-sm sticky top-0 z-40",
            children: [u.jsxs("div", {
                className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center",
                children: [u.jsx("h1", {
                    className: "text-2xl font-bold text-primary",
                    children: "WireNet Admin"
                }), u.jsxs("div", {
                    className: "hidden md:flex items-center gap-4",
                    children: [u.jsxs("span", {
                        className: "text-sm text-gray-600",
                        children: ["Welcome, ", e]
                    }), u.jsxs(se, {
                        variant: "outline",
                        size: "sm",
                        onClick: x,
                        children: [u.jsx(Wh, {
                            size: 16,
                            className: "mr-2"
                        }), "Logout"]
                    })]
                }), u.jsx("button", {
                    className: "md:hidden",
                    onClick: () => v(!p),
                    children: p ? u.jsx(dm, {
                        size: 24
                    }) : u.jsx(um, {
                        size: 24
                    })
                })]
            }), p && u.jsx("div", {
                className: "md:hidden bg-white border-t p-4",
                children: u.jsxs("div", {
                    className: "flex flex-col gap-4",
                    children: [u.jsxs("span", {
                        className: "text-sm text-gray-600",
                        children: ["Welcome, ", e]
                    }), u.jsxs(se, {
                        variant: "outline",
                        size: "sm",
                        onClick: x,
                        className: "w-full justify-start",
                        children: [u.jsx(Wh, {
                            size: 16,
                            className: "mr-2"
                        }), "Logout"]
                    })]
                })
            })]
        }), u.jsxs("main", {
            className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12",
            children: [h && u.jsx("div", {
                className: `mb-6 p-4 rounded ${h.includes("") ? "bg-green-50 text-green-700" : "bg-red-50 text-red-700"}`,
                children: h
            }), u.jsxs("div", {
                className: "grid md:grid-cols-3 gap-4 mb-8",
                children: [u.jsxs(se, {
                    variant: "outline",
                    className: "h-auto py-4 flex flex-col items-center gap-2",
                    onClick: () => t("/admin"),
                    children: [u.jsx(Du, {
                        size: 24
                    }), u.jsx("span", {
                        children: "Dashboard Home"
                    })]
                }), u.jsxs(se, {
                    variant: "outline",
                    className: "h-auto py-4 flex flex-col items-center gap-2 bg-yellow-50 hover:bg-yellow-100 border-yellow-200",
                    onClick: () => t("/admin/datagod"),
                    children: [u.jsx("span", {
                        className: "text-2xl",
                        children: ""
                    }), u.jsx("span", {
                        children: "DataGod Admin"
                    })]
                }), u.jsxs(se, {
                    variant: "outline",
                    className: "h-auto py-4 flex flex-col items-center gap-2 bg-blue-50 hover:bg-blue-100 border-blue-200",
                    onClick: () => t("/admin/fastnet"),
                    children: [u.jsx("span", {
                        className: "text-2xl",
                        children: ""
                    }), u.jsx("span", {
                        children: "FastNet Admin"
                    })]
                })]
            }), u.jsxs("div", {
                className: "grid md:grid-cols-2 gap-8",
                children: [u.jsxs(ve, {
                    children: [u.jsxs(Ze, {
                        children: [u.jsx(et, {
                            children: "Storefront Visibility"
                        }), u.jsx(Mr, {
                            children: "Toggle categories to show or hide them on the storefront"
                        })]
                    }), u.jsxs(we, {
                        className: "space-y-4",
                        children: [u.jsxs("div", {
                            className: "flex items-center justify-between p-4 border rounded bg-yellow-50/50",
                            children: [u.jsxs("div", {
                                children: [u.jsx("h3", {
                                    className: "font-semibold text-yellow-700",
                                    children: "DataGod"
                                }), u.jsx("p", {
                                    className: "text-sm text-gray-600",
                                    children: "Cheap prices, 24hr delivery"
                                }), u.jsxs("p", {
                                    className: "text-xs text-gray-500 mt-1",
                                    children: ["Status: ", n.datagodEnabled ? " Visible" : " Hidden"]
                                })]
                            }), u.jsx("button", {
                                onClick: b,
                                className: `relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${n.datagodEnabled ? "bg-green-500" : "bg-gray-300"}`,
                                children: u.jsx("span", {
                                    className: `inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${n.datagodEnabled ? "translate-x-6" : "translate-x-1"}`
                                })
                            })]
                        }), u.jsxs("div", {
                            className: "flex items-center justify-between p-4 border rounded bg-blue-50/50",
                            children: [u.jsxs("div", {
                                children: [u.jsx("h3", {
                                    className: "font-semibold text-blue-700",
                                    children: "FastNet"
                                }), u.jsx("p", {
                                    className: "text-sm text-gray-600",
                                    children: "Fast delivery (5-20 mins)"
                                }), u.jsxs("p", {
                                    className: "text-xs text-gray-500 mt-1",
                                    children: ["Status: ", n.fastnetEnabled ? " Visible" : " Hidden"]
                                })]
                            }), u.jsx("button", {
                                onClick: g,
                                className: `relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${n.fastnetEnabled ? "bg-green-500" : "bg-gray-300"}`,
                                children: u.jsx("span", {
                                    className: `inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${n.fastnetEnabled ? "translate-x-6" : "translate-x-1"}`
                                })
                            })]
                        }), u.jsxs("div", {
                            className: "flex items-center justify-between p-4 border rounded bg-purple-50/50",
                            children: [u.jsxs("div", {
                                children: [u.jsx("h3", {
                                    className: "font-semibold text-purple-700",
                                    children: "MTN AFA Registration"
                                }), u.jsx("p", {
                                    className: "text-sm text-gray-600",
                                    children: "Cheaper calls, free network calls"
                                }), u.jsxs("p", {
                                    className: "text-xs text-gray-500 mt-1",
                                    children: ["Status: ", n.afaEnabled ? " Visible" : " Hidden"]
                                })]
                            }), u.jsx("button", {
                                onClick: m,
                                className: `relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${n.afaEnabled ? "bg-green-500" : "bg-gray-300"}`,
                                children: u.jsx("span", {
                                    className: `inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${n.afaEnabled ? "translate-x-6" : "translate-x-1"}`
                                })
                            })]
                        })]
                    })]
                }), u.jsxs(ve, {
                    children: [u.jsxs(Ze, {
                        children: [u.jsxs(et, {
                            className: "flex items-center gap-2",
                            children: [u.jsx(Du, {
                                size: 20
                            }), "Platform Settings"]
                        }), u.jsx(Mr, {
                            children: "Configure external links and integrations"
                        })]
                    }), u.jsxs(we, {
                        className: "space-y-4",
                        children: [u.jsxs("div", {
                            className: "space-y-2",
                            children: [u.jsx("label", {
                                className: "text-sm font-medium",
                                children: "WhatsApp Link"
                            }), u.jsx(Ie, {
                                type: "url",
                                placeholder: "https://wa.link/...",
                                value: i,
                                onChange: k => o(k.target.value)
                            }), u.jsx("p", {
                                className: "text-xs text-gray-500",
                                children: "Link for the floating WhatsApp button"
                            })]
                        }), u.jsxs("div", {
                            className: "space-y-2",
                            children: [u.jsx("label", {
                                className: "text-sm font-medium",
                                children: "MTN AFA Registration Link"
                            }), u.jsx(Ie, {
                                type: "url",
                                placeholder: "https://forms.google.com/...",
                                value: a,
                                onChange: k => l(k.target.value)
                            }), u.jsx("p", {
                                className: "text-xs text-gray-500",
                                children: "External link for AFA registration form"
                            })]
                        }), u.jsx(se, {
                            onClick: y,
                            disabled: c,
                            className: "w-full",
                            children: c ? "Saving..." : "Save Settings"
                        })]
                    })]
                })]
            })]
        })]
    })
}
function _x() {
    const [t,e] = j.useState("")
      , [r,n] = j.useState("")
      , [s,i] = j.useState("")
      , [o,a] = j.useState(!1)
      , [,l] = Rn()
      , c = async d => {
        d.preventDefault(),
        i(""),
        a(!0);
        try {
            const h = await fetch("/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                credentials: "include",
                body: JSON.stringify({
                    email: t,
                    password: r
                })
            })
              , f = await h.json();
            h.ok ? (sessionStorage.setItem("adminEmail", t),
            sessionStorage.setItem("adminLoggedIn", "true"),
            l("/admin")) : i(f.message || "Invalid email or password")
        } catch (h) {
            i("An error occurred. Please try again."),
            console.error(h)
        } finally {
            a(!1)
        }
    }
    ;
    return u.jsx("div", {
        className: "min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 flex items-center justify-center p-4",
        children: u.jsxs(ve, {
            className: "w-full max-w-md",
            children: [u.jsxs(Ze, {
                children: [u.jsx(et, {
                    children: "WireNet Admin Login"
                }), u.jsx(Mr, {
                    children: "Enter your credentials to access the admin dashboard"
                })]
            }), u.jsx(we, {
                children: u.jsxs("form", {
                    onSubmit: c,
                    className: "space-y-4",
                    children: [s && u.jsx("div", {
                        className: "bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded",
                        children: s
                    }), u.jsxs("div", {
                        className: "space-y-2",
                        children: [u.jsx("label", {
                            className: "text-sm font-medium",
                            children: "Email"
                        }), u.jsx(Ie, {
                            type: "email",
                            placeholder: "Enter your email",
                            value: t,
                            onChange: d => e(d.target.value),
                            required: !0
                        })]
                    }), u.jsxs("div", {
                        className: "space-y-2",
                        children: [u.jsx("label", {
                            className: "text-sm font-medium",
                            children: "Password"
                        }), u.jsx(Ie, {
                            type: "password",
                            placeholder: "Enter your password",
                            value: r,
                            onChange: d => n(d.target.value),
                            required: !0
                        })]
                    }), u.jsx(se, {
                        type: "submit",
                        className: "w-full",
                        disabled: o,
                        children: o ? "Logging in..." : "Login"
                    })]
                })
            })]
        })
    })
}
function Sx() {
    const [,t] = Rn()
      , [e,r] = j.useState([])
      , [n,s] = j.useState({
        datagodEnabled: !0,
        fastnetEnabled: !0
    })
      , [i,o] = j.useState("")
      , [a,l] = j.useState(!0)
      , [c,d] = j.useState("")
      , [h,f] = j.useState(null)
      , [p,v] = j.useState([])
      , [w,b] = j.useState("")
      , [g,m] = j.useState(null)
      , [y,x] = j.useState(!1)
      , [k,C] = j.useState(!1)
      , [T,I] = j.useState(1.3);
    j.useEffect( () => {
        z(),
        Z(),
        N()
    }
    , []);
    const z = () => {
        try {
            const O = localStorage.getItem("wirenetSettings");
            if (O) {
                const W = JSON.parse(O);
                s(W),
                o(W.whatsappLink || "")
            }
        } catch (O) {
            console.error("Error fetching settings:", O)
        }
    }
      , N = () => {
        try {
            const O = localStorage.getItem("datagodSettings");
            if (O) {
                const W = JSON.parse(O);
                W.transactionCharge && I(parseFloat(W.transactionCharge))
            }
        } catch (O) {
            console.error("Error loading transaction settings:", O)
        }
    }
      , Z = () => {
        try {
            const O = localStorage.getItem("datagodPackages");
            if (O) {
                const ie = JSON.parse(O).filter(ue => ue.isEnabled).sort( (ue, We) => ue.dataValueGB - We.dataValueGB);
                r(ie)
            } else {
                const W = [{
                    id: "1",
                    packageName: "1GB",
                    dataValueGB: 1,
                    priceGHS: 2.5,
                    isEnabled: !0
                }, {
                    id: "2",
                    packageName: "2GB",
                    dataValueGB: 2,
                    priceGHS: 4.5,
                    isEnabled: !0
                }, {
                    id: "3",
                    packageName: "5GB",
                    dataValueGB: 5,
                    priceGHS: 10,
                    isEnabled: !0
                }, {
                    id: "4",
                    packageName: "10GB",
                    dataValueGB: 10,
                    priceGHS: 18,
                    isEnabled: !0
                }];
                localStorage.setItem("datagodPackages", JSON.stringify(W)),
                r(W.sort( (ie, ue) => ie.dataValueGB - ue.dataValueGB))
            }
            l(!1)
        } catch (O) {
            console.error("Error fetching packages:", O),
            l(!1)
        }
    }
      , V = () => {
        n.whatsappLink && window.open(n.whatsappLink, "_blank")
    }
      , he = async () => {
        if (!w) {
            alert("Please enter an order ID");
            return
        }
        x(!0);
        try {
            const O = localStorage.getItem("datagodOrders");
            if (O) {
                const ie = JSON.parse(O).find(ue => ue.shortId === w);
                ie ? m({
                    shortId: ie.shortId,
                    status: ie.status,
                    packageDetails: ie.packageDetails,
                    createdAt: new Date(ie.createdAt).toLocaleDateString()
                }) : (m(null),
                alert("Order not found"))
            }
        } catch (O) {
            console.error("Status check error:", O),
            m(null)
        } finally {
            x(!1)
        }
    }
      , Me = () => {
        if (!c || !h) {
            alert("Please enter phone number and select a package");
            return
        }
        const O = {
            id: Date.now().toString(),
            pkg: h,
            phoneNumber: c
        };
        v([...p, O]),
        d(""),
        f(null)
    }
      , M = O => {
        v(p.filter(W => W.id !== O))
    }
      , ne = async () => {
        if (p.length === 0) {
            alert("Cart is empty");
            return
        }
        const O = "pk_live_574b7f2d8e5798fcab3221d292ef5fa8d28c204e";
        C(!0);
        const W = p.reduce( (Ge, zt) => Ge + zt.pkg.priceGHS, 0)
          , ie = W * (T / 100)
          , ue = W + ie;
        window.PaystackPop.setup({
            key: O,
            email: "customer@wirenet.com",
            amount: Math.ceil(ue * 100),
            currency: "GHS",
            ref: `DG-BULK-${Date.now()}-${Math.floor(Math.random() * 1e3)}`,
            metadata: {
                custom_fields: [{
                    display_name: "Items Count",
                    variable_name: "items_count",
                    value: p.length.toString()
                }]
            },
            callback: Ge => {
                Le(Ge.reference)
            }
            ,
            onClose: () => {
                alert("Transaction cancelled"),
                C(!1)
            }
        }).openIframe()
    }
      , Le = async O => {
        try {
            const W = localStorage.getItem("datagodOrders") || "[]"
              , ie = JSON.parse(W)
              , ue = [];
            p.forEach( (We, Ge) => {
                const zt = {
                    id: `${Date.now()}-${Ge}`,
                    shortId: `${O}-${Ge + 1}`,
                    customerPhone: We.phoneNumber,
                    packageGB: We.pkg.dataValueGB,
                    packagePrice: We.pkg.priceGHS,
                    packageDetails: We.pkg.packageName,
                    status: "PAID",
                    createdAt: new Date
                };
                ue.push(zt)
            }
            ),
            localStorage.setItem("datagodOrders", JSON.stringify([...ie, ...ue])),
            alert(` Payment successful! ${p.length} orders created.`),
            v([])
        } catch (W) {
            console.error("Purchase error:", W),
            alert(" Error creating orders")
        } finally {
            C(!1)
        }
    }
      , S = p.reduce( (O, W) => O + W.pkg.priceGHS, 0)
      , R = S * (T / 100)
      , L = S + R;
    return u.jsxs("div", {
        style: K.body,
        children: [u.jsxs("div", {
            style: K.header,
            children: [u.jsx("div", {
                style: K.headerTop,
                children: u.jsxs(se, {
                    variant: "ghost",
                    size: "sm",
                    onClick: () => t("/"),
                    style: {
                        marginBottom: "10px"
                    },
                    children: [u.jsx($a, {
                        size: 18,
                        style: {
                            marginRight: "8px"
                        }
                    }), "Back to WireNet"]
                })
            }), u.jsx("h1", {
                style: K.h1,
                children: "DataGod Vending Platform"
            }), u.jsx("p", {
                style: K.subtitle,
                children: "Cheapest Data Prices  24hr Delivery"
            })]
        }), u.jsxs("div", {
            style: K.contactBar,
            children: [" Contact: ", u.jsx("a", {
                href: "tel:+233XXXXXXXXX",
                style: K.contactLink,
                children: "+233 XXX XXX XXX"
            }), " |  WhatsApp: ", u.jsx("a", {
                href: "https://wa.me/233XXXXXXXXX",
                style: K.contactLink,
                children: "Chat with us"
            })]
        }), u.jsxs("main", {
            style: K.main,
            children: [u.jsxs("div", {
                style: K.statusChecker,
                children: [u.jsx("h2", {
                    style: K.statusCheckerH2,
                    children: "Check Order Status"
                }), u.jsxs("div", {
                    style: K.statusCheckerForm,
                    children: [u.jsx(Ie, {
                        type: "text",
                        placeholder: "Enter Order ID",
                        value: w,
                        onChange: O => b(O.target.value),
                        style: K.input
                    }), u.jsx(se, {
                        onClick: he,
                        disabled: y,
                        style: K.statusButton,
                        children: y ? "Checking..." : "Check Status"
                    })]
                }), g && u.jsxs("div", {
                    style: K.statusReport,
                    children: [u.jsxs("p", {
                        children: [u.jsx("strong", {
                            children: "Order ID:"
                        }), " ", g.shortId]
                    }), u.jsxs("p", {
                        children: [u.jsx("strong", {
                            children: "Status:"
                        }), " ", g.status]
                    }), u.jsxs("p", {
                        children: [u.jsx("strong", {
                            children: "Package:"
                        }), " ", g.packageDetails]
                    }), u.jsxs("p", {
                        children: [u.jsx("strong", {
                            children: "Date:"
                        }), " ", g.createdAt]
                    })]
                })]
            }), u.jsx("h2", {
                style: K.sectionTitle,
                children: "Available Packages"
            }), a ? u.jsx("p", {
                style: K.loading,
                children: "Loading packages..."
            }) : e.length === 0 ? u.jsx("p", {
                style: K.loading,
                children: "No packages available"
            }) : u.jsx("div", {
                style: K.packagesGrid,
                children: e.map(O => u.jsxs("div", {
                    onClick: () => f(O),
                    style: {
                        ...K.packageCard,
                        ...(h == null ? void 0 : h.id) === O.id ? K.packageCardSelected : {}
                    },
                    children: [u.jsx("p", {
                        style: K.packageCardName,
                        children: O.packageName
                    }), u.jsxs("p", {
                        style: K.packageCardPrice,
                        children: ["GH", O.priceGHS]
                    })]
                }, O.id))
            }), u.jsx("h2", {
                style: K.sectionTitle,
                children: "Purchase Data"
            }), u.jsxs("div", {
                style: K.purchaseSection,
                children: [u.jsxs("div", {
                    style: K.purchaseCard,
                    children: [u.jsx("h3", {
                        children: "Phone Number"
                    }), u.jsx(Ie, {
                        type: "tel",
                        placeholder: "Enter MTN number",
                        value: c,
                        onChange: O => d(O.target.value),
                        style: K.input
                    })]
                }), u.jsxs("div", {
                    style: K.purchaseCard,
                    children: [u.jsx("h3", {
                        children: "Selected Package"
                    }), h ? u.jsxs("div", {
                        style: K.selectedPackageInfo,
                        children: [u.jsx("p", {
                            style: K.packageName,
                            children: h.packageName
                        }), u.jsxs("p", {
                            style: K.packagePrice,
                            children: ["GH", h.priceGHS]
                        })]
                    }) : u.jsx("p", {
                        style: K.noSelection,
                        children: "Select a package above"
                    })]
                }), u.jsxs("div", {
                    style: K.purchaseCard,
                    children: [u.jsx("h3", {
                        children: "Add to Cart"
                    }), u.jsx(se, {
                        onClick: Me,
                        disabled: !c || !h,
                        style: {
                            ...K.buyButton,
                            opacity: !c || !h ? .5 : 1
                        },
                        children: "Add More +"
                    })]
                })]
            }), p.length > 0 && u.jsxs("div", {
                style: K.cartSection,
                children: [u.jsxs("h2", {
                    style: K.sectionTitle,
                    children: [u.jsx(ua, {
                        size: 24,
                        style: {
                            marginRight: "10px",
                            verticalAlign: "middle"
                        }
                    }), "Your Cart (", p.length, ")"]
                }), u.jsx("div", {
                    style: K.cartList,
                    children: p.map(O => u.jsxs("div", {
                        style: K.cartItem,
                        children: [u.jsxs("div", {
                            children: [u.jsx("p", {
                                style: K.cartItemPhone,
                                children: O.phoneNumber
                            }), u.jsxs("p", {
                                style: K.cartItemPkg,
                                children: [O.pkg.packageName, " - GH", O.pkg.priceGHS]
                            })]
                        }), u.jsx("button", {
                            onClick: () => M(O.id),
                            style: K.removeButton,
                            children: u.jsx(Ua, {
                                size: 18
                            })
                        })]
                    }, O.id))
                }), u.jsxs("div", {
                    style: K.cartSummary,
                    children: [u.jsxs("div", {
                        style: K.summaryRow,
                        children: [u.jsx("span", {
                            children: "Subtotal:"
                        }), u.jsxs("span", {
                            children: ["GH", S.toFixed(2)]
                        })]
                    }), u.jsxs("div", {
                        style: K.summaryRow,
                        children: [u.jsxs("span", {
                            children: ["Fee (", T, "%):"]
                        }), u.jsxs("span", {
                            children: ["GH", R.toFixed(2)]
                        })]
                    }), u.jsxs("div", {
                        style: K.summaryTotal,
                        children: [u.jsx("span", {
                            children: "Total:"
                        }), u.jsxs("span", {
                            children: ["GH", L.toFixed(2)]
                        })]
                    }), u.jsx(se, {
                        onClick: ne,
                        disabled: k,
                        style: K.checkoutButton,
                        children: k ? "Processing..." : `Pay GH${L.toFixed(2)}`
                    })]
                })]
            })]
        }), n.whatsappLink && u.jsx("button", {
            onClick: V,
            style: K.whatsappButton,
            title: "Chat on WhatsApp",
            children: u.jsx(nd, {
                size: 24
            })
        })]
    })
}
const K = {
    body: {
        fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
        margin: 0,
        padding: 0,
        backgroundColor: "#f4f4f9",
        color: "#333"
    },
    header: {
        backgroundColor: "white",
        boxShadow: "0 4px 15px rgba(0, 0, 0, 0.1)",
        padding: "20px",
        textAlign: "center",
        borderBottom: "3px solid #ffcc00"
    },
    headerTop: {
        textAlign: "left"
    },
    h1: {
        color: "#1a1a1a",
        marginBottom: "5px",
        fontSize: "2.5em"
    },
    subtitle: {
        color: "#666",
        fontSize: "1.1em"
    },
    contactBar: {
        backgroundColor: "#1a1a1a",
        color: "white",
        padding: "10px",
        textAlign: "center",
        borderRadius: "5px",
        margin: "20px"
    },
    contactLink: {
        color: "#ffcc00",
        textDecoration: "none",
        fontWeight: "bold"
    },
    main: {
        maxWidth: "1200px",
        margin: "0 auto",
        padding: "20px"
    },
    statusChecker: {
        backgroundColor: "#e9ecef",
        padding: "20px",
        borderRadius: "8px",
        marginBottom: "30px",
        textAlign: "center"
    },
    statusCheckerH2: {
        marginTop: 0,
        color: "#007bff"
    },
    statusCheckerForm: {
        display: "flex",
        justifyContent: "center",
        gap: "10px",
        flexWrap: "wrap"
    },
    input: {
        padding: "10px",
        border: "1px solid #ccc",
        borderRadius: "5px",
        width: "150px"
    },
    statusButton: {
        padding: "10px 20px",
        backgroundColor: "#007bff",
        color: "white",
        border: "none",
        borderRadius: "5px",
        cursor: "pointer"
    },
    statusReport: {
        marginTop: "15px",
        textAlign: "left",
        padding: "10px",
        backgroundColor: "#fff",
        borderRadius: "5px"
    },
    sectionTitle: {
        fontSize: "1.8em",
        marginTop: "30px",
        marginBottom: "20px",
        color: "#1a1a1a"
    },
    purchaseSection: {
        display: "grid",
        gridTemplateColumns: "repeat(auto-fit, minmax(250px, 1fr))",
        gap: "20px",
        marginBottom: "30px"
    },
    purchaseCard: {
        padding: "20px",
        backgroundColor: "#f9f9f9",
        borderRadius: "8px",
        border: "1px solid #ddd"
    },
    selectedPackageInfo: {
        textAlign: "center"
    },
    packageName: {
        fontSize: "2em",
        fontWeight: "bold",
        color: "#ffcc00",
        margin: "10px 0"
    },
    packagePrice: {
        fontSize: "1.5em",
        fontWeight: "bold",
        color: "#1a1a1a"
    },
    noSelection: {
        color: "#999",
        textAlign: "center"
    },
    buyButton: {
        width: "100%",
        padding: "12px",
        backgroundColor: "#ffcc00",
        color: "#1a1a1a",
        border: "none",
        borderRadius: "5px",
        cursor: "pointer",
        fontWeight: "bold",
        fontSize: "1.1em"
    },
    loading: {
        textAlign: "center",
        color: "#666"
    },
    packagesGrid: {
        display: "grid",
        gridTemplateColumns: "repeat(auto-fit, minmax(120px, 1fr))",
        gap: "15px",
        marginBottom: "30px"
    },
    packageCard: {
        padding: "20px",
        backgroundColor: "#fff",
        border: "2px solid #ddd",
        borderRadius: "8px",
        textAlign: "center",
        cursor: "pointer",
        transition: "all 0.3s"
    },
    packageCardSelected: {
        border: "2px solid #ffcc00",
        backgroundColor: "#fffbf0",
        boxShadow: "0 0 10px rgba(255, 204, 0, 0.3)"
    },
    packageCardName: {
        fontSize: "1.3em",
        fontWeight: "bold",
        color: "#ffcc00",
        margin: "10px 0"
    },
    packageCardPrice: {
        fontSize: "1.2em",
        fontWeight: "bold",
        color: "#1a1a1a"
    },
    whatsappButton: {
        position: "fixed",
        bottom: "24px",
        right: "24px",
        backgroundColor: "#25D366",
        color: "white",
        border: "none",
        borderRadius: "50%",
        width: "56px",
        height: "56px",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        cursor: "pointer",
        boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
        zIndex: 50
    },
    cartSection: {
        backgroundColor: "white",
        padding: "20px",
        borderRadius: "10px",
        boxShadow: "0 4px 15px rgba(0, 0, 0, 0.1)",
        marginTop: "30px"
    },
    cartList: {
        marginBottom: "20px"
    },
    cartItem: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        padding: "10px",
        borderBottom: "1px solid #eee"
    },
    cartItemPhone: {
        fontWeight: "bold",
        margin: 0
    },
    cartItemPkg: {
        color: "#666",
        margin: 0,
        fontSize: "0.9em"
    },
    removeButton: {
        background: "none",
        border: "none",
        color: "#dc3545",
        cursor: "pointer"
    },
    cartSummary: {
        borderTop: "2px solid #eee",
        paddingTop: "15px"
    },
    summaryRow: {
        display: "flex",
        justifyContent: "space-between",
        marginBottom: "5px",
        color: "#666"
    },
    summaryTotal: {
        display: "flex",
        justifyContent: "space-between",
        marginTop: "10px",
        marginBottom: "20px",
        fontSize: "1.2em",
        fontWeight: "bold",
        color: "#1a1a1a"
    },
    checkoutButton: {
        width: "100%",
        padding: "15px",
        backgroundColor: "#28a745",
        color: "white",
        border: "none",
        borderRadius: "5px",
        cursor: "pointer",
        fontWeight: "bold",
        fontSize: "1.2em"
    }
};
var id = {}
  , ca = {}
  , Uu = function(t, e) {
    return Uu = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(r, n) {
        r.__proto__ = n
    }
    || function(r, n) {
        for (var s in n)
            Object.prototype.hasOwnProperty.call(n, s) && (r[s] = n[s])
    }
    ,
    Uu(t, e)
};
function wm(t, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    Uu(t, e);
    function r() {
        this.constructor = t
    }
    t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype,
    new r)
}
var da = function() {
    return da = Object.assign || function(e) {
        for (var r, n = 1, s = arguments.length; n < s; n++) {
            r = arguments[n];
            for (var i in r)
                Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
        }
        return e
    }
    ,
    da.apply(this, arguments)
};
function Ls(t, e) {
    var r = {};
    for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var s = 0, n = Object.getOwnPropertySymbols(t); s < n.length; s++)
            e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (r[n[s]] = t[n[s]]);
    return r
}
function bm(t, e, r, n) {
    var s = arguments.length, i = s < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, r) : n, o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        i = Reflect.decorate(t, e, r, n);
    else
        for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) && (i = (s < 3 ? o(i) : s > 3 ? o(e, r, i) : o(e, r)) || i);
    return s > 3 && i && Object.defineProperty(e, r, i),
    i
}
function xm(t, e) {
    return function(r, n) {
        e(r, n, t)
    }
}
function _m(t, e, r, n, s, i) {
    function o(g) {
        if (g !== void 0 && typeof g != "function")
            throw new TypeError("Function expected");
        return g
    }
    for (var a = n.kind, l = a === "getter" ? "get" : a === "setter" ? "set" : "value", c = !e && t ? n.static ? t : t.prototype : null, d = e || (c ? Object.getOwnPropertyDescriptor(c, n.name) : {}), h, f = !1, p = r.length - 1; p >= 0; p--) {
        var v = {};
        for (var w in n)
            v[w] = w === "access" ? {} : n[w];
        for (var w in n.access)
            v.access[w] = n.access[w];
        v.addInitializer = function(g) {
            if (f)
                throw new TypeError("Cannot add initializers after decoration has completed");
            i.push(o(g || null))
        }
        ;
        var b = (0,
        r[p])(a === "accessor" ? {
            get: d.get,
            set: d.set
        } : d[l], v);
        if (a === "accessor") {
            if (b === void 0)
                continue;
            if (b === null || typeof b != "object")
                throw new TypeError("Object expected");
            (h = o(b.get)) && (d.get = h),
            (h = o(b.set)) && (d.set = h),
            (h = o(b.init)) && s.unshift(h)
        } else
            (h = o(b)) && (a === "field" ? s.unshift(h) : d[l] = h)
    }
    c && Object.defineProperty(c, n.name, d),
    f = !0
}
function Sm(t, e, r) {
    for (var n = arguments.length > 2, s = 0; s < e.length; s++)
        r = n ? e[s].call(t, r) : e[s].call(t);
    return n ? r : void 0
}
function km(t) {
    return typeof t == "symbol" ? t : "".concat(t)
}
function Em(t, e, r) {
    return typeof e == "symbol" && (e = e.description ? "[".concat(e.description, "]") : ""),
    Object.defineProperty(t, "name", {
        configurable: !0,
        value: r ? "".concat(r, " ", e) : e
    })
}
function Cm(t, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(t, e)
}
function F(t, e, r, n) {
    function s(i) {
        return i instanceof r ? i : new r(function(o) {
            o(i)
        }
        )
    }
    return new (r || (r = Promise))(function(i, o) {
        function a(d) {
            try {
                c(n.next(d))
            } catch (h) {
                o(h)
            }
        }
        function l(d) {
            try {
                c(n.throw(d))
            } catch (h) {
                o(h)
            }
        }
        function c(d) {
            d.done ? i(d.value) : s(d.value).then(a, l)
        }
        c((n = n.apply(t, e || [])).next())
    }
    )
}
function jm(t, e) {
    var r = {
        label: 0,
        sent: function() {
            if (i[0] & 1)
                throw i[1];
            return i[1]
        },
        trys: [],
        ops: []
    }, n, s, i, o = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
    return o.next = a(0),
    o.throw = a(1),
    o.return = a(2),
    typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }
    ),
    o;
    function a(c) {
        return function(d) {
            return l([c, d])
        }
    }
    function l(c) {
        if (n)
            throw new TypeError("Generator is already executing.");
        for (; o && (o = 0,
        c[0] && (r = 0)),
        r; )
            try {
                if (n = 1,
                s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s),
                0) : s.next) && !(i = i.call(s, c[1])).done)
                    return i;
                switch (s = 0,
                i && (c = [c[0] & 2, i.value]),
                c[0]) {
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return r.label++,
                    {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    r.label++,
                    s = c[1],
                    c = [0];
                    continue;
                case 7:
                    c = r.ops.pop(),
                    r.trys.pop();
                    continue;
                default:
                    if (i = r.trys,
                    !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        r = 0;
                        continue
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        r.label = c[1];
                        break
                    }
                    if (c[0] === 6 && r.label < i[1]) {
                        r.label = i[1],
                        i = c;
                        break
                    }
                    if (i && r.label < i[2]) {
                        r.label = i[2],
                        r.ops.push(c);
                        break
                    }
                    i[2] && r.ops.pop(),
                    r.trys.pop();
                    continue
                }
                c = e.call(t, r)
            } catch (d) {
                c = [6, d],
                s = 0
            } finally {
                n = i = 0
            }
        if (c[0] & 5)
            throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        }
    }
}
var Fa = Object.create ? function(t, e, r, n) {
    n === void 0 && (n = r);
    var s = Object.getOwnPropertyDescriptor(e, r);
    (!s || ("get"in s ? !e.__esModule : s.writable || s.configurable)) && (s = {
        enumerable: !0,
        get: function() {
            return e[r]
        }
    }),
    Object.defineProperty(t, n, s)
}
: function(t, e, r, n) {
    n === void 0 && (n = r),
    t[n] = e[r]
}
;
function Tm(t, e) {
    for (var r in t)
        r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && Fa(e, t, r)
}
function ha(t) {
    var e = typeof Symbol == "function" && Symbol.iterator
      , r = e && t[e]
      , n = 0;
    if (r)
        return r.call(t);
    if (t && typeof t.length == "number")
        return {
            next: function() {
                return t && n >= t.length && (t = void 0),
                {
                    value: t && t[n++],
                    done: !t
                }
            }
        };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function od(t, e) {
    var r = typeof Symbol == "function" && t[Symbol.iterator];
    if (!r)
        return t;
    var n = r.call(t), s, i = [], o;
    try {
        for (; (e === void 0 || e-- > 0) && !(s = n.next()).done; )
            i.push(s.value)
    } catch (a) {
        o = {
            error: a
        }
    } finally {
        try {
            s && !s.done && (r = n.return) && r.call(n)
        } finally {
            if (o)
                throw o.error
        }
    }
    return i
}
function Pm() {
    for (var t = [], e = 0; e < arguments.length; e++)
        t = t.concat(od(arguments[e]));
    return t
}
function Om() {
    for (var t = 0, e = 0, r = arguments.length; e < r; e++)
        t += arguments[e].length;
    for (var n = Array(t), s = 0, e = 0; e < r; e++)
        for (var i = arguments[e], o = 0, a = i.length; o < a; o++,
        s++)
            n[s] = i[o];
    return n
}
function Rm(t, e, r) {
    if (r || arguments.length === 2)
        for (var n = 0, s = e.length, i; n < s; n++)
            (i || !(n in e)) && (i || (i = Array.prototype.slice.call(e, 0, n)),
            i[n] = e[n]);
    return t.concat(i || Array.prototype.slice.call(e))
}
function Ps(t) {
    return this instanceof Ps ? (this.v = t,
    this) : new Ps(t)
}
function Am(t, e, r) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var n = r.apply(t, e || []), s, i = [];
    return s = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype),
    a("next"),
    a("throw"),
    a("return", o),
    s[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    s;
    function o(p) {
        return function(v) {
            return Promise.resolve(v).then(p, h)
        }
    }
    function a(p, v) {
        n[p] && (s[p] = function(w) {
            return new Promise(function(b, g) {
                i.push([p, w, b, g]) > 1 || l(p, w)
            }
            )
        }
        ,
        v && (s[p] = v(s[p])))
    }
    function l(p, v) {
        try {
            c(n[p](v))
        } catch (w) {
            f(i[0][3], w)
        }
    }
    function c(p) {
        p.value instanceof Ps ? Promise.resolve(p.value.v).then(d, h) : f(i[0][2], p)
    }
    function d(p) {
        l("next", p)
    }
    function h(p) {
        l("throw", p)
    }
    function f(p, v) {
        p(v),
        i.shift(),
        i.length && l(i[0][0], i[0][1])
    }
}
function Im(t) {
    var e, r;
    return e = {},
    n("next"),
    n("throw", function(s) {
        throw s
    }),
    n("return"),
    e[Symbol.iterator] = function() {
        return this
    }
    ,
    e;
    function n(s, i) {
        e[s] = t[s] ? function(o) {
            return (r = !r) ? {
                value: Ps(t[s](o)),
                done: !1
            } : i ? i(o) : o
        }
        : i
    }
}
function Nm(t) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = t[Symbol.asyncIterator], r;
    return e ? e.call(t) : (t = typeof ha == "function" ? ha(t) : t[Symbol.iterator](),
    r = {},
    n("next"),
    n("throw"),
    n("return"),
    r[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    r);
    function n(i) {
        r[i] = t[i] && function(o) {
            return new Promise(function(a, l) {
                o = t[i](o),
                s(a, l, o.done, o.value)
            }
            )
        }
    }
    function s(i, o, a, l) {
        Promise.resolve(l).then(function(c) {
            i({
                value: c,
                done: a
            })
        }, o)
    }
}
function Lm(t, e) {
    return Object.defineProperty ? Object.defineProperty(t, "raw", {
        value: e
    }) : t.raw = e,
    t
}
var kx = Object.create ? function(t, e) {
    Object.defineProperty(t, "default", {
        enumerable: !0,
        value: e
    })
}
: function(t, e) {
    t.default = e
}
  , Fu = function(t) {
    return Fu = Object.getOwnPropertyNames || function(e) {
        var r = [];
        for (var n in e)
            Object.prototype.hasOwnProperty.call(e, n) && (r[r.length] = n);
        return r
    }
    ,
    Fu(t)
};
function Dm(t) {
    if (t && t.__esModule)
        return t;
    var e = {};
    if (t != null)
        for (var r = Fu(t), n = 0; n < r.length; n++)
            r[n] !== "default" && Fa(e, t, r[n]);
    return kx(e, t),
    e
}
function $m(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
function Um(t, e, r, n) {
    if (r === "a" && !n)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !n : !e.has(t))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t)
}
function Fm(t, e, r, n, s) {
    if (n === "m")
        throw new TypeError("Private method is not writable");
    if (n === "a" && !s)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? t !== e || !s : !e.has(t))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return n === "a" ? s.call(t, r) : s ? s.value = r : e.set(t, r),
    r
}
function Bm(t, e) {
    if (e === null || typeof e != "object" && typeof e != "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof t == "function" ? e === t : t.has(e)
}
function zm(t, e, r) {
    if (e != null) {
        if (typeof e != "object" && typeof e != "function")
            throw new TypeError("Object expected.");
        var n, s;
        if (r) {
            if (!Symbol.asyncDispose)
                throw new TypeError("Symbol.asyncDispose is not defined.");
            n = e[Symbol.asyncDispose]
        }
        if (n === void 0) {
            if (!Symbol.dispose)
                throw new TypeError("Symbol.dispose is not defined.");
            n = e[Symbol.dispose],
            r && (s = n)
        }
        if (typeof n != "function")
            throw new TypeError("Object not disposable.");
        s && (n = function() {
            try {
                s.call(this)
            } catch (i) {
                return Promise.reject(i)
            }
        }
        ),
        t.stack.push({
            value: e,
            dispose: n,
            async: r
        })
    } else
        r && t.stack.push({
            async: !0
        });
    return e
}
var Ex = typeof SuppressedError == "function" ? SuppressedError : function(t, e, r) {
    var n = new Error(r);
    return n.name = "SuppressedError",
    n.error = t,
    n.suppressed = e,
    n
}
;
function Mm(t) {
    function e(i) {
        t.error = t.hasError ? new Ex(i,t.error,"An error was suppressed during disposal.") : i,
        t.hasError = !0
    }
    var r, n = 0;
    function s() {
        for (; r = t.stack.pop(); )
            try {
                if (!r.async && n === 1)
                    return n = 0,
                    t.stack.push(r),
                    Promise.resolve().then(s);
                if (r.dispose) {
                    var i = r.dispose.call(r.value);
                    if (r.async)
                        return n |= 2,
                        Promise.resolve(i).then(s, function(o) {
                            return e(o),
                            s()
                        })
                } else
                    n |= 1
            } catch (o) {
                e(o)
            }
        if (n === 1)
            return t.hasError ? Promise.reject(t.error) : Promise.resolve();
        if (t.hasError)
            throw t.error
    }
    return s()
}
function Wm(t, e) {
    return typeof t == "string" && /^\.\.?\//.test(t) ? t.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(r, n, s, i, o) {
        return n ? e ? ".jsx" : ".js" : s && (!i || !o) ? r : s + i + "." + o.toLowerCase() + "js"
    }) : t
}
const Cx = {
    __extends: wm,
    __assign: da,
    __rest: Ls,
    __decorate: bm,
    __param: xm,
    __esDecorate: _m,
    __runInitializers: Sm,
    __propKey: km,
    __setFunctionName: Em,
    __metadata: Cm,
    __awaiter: F,
    __generator: jm,
    __createBinding: Fa,
    __exportStar: Tm,
    __values: ha,
    __read: od,
    __spread: Pm,
    __spreadArrays: Om,
    __spreadArray: Rm,
    __await: Ps,
    __asyncGenerator: Am,
    __asyncDelegator: Im,
    __asyncValues: Nm,
    __makeTemplateObject: Lm,
    __importStar: Dm,
    __importDefault: $m,
    __classPrivateFieldGet: Um,
    __classPrivateFieldSet: Fm,
    __classPrivateFieldIn: Bm,
    __addDisposableResource: zm,
    __disposeResources: Mm,
    __rewriteRelativeImportExtension: Wm
}
  , jx = Object.freeze(Object.defineProperty({
    __proto__: null,
    __addDisposableResource: zm,
    get __assign() {
        return da
    },
    __asyncDelegator: Im,
    __asyncGenerator: Am,
    __asyncValues: Nm,
    __await: Ps,
    __awaiter: F,
    __classPrivateFieldGet: Um,
    __classPrivateFieldIn: Bm,
    __classPrivateFieldSet: Fm,
    __createBinding: Fa,
    __decorate: bm,
    __disposeResources: Mm,
    __esDecorate: _m,
    __exportStar: Tm,
    __extends: wm,
    __generator: jm,
    __importDefault: $m,
    __importStar: Dm,
    __makeTemplateObject: Lm,
    __metadata: Cm,
    __param: xm,
    __propKey: km,
    __read: od,
    __rest: Ls,
    __rewriteRelativeImportExtension: Wm,
    __runInitializers: Sm,
    __setFunctionName: Em,
    __spread: Pm,
    __spreadArray: Rm,
    __spreadArrays: Om,
    __values: ha,
    default: Cx
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Tx = t => t ? (...e) => t(...e) : (...e) => fetch(...e);
let Ba = class extends Error {
    constructor(e, r="FunctionsError", n) {
        super(e),
        this.name = r,
        this.context = n
    }
}
  , Gm = class extends Ba {
    constructor(e) {
        super("Failed to send a request to the Edge Function", "FunctionsFetchError", e)
    }
}
  , Bu = class extends Ba {
    constructor(e) {
        super("Relay Error invoking the Edge Function", "FunctionsRelayError", e)
    }
}
  , zu = class extends Ba {
    constructor(e) {
        super("Edge Function returned a non-2xx status code", "FunctionsHttpError", e)
    }
}
;
var fa;
(function(t) {
    t.Any = "any",
    t.ApNortheast1 = "ap-northeast-1",
    t.ApNortheast2 = "ap-northeast-2",
    t.ApSouth1 = "ap-south-1",
    t.ApSoutheast1 = "ap-southeast-1",
    t.ApSoutheast2 = "ap-southeast-2",
    t.CaCentral1 = "ca-central-1",
    t.EuCentral1 = "eu-central-1",
    t.EuWest1 = "eu-west-1",
    t.EuWest2 = "eu-west-2",
    t.EuWest3 = "eu-west-3",
    t.SaEast1 = "sa-east-1",
    t.UsEast1 = "us-east-1",
    t.UsWest1 = "us-west-1",
    t.UsWest2 = "us-west-2"
}
)(fa || (fa = {}));
class Px {
    constructor(e, {headers: r={}, customFetch: n, region: s=fa.Any}={}) {
        this.url = e,
        this.headers = r,
        this.region = s,
        this.fetch = Tx(n)
    }
    setAuth(e) {
        this.headers.Authorization = `Bearer ${e}`
    }
    invoke(e) {
        return F(this, arguments, void 0, function*(r, n={}) {
            var s;
            let i, o;
            try {
                const {headers: a, method: l, body: c, signal: d, timeout: h} = n;
                let f = {}
                  , {region: p} = n;
                p || (p = this.region);
                const v = new URL(`${this.url}/${r}`);
                p && p !== "any" && (f["x-region"] = p,
                v.searchParams.set("forceFunctionRegion", p));
                let w;
                c && (a && !Object.prototype.hasOwnProperty.call(a, "Content-Type") || !a) ? typeof Blob < "u" && c instanceof Blob || c instanceof ArrayBuffer ? (f["Content-Type"] = "application/octet-stream",
                w = c) : typeof c == "string" ? (f["Content-Type"] = "text/plain",
                w = c) : typeof FormData < "u" && c instanceof FormData ? w = c : (f["Content-Type"] = "application/json",
                w = JSON.stringify(c)) : w = c;
                let b = d;
                h && (o = new AbortController,
                i = setTimeout( () => o.abort(), h),
                d ? (b = o.signal,
                d.addEventListener("abort", () => o.abort())) : b = o.signal);
                const g = yield this.fetch(v.toString(), {
                    method: l || "POST",
                    headers: Object.assign(Object.assign(Object.assign({}, f), this.headers), a),
                    body: w,
                    signal: b
                }).catch(k => {
                    throw new Gm(k)
                }
                )
                  , m = g.headers.get("x-relay-error");
                if (m && m === "true")
                    throw new Bu(g);
                if (!g.ok)
                    throw new zu(g);
                let y = ((s = g.headers.get("Content-Type")) !== null && s !== void 0 ? s : "text/plain").split(";")[0].trim(), x;
                return y === "application/json" ? x = yield g.json() : y === "application/octet-stream" || y === "application/pdf" ? x = yield g.blob() : y === "text/event-stream" ? x = g : y === "multipart/form-data" ? x = yield g.formData() : x = yield g.text(),
                {
                    data: x,
                    error: null,
                    response: g
                }
            } catch (a) {
                return {
                    data: null,
                    error: a,
                    response: a instanceof zu || a instanceof Bu ? a.context : void 0
                }
            } finally {
                i && clearTimeout(i)
            }
        })
    }
}
const Ox = Object.freeze(Object.defineProperty({
    __proto__: null,
    get FunctionRegion() {
        return fa
    },
    FunctionsClient: Px,
    FunctionsError: Ba,
    FunctionsFetchError: Gm,
    FunctionsHttpError: zu,
    FunctionsRelayError: Bu
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Vm = Ui(Ox);
var Ke = {};
const Ds = Ui(jx);
var fo = {}, po = {}, go = {}, mo = {}, yo = {}, vo = {}, Kh;
function Hm() {
    if (Kh)
        return vo;
    Kh = 1,
    Object.defineProperty(vo, "__esModule", {
        value: !0
    });
    class t extends Error {
        constructor(r) {
            super(r.message),
            this.name = "PostgrestError",
            this.details = r.details,
            this.hint = r.hint,
            this.code = r.code
        }
    }
    return vo.default = t,
    vo
}
var Qh;
function qm() {
    if (Qh)
        return yo;
    Qh = 1,
    Object.defineProperty(yo, "__esModule", {
        value: !0
    });
    const e = Ds.__importDefault(Hm());
    let r = class {
        constructor(s) {
            var i, o;
            this.shouldThrowOnError = !1,
            this.method = s.method,
            this.url = s.url,
            this.headers = new Headers(s.headers),
            this.schema = s.schema,
            this.body = s.body,
            this.shouldThrowOnError = (i = s.shouldThrowOnError) !== null && i !== void 0 ? i : !1,
            this.signal = s.signal,
            this.isMaybeSingle = (o = s.isMaybeSingle) !== null && o !== void 0 ? o : !1,
            s.fetch ? this.fetch = s.fetch : this.fetch = fetch
        }
        throwOnError() {
            return this.shouldThrowOnError = !0,
            this
        }
        setHeader(s, i) {
            return this.headers = new Headers(this.headers),
            this.headers.set(s, i),
            this
        }
        then(s, i) {
            this.schema === void 0 || (["GET", "HEAD"].includes(this.method) ? this.headers.set("Accept-Profile", this.schema) : this.headers.set("Content-Profile", this.schema)),
            this.method !== "GET" && this.method !== "HEAD" && this.headers.set("Content-Type", "application/json");
            const o = this.fetch;
            let a = o(this.url.toString(), {
                method: this.method,
                headers: this.headers,
                body: JSON.stringify(this.body),
                signal: this.signal
            }).then(async l => {
                var c, d, h, f;
                let p = null
                  , v = null
                  , w = null
                  , b = l.status
                  , g = l.statusText;
                if (l.ok) {
                    if (this.method !== "HEAD") {
                        const k = await l.text();
                        k === "" || (this.headers.get("Accept") === "text/csv" || this.headers.get("Accept") && (!((c = this.headers.get("Accept")) === null || c === void 0) && c.includes("application/vnd.pgrst.plan+text")) ? v = k : v = JSON.parse(k))
                    }
                    const y = (d = this.headers.get("Prefer")) === null || d === void 0 ? void 0 : d.match(/count=(exact|planned|estimated)/)
                      , x = (h = l.headers.get("content-range")) === null || h === void 0 ? void 0 : h.split("/");
                    y && x && x.length > 1 && (w = parseInt(x[1])),
                    this.isMaybeSingle && this.method === "GET" && Array.isArray(v) && (v.length > 1 ? (p = {
                        code: "PGRST116",
                        details: `Results contain ${v.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                        hint: null,
                        message: "JSON object requested, multiple (or no) rows returned"
                    },
                    v = null,
                    w = null,
                    b = 406,
                    g = "Not Acceptable") : v.length === 1 ? v = v[0] : v = null)
                } else {
                    const y = await l.text();
                    try {
                        p = JSON.parse(y),
                        Array.isArray(p) && l.status === 404 && (v = [],
                        p = null,
                        b = 200,
                        g = "OK")
                    } catch {
                        l.status === 404 && y === "" ? (b = 204,
                        g = "No Content") : p = {
                            message: y
                        }
                    }
                    if (p && this.isMaybeSingle && (!((f = p == null ? void 0 : p.details) === null || f === void 0) && f.includes("0 rows")) && (p = null,
                    b = 200,
                    g = "OK"),
                    p && this.shouldThrowOnError)
                        throw new e.default(p)
                }
                return {
                    error: p,
                    data: v,
                    count: w,
                    status: b,
                    statusText: g
                }
            }
            );
            return this.shouldThrowOnError || (a = a.catch(l => {
                var c, d, h, f, p, v;
                let w = "";
                const b = l == null ? void 0 : l.cause;
                if (b) {
                    const g = (c = b == null ? void 0 : b.message) !== null && c !== void 0 ? c : ""
                      , m = (d = b == null ? void 0 : b.code) !== null && d !== void 0 ? d : "";
                    w = `${(h = l == null ? void 0 : l.name) !== null && h !== void 0 ? h : "FetchError"}: ${l == null ? void 0 : l.message}`,
                    w += `

Caused by: ${(f = b == null ? void 0 : b.name) !== null && f !== void 0 ? f : "Error"}: ${g}`,
                    m && (w += ` (${m})`),
                    b != null && b.stack && (w += `
${b.stack}`)
                } else
                    w = (p = l == null ? void 0 : l.stack) !== null && p !== void 0 ? p : "";
                return {
                    error: {
                        message: `${(v = l == null ? void 0 : l.name) !== null && v !== void 0 ? v : "FetchError"}: ${l == null ? void 0 : l.message}`,
                        details: w,
                        hint: "",
                        code: ""
                    },
                    data: null,
                    count: null,
                    status: 0,
                    statusText: ""
                }
            }
            )),
            a.then(s, i)
        }
        returns() {
            return this
        }
        overrideTypes() {
            return this
        }
    }
    ;
    return yo.default = r,
    yo
}
var Jh;
function Km() {
    if (Jh)
        return mo;
    Jh = 1,
    Object.defineProperty(mo, "__esModule", {
        value: !0
    });
    const e = Ds.__importDefault(qm());
    let r = class extends e.default {
        select(s) {
            let i = !1;
            const o = (s ?? "*").split("").map(a => /\s/.test(a) && !i ? "" : (a === '"' && (i = !i),
            a)).join("");
            return this.url.searchParams.set("select", o),
            this.headers.append("Prefer", "return=representation"),
            this
        }
        order(s, {ascending: i=!0, nullsFirst: o, foreignTable: a, referencedTable: l=a}={}) {
            const c = l ? `${l}.order` : "order"
              , d = this.url.searchParams.get(c);
            return this.url.searchParams.set(c, `${d ? `${d},` : ""}${s}.${i ? "asc" : "desc"}${o === void 0 ? "" : o ? ".nullsfirst" : ".nullslast"}`),
            this
        }
        limit(s, {foreignTable: i, referencedTable: o=i}={}) {
            const a = typeof o > "u" ? "limit" : `${o}.limit`;
            return this.url.searchParams.set(a, `${s}`),
            this
        }
        range(s, i, {foreignTable: o, referencedTable: a=o}={}) {
            const l = typeof a > "u" ? "offset" : `${a}.offset`
              , c = typeof a > "u" ? "limit" : `${a}.limit`;
            return this.url.searchParams.set(l, `${s}`),
            this.url.searchParams.set(c, `${i - s + 1}`),
            this
        }
        abortSignal(s) {
            return this.signal = s,
            this
        }
        single() {
            return this.headers.set("Accept", "application/vnd.pgrst.object+json"),
            this
        }
        maybeSingle() {
            return this.method === "GET" ? this.headers.set("Accept", "application/json") : this.headers.set("Accept", "application/vnd.pgrst.object+json"),
            this.isMaybeSingle = !0,
            this
        }
        csv() {
            return this.headers.set("Accept", "text/csv"),
            this
        }
        geojson() {
            return this.headers.set("Accept", "application/geo+json"),
            this
        }
        explain({analyze: s=!1, verbose: i=!1, settings: o=!1, buffers: a=!1, wal: l=!1, format: c="text"}={}) {
            var d;
            const h = [s ? "analyze" : null, i ? "verbose" : null, o ? "settings" : null, a ? "buffers" : null, l ? "wal" : null].filter(Boolean).join("|")
              , f = (d = this.headers.get("Accept")) !== null && d !== void 0 ? d : "application/json";
            return this.headers.set("Accept", `application/vnd.pgrst.plan+${c}; for="${f}"; options=${h};`),
            c === "json" ? this : this
        }
        rollback() {
            return this.headers.append("Prefer", "tx=rollback"),
            this
        }
        returns() {
            return this
        }
        maxAffected(s) {
            return this.headers.append("Prefer", "handling=strict"),
            this.headers.append("Prefer", `max-affected=${s}`),
            this
        }
    }
    ;
    return mo.default = r,
    mo
}
var Xh;
function ad() {
    if (Xh)
        return go;
    Xh = 1,
    Object.defineProperty(go, "__esModule", {
        value: !0
    });
    const e = Ds.__importDefault(Km())
      , r = new RegExp("[,()]");
    let n = class extends e.default {
        eq(i, o) {
            return this.url.searchParams.append(i, `eq.${o}`),
            this
        }
        neq(i, o) {
            return this.url.searchParams.append(i, `neq.${o}`),
            this
        }
        gt(i, o) {
            return this.url.searchParams.append(i, `gt.${o}`),
            this
        }
        gte(i, o) {
            return this.url.searchParams.append(i, `gte.${o}`),
            this
        }
        lt(i, o) {
            return this.url.searchParams.append(i, `lt.${o}`),
            this
        }
        lte(i, o) {
            return this.url.searchParams.append(i, `lte.${o}`),
            this
        }
        like(i, o) {
            return this.url.searchParams.append(i, `like.${o}`),
            this
        }
        likeAllOf(i, o) {
            return this.url.searchParams.append(i, `like(all).{${o.join(",")}}`),
            this
        }
        likeAnyOf(i, o) {
            return this.url.searchParams.append(i, `like(any).{${o.join(",")}}`),
            this
        }
        ilike(i, o) {
            return this.url.searchParams.append(i, `ilike.${o}`),
            this
        }
        ilikeAllOf(i, o) {
            return this.url.searchParams.append(i, `ilike(all).{${o.join(",")}}`),
            this
        }
        ilikeAnyOf(i, o) {
            return this.url.searchParams.append(i, `ilike(any).{${o.join(",")}}`),
            this
        }
        regexMatch(i, o) {
            return this.url.searchParams.append(i, `match.${o}`),
            this
        }
        regexIMatch(i, o) {
            return this.url.searchParams.append(i, `imatch.${o}`),
            this
        }
        is(i, o) {
            return this.url.searchParams.append(i, `is.${o}`),
            this
        }
        isDistinct(i, o) {
            return this.url.searchParams.append(i, `isdistinct.${o}`),
            this
        }
        in(i, o) {
            const a = Array.from(new Set(o)).map(l => typeof l == "string" && r.test(l) ? `"${l}"` : `${l}`).join(",");
            return this.url.searchParams.append(i, `in.(${a})`),
            this
        }
        contains(i, o) {
            return typeof o == "string" ? this.url.searchParams.append(i, `cs.${o}`) : Array.isArray(o) ? this.url.searchParams.append(i, `cs.{${o.join(",")}}`) : this.url.searchParams.append(i, `cs.${JSON.stringify(o)}`),
            this
        }
        containedBy(i, o) {
            return typeof o == "string" ? this.url.searchParams.append(i, `cd.${o}`) : Array.isArray(o) ? this.url.searchParams.append(i, `cd.{${o.join(",")}}`) : this.url.searchParams.append(i, `cd.${JSON.stringify(o)}`),
            this
        }
        rangeGt(i, o) {
            return this.url.searchParams.append(i, `sr.${o}`),
            this
        }
        rangeGte(i, o) {
            return this.url.searchParams.append(i, `nxl.${o}`),
            this
        }
        rangeLt(i, o) {
            return this.url.searchParams.append(i, `sl.${o}`),
            this
        }
        rangeLte(i, o) {
            return this.url.searchParams.append(i, `nxr.${o}`),
            this
        }
        rangeAdjacent(i, o) {
            return this.url.searchParams.append(i, `adj.${o}`),
            this
        }
        overlaps(i, o) {
            return typeof o == "string" ? this.url.searchParams.append(i, `ov.${o}`) : this.url.searchParams.append(i, `ov.{${o.join(",")}}`),
            this
        }
        textSearch(i, o, {config: a, type: l}={}) {
            let c = "";
            l === "plain" ? c = "pl" : l === "phrase" ? c = "ph" : l === "websearch" && (c = "w");
            const d = a === void 0 ? "" : `(${a})`;
            return this.url.searchParams.append(i, `${c}fts${d}.${o}`),
            this
        }
        match(i) {
            return Object.entries(i).forEach( ([o,a]) => {
                this.url.searchParams.append(o, `eq.${a}`)
            }
            ),
            this
        }
        not(i, o, a) {
            return this.url.searchParams.append(i, `not.${o}.${a}`),
            this
        }
        or(i, {foreignTable: o, referencedTable: a=o}={}) {
            const l = a ? `${a}.or` : "or";
            return this.url.searchParams.append(l, `(${i})`),
            this
        }
        filter(i, o, a) {
            return this.url.searchParams.append(i, `${o}.${a}`),
            this
        }
    }
    ;
    return go.default = n,
    go
}
var Yh;
function Qm() {
    if (Yh)
        return po;
    Yh = 1,
    Object.defineProperty(po, "__esModule", {
        value: !0
    });
    const e = Ds.__importDefault(ad());
    let r = class {
        constructor(s, {headers: i={}, schema: o, fetch: a}) {
            this.url = s,
            this.headers = new Headers(i),
            this.schema = o,
            this.fetch = a
        }
        select(s, i) {
            const {head: o=!1, count: a} = i ?? {}
              , l = o ? "HEAD" : "GET";
            let c = !1;
            const d = (s ?? "*").split("").map(h => /\s/.test(h) && !c ? "" : (h === '"' && (c = !c),
            h)).join("");
            return this.url.searchParams.set("select", d),
            a && this.headers.append("Prefer", `count=${a}`),
            new e.default({
                method: l,
                url: this.url,
                headers: this.headers,
                schema: this.schema,
                fetch: this.fetch
            })
        }
        insert(s, {count: i, defaultToNull: o=!0}={}) {
            var a;
            const l = "POST";
            if (i && this.headers.append("Prefer", `count=${i}`),
            o || this.headers.append("Prefer", "missing=default"),
            Array.isArray(s)) {
                const c = s.reduce( (d, h) => d.concat(Object.keys(h)), []);
                if (c.length > 0) {
                    const d = [...new Set(c)].map(h => `"${h}"`);
                    this.url.searchParams.set("columns", d.join(","))
                }
            }
            return new e.default({
                method: l,
                url: this.url,
                headers: this.headers,
                schema: this.schema,
                body: s,
                fetch: (a = this.fetch) !== null && a !== void 0 ? a : fetch
            })
        }
        upsert(s, {onConflict: i, ignoreDuplicates: o=!1, count: a, defaultToNull: l=!0}={}) {
            var c;
            const d = "POST";
            if (this.headers.append("Prefer", `resolution=${o ? "ignore" : "merge"}-duplicates`),
            i !== void 0 && this.url.searchParams.set("on_conflict", i),
            a && this.headers.append("Prefer", `count=${a}`),
            l || this.headers.append("Prefer", "missing=default"),
            Array.isArray(s)) {
                const h = s.reduce( (f, p) => f.concat(Object.keys(p)), []);
                if (h.length > 0) {
                    const f = [...new Set(h)].map(p => `"${p}"`);
                    this.url.searchParams.set("columns", f.join(","))
                }
            }
            return new e.default({
                method: d,
                url: this.url,
                headers: this.headers,
                schema: this.schema,
                body: s,
                fetch: (c = this.fetch) !== null && c !== void 0 ? c : fetch
            })
        }
        update(s, {count: i}={}) {
            var o;
            const a = "PATCH";
            return i && this.headers.append("Prefer", `count=${i}`),
            new e.default({
                method: a,
                url: this.url,
                headers: this.headers,
                schema: this.schema,
                body: s,
                fetch: (o = this.fetch) !== null && o !== void 0 ? o : fetch
            })
        }
        delete({count: s}={}) {
            var i;
            const o = "DELETE";
            return s && this.headers.append("Prefer", `count=${s}`),
            new e.default({
                method: o,
                url: this.url,
                headers: this.headers,
                schema: this.schema,
                fetch: (i = this.fetch) !== null && i !== void 0 ? i : fetch
            })
        }
    }
    ;
    return po.default = r,
    po
}
var Zh;
function Rx() {
    if (Zh)
        return fo;
    Zh = 1,
    Object.defineProperty(fo, "__esModule", {
        value: !0
    });
    const t = Ds
      , e = t.__importDefault(Qm())
      , r = t.__importDefault(ad());
    let n = class Jm {
        constructor(i, {headers: o={}, schema: a, fetch: l}={}) {
            this.url = i,
            this.headers = new Headers(o),
            this.schemaName = a,
            this.fetch = l
        }
        from(i) {
            if (!i || typeof i != "string" || i.trim() === "")
                throw new Error("Invalid relation name: relation must be a non-empty string.");
            const o = new URL(`${this.url}/${i}`);
            return new e.default(o,{
                headers: new Headers(this.headers),
                schema: this.schemaName,
                fetch: this.fetch
            })
        }
        schema(i) {
            return new Jm(this.url,{
                headers: this.headers,
                schema: i,
                fetch: this.fetch
            })
        }
        rpc(i, o={}, {head: a=!1, get: l=!1, count: c}={}) {
            var d;
            let h;
            const f = new URL(`${this.url}/rpc/${i}`);
            let p;
            a || l ? (h = a ? "HEAD" : "GET",
            Object.entries(o).filter( ([w,b]) => b !== void 0).map( ([w,b]) => [w, Array.isArray(b) ? `{${b.join(",")}}` : `${b}`]).forEach( ([w,b]) => {
                f.searchParams.append(w, b)
            }
            )) : (h = "POST",
            p = o);
            const v = new Headers(this.headers);
            return c && v.set("Prefer", `count=${c}`),
            new r.default({
                method: h,
                url: f,
                headers: v,
                schema: this.schemaName,
                body: p,
                fetch: (d = this.fetch) !== null && d !== void 0 ? d : fetch
            })
        }
    }
    ;
    return fo.default = n,
    fo
}
Object.defineProperty(Ke, "__esModule", {
    value: !0
});
Ke.PostgrestError = Ke.PostgrestBuilder = Ke.PostgrestTransformBuilder = Ke.PostgrestFilterBuilder = Ke.PostgrestQueryBuilder = Ke.PostgrestClient = void 0;
const $s = Ds
  , Xm = $s.__importDefault(Rx());
Ke.PostgrestClient = Xm.default;
const Ym = $s.__importDefault(Qm());
Ke.PostgrestQueryBuilder = Ym.default;
const Zm = $s.__importDefault(ad());
Ke.PostgrestFilterBuilder = Zm.default;
const ey = $s.__importDefault(Km());
Ke.PostgrestTransformBuilder = ey.default;
const ty = $s.__importDefault(qm());
Ke.PostgrestBuilder = ty.default;
const ry = $s.__importDefault(Hm());
Ke.PostgrestError = ry.default;
Ke.default = {
    PostgrestClient: Xm.default,
    PostgrestQueryBuilder: Ym.default,
    PostgrestFilterBuilder: Zm.default,
    PostgrestTransformBuilder: ey.default,
    PostgrestBuilder: ty.default,
    PostgrestError: ry.default
};
class ny {
    constructor() {}
    static detectEnvironment() {
        var e;
        if (typeof WebSocket < "u")
            return {
                type: "native",
                constructor: WebSocket
            };
        if (typeof globalThis < "u" && typeof globalThis.WebSocket < "u")
            return {
                type: "native",
                constructor: globalThis.WebSocket
            };
        if (typeof global < "u" && typeof global.WebSocket < "u")
            return {
                type: "native",
                constructor: global.WebSocket
            };
        if (typeof globalThis < "u" && typeof globalThis.WebSocketPair < "u" && typeof globalThis.WebSocket > "u")
            return {
                type: "cloudflare",
                error: "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",
                workaround: "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."
            };
        if (typeof globalThis < "u" && globalThis.EdgeRuntime || typeof navigator < "u" && (!((e = navigator.userAgent) === null || e === void 0) && e.includes("Vercel-Edge")))
            return {
                type: "unsupported",
                error: "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",
                workaround: "Use serverless functions or a different deployment target for WebSocket functionality."
            };
        if (typeof process < "u") {
            const r = process.versions;
            if (r && r.node) {
                const n = r.node
                  , s = parseInt(n.replace(/^v/, "").split(".")[0]);
                return s >= 22 ? typeof globalThis.WebSocket < "u" ? {
                    type: "native",
                    constructor: globalThis.WebSocket
                } : {
                    type: "unsupported",
                    error: `Node.js ${s} detected but native WebSocket not found.`,
                    workaround: "Provide a WebSocket implementation via the transport option."
                } : {
                    type: "unsupported",
                    error: `Node.js ${s} detected without native WebSocket support.`,
                    workaround: `For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`
                }
            }
        }
        return {
            type: "unsupported",
            error: "Unknown JavaScript runtime without WebSocket support.",
            workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
        }
    }
    static getWebSocketConstructor() {
        const e = this.detectEnvironment();
        if (e.constructor)
            return e.constructor;
        let r = e.error || "WebSocket not supported in this environment.";
        throw e.workaround && (r += `

Suggested solution: ${e.workaround}`),
        new Error(r)
    }
    static createWebSocket(e, r) {
        const n = this.getWebSocketConstructor();
        return new n(e,r)
    }
    static isWebSocketSupported() {
        try {
            const e = this.detectEnvironment();
            return e.type === "native" || e.type === "ws"
        } catch {
            return !1
        }
    }
}
const Ax = "2.87.1"
  , Ix = `realtime-js/${Ax}`
  , sy = "1.0.0"
  , Nx = "2.0.0"
  , ef = sy
  , Mu = 1e4
  , Lx = 1e3
  , Dx = 100;
var sn;
(function(t) {
    t[t.connecting = 0] = "connecting",
    t[t.open = 1] = "open",
    t[t.closing = 2] = "closing",
    t[t.closed = 3] = "closed"
}
)(sn || (sn = {}));
var Ce;
(function(t) {
    t.closed = "closed",
    t.errored = "errored",
    t.joined = "joined",
    t.joining = "joining",
    t.leaving = "leaving"
}
)(Ce || (Ce = {}));
var Dt;
(function(t) {
    t.close = "phx_close",
    t.error = "phx_error",
    t.join = "phx_join",
    t.reply = "phx_reply",
    t.leave = "phx_leave",
    t.access_token = "access_token"
}
)(Dt || (Dt = {}));
var Wu;
(function(t) {
    t.websocket = "websocket"
}
)(Wu || (Wu = {}));
var on;
(function(t) {
    t.Connecting = "connecting",
    t.Open = "open",
    t.Closing = "closing",
    t.Closed = "closed"
}
)(on || (on = {}));
class $x {
    constructor(e) {
        this.HEADER_LENGTH = 1,
        this.USER_BROADCAST_PUSH_META_LENGTH = 6,
        this.KINDS = {
            userBroadcastPush: 3,
            userBroadcast: 4
        },
        this.BINARY_ENCODING = 0,
        this.JSON_ENCODING = 1,
        this.BROADCAST_EVENT = "broadcast",
        this.allowedMetadataKeys = [],
        this.allowedMetadataKeys = e ?? []
    }
    encode(e, r) {
        if (e.event === this.BROADCAST_EVENT && !(e.payload instanceof ArrayBuffer) && typeof e.payload.event == "string")
            return r(this._binaryEncodeUserBroadcastPush(e));
        let n = [e.join_ref, e.ref, e.topic, e.event, e.payload];
        return r(JSON.stringify(n))
    }
    _binaryEncodeUserBroadcastPush(e) {
        var r;
        return this._isArrayBuffer((r = e.payload) === null || r === void 0 ? void 0 : r.payload) ? this._encodeBinaryUserBroadcastPush(e) : this._encodeJsonUserBroadcastPush(e)
    }
    _encodeBinaryUserBroadcastPush(e) {
        var r, n;
        const s = (n = (r = e.payload) === null || r === void 0 ? void 0 : r.payload) !== null && n !== void 0 ? n : new ArrayBuffer(0);
        return this._encodeUserBroadcastPush(e, this.BINARY_ENCODING, s)
    }
    _encodeJsonUserBroadcastPush(e) {
        var r, n;
        const s = (n = (r = e.payload) === null || r === void 0 ? void 0 : r.payload) !== null && n !== void 0 ? n : {}
          , o = new TextEncoder().encode(JSON.stringify(s)).buffer;
        return this._encodeUserBroadcastPush(e, this.JSON_ENCODING, o)
    }
    _encodeUserBroadcastPush(e, r, n) {
        var s, i;
        const o = e.topic
          , a = (s = e.ref) !== null && s !== void 0 ? s : ""
          , l = (i = e.join_ref) !== null && i !== void 0 ? i : ""
          , c = e.payload.event
          , d = this.allowedMetadataKeys ? this._pick(e.payload, this.allowedMetadataKeys) : {}
          , h = Object.keys(d).length === 0 ? "" : JSON.stringify(d);
        if (l.length > 255)
            throw new Error(`joinRef length ${l.length} exceeds maximum of 255`);
        if (a.length > 255)
            throw new Error(`ref length ${a.length} exceeds maximum of 255`);
        if (o.length > 255)
            throw new Error(`topic length ${o.length} exceeds maximum of 255`);
        if (c.length > 255)
            throw new Error(`userEvent length ${c.length} exceeds maximum of 255`);
        if (h.length > 255)
            throw new Error(`metadata length ${h.length} exceeds maximum of 255`);
        const f = this.USER_BROADCAST_PUSH_META_LENGTH + l.length + a.length + o.length + c.length + h.length
          , p = new ArrayBuffer(this.HEADER_LENGTH + f);
        let v = new DataView(p)
          , w = 0;
        v.setUint8(w++, this.KINDS.userBroadcastPush),
        v.setUint8(w++, l.length),
        v.setUint8(w++, a.length),
        v.setUint8(w++, o.length),
        v.setUint8(w++, c.length),
        v.setUint8(w++, h.length),
        v.setUint8(w++, r),
        Array.from(l, g => v.setUint8(w++, g.charCodeAt(0))),
        Array.from(a, g => v.setUint8(w++, g.charCodeAt(0))),
        Array.from(o, g => v.setUint8(w++, g.charCodeAt(0))),
        Array.from(c, g => v.setUint8(w++, g.charCodeAt(0))),
        Array.from(h, g => v.setUint8(w++, g.charCodeAt(0)));
        var b = new Uint8Array(p.byteLength + n.byteLength);
        return b.set(new Uint8Array(p), 0),
        b.set(new Uint8Array(n), p.byteLength),
        b.buffer
    }
    decode(e, r) {
        if (this._isArrayBuffer(e)) {
            let n = this._binaryDecode(e);
            return r(n)
        }
        if (typeof e == "string") {
            const n = JSON.parse(e)
              , [s,i,o,a,l] = n;
            return r({
                join_ref: s,
                ref: i,
                topic: o,
                event: a,
                payload: l
            })
        }
        return r({})
    }
    _binaryDecode(e) {
        const r = new DataView(e)
          , n = r.getUint8(0)
          , s = new TextDecoder;
        switch (n) {
        case this.KINDS.userBroadcast:
            return this._decodeUserBroadcast(e, r, s)
        }
    }
    _decodeUserBroadcast(e, r, n) {
        const s = r.getUint8(1)
          , i = r.getUint8(2)
          , o = r.getUint8(3)
          , a = r.getUint8(4);
        let l = this.HEADER_LENGTH + 4;
        const c = n.decode(e.slice(l, l + s));
        l = l + s;
        const d = n.decode(e.slice(l, l + i));
        l = l + i;
        const h = n.decode(e.slice(l, l + o));
        l = l + o;
        const f = e.slice(l, e.byteLength)
          , p = a === this.JSON_ENCODING ? JSON.parse(n.decode(f)) : f
          , v = {
            type: this.BROADCAST_EVENT,
            event: d,
            payload: p
        };
        return o > 0 && (v.meta = JSON.parse(h)),
        {
            join_ref: null,
            ref: null,
            topic: c,
            event: this.BROADCAST_EVENT,
            payload: v
        }
    }
    _isArrayBuffer(e) {
        var r;
        return e instanceof ArrayBuffer || ((r = e == null ? void 0 : e.constructor) === null || r === void 0 ? void 0 : r.name) === "ArrayBuffer"
    }
    _pick(e, r) {
        return !e || typeof e != "object" ? {} : Object.fromEntries(Object.entries(e).filter( ([n]) => r.includes(n)))
    }
}
class iy {
    constructor(e, r) {
        this.callback = e,
        this.timerCalc = r,
        this.timer = void 0,
        this.tries = 0,
        this.callback = e,
        this.timerCalc = r
    }
    reset() {
        this.tries = 0,
        clearTimeout(this.timer),
        this.timer = void 0
    }
    scheduleTimeout() {
        clearTimeout(this.timer),
        this.timer = setTimeout( () => {
            this.tries = this.tries + 1,
            this.callback()
        }
        , this.timerCalc(this.tries + 1))
    }
}
var ce;
(function(t) {
    t.abstime = "abstime",
    t.bool = "bool",
    t.date = "date",
    t.daterange = "daterange",
    t.float4 = "float4",
    t.float8 = "float8",
    t.int2 = "int2",
    t.int4 = "int4",
    t.int4range = "int4range",
    t.int8 = "int8",
    t.int8range = "int8range",
    t.json = "json",
    t.jsonb = "jsonb",
    t.money = "money",
    t.numeric = "numeric",
    t.oid = "oid",
    t.reltime = "reltime",
    t.text = "text",
    t.time = "time",
    t.timestamp = "timestamp",
    t.timestamptz = "timestamptz",
    t.timetz = "timetz",
    t.tsrange = "tsrange",
    t.tstzrange = "tstzrange"
}
)(ce || (ce = {}));
const tf = (t, e, r={}) => {
    var n;
    const s = (n = r.skipTypes) !== null && n !== void 0 ? n : [];
    return e ? Object.keys(e).reduce( (i, o) => (i[o] = Ux(o, t, e, s),
    i), {}) : {}
}
  , Ux = (t, e, r, n) => {
    const s = e.find(a => a.name === t)
      , i = s == null ? void 0 : s.type
      , o = r[t];
    return i && !n.includes(i) ? oy(i, o) : Gu(o)
}
  , oy = (t, e) => {
    if (t.charAt(0) === "_") {
        const r = t.slice(1, t.length);
        return Mx(e, r)
    }
    switch (t) {
    case ce.bool:
        return Fx(e);
    case ce.float4:
    case ce.float8:
    case ce.int2:
    case ce.int4:
    case ce.int8:
    case ce.numeric:
    case ce.oid:
        return Bx(e);
    case ce.json:
    case ce.jsonb:
        return zx(e);
    case ce.timestamp:
        return Wx(e);
    case ce.abstime:
    case ce.date:
    case ce.daterange:
    case ce.int4range:
    case ce.int8range:
    case ce.money:
    case ce.reltime:
    case ce.text:
    case ce.time:
    case ce.timestamptz:
    case ce.timetz:
    case ce.tsrange:
    case ce.tstzrange:
        return Gu(e);
    default:
        return Gu(e)
    }
}
  , Gu = t => t
  , Fx = t => {
    switch (t) {
    case "t":
        return !0;
    case "f":
        return !1;
    default:
        return t
    }
}
  , Bx = t => {
    if (typeof t == "string") {
        const e = parseFloat(t);
        if (!Number.isNaN(e))
            return e
    }
    return t
}
  , zx = t => {
    if (typeof t == "string")
        try {
            return JSON.parse(t)
        } catch (e) {
            return console.log(`JSON parse error: ${e}`),
            t
        }
    return t
}
  , Mx = (t, e) => {
    if (typeof t != "string")
        return t;
    const r = t.length - 1
      , n = t[r];
    if (t[0] === "{" && n === "}") {
        let i;
        const o = t.slice(1, r);
        try {
            i = JSON.parse("[" + o + "]")
        } catch {
            i = o ? o.split(",") : []
        }
        return i.map(a => oy(e, a))
    }
    return t
}
  , Wx = t => typeof t == "string" ? t.replace(" ", "T") : t
  , ay = t => {
    const e = new URL(t);
    return e.protocol = e.protocol.replace(/^ws/i, "http"),
    e.pathname = e.pathname.replace(/\/+$/, "").replace(/\/socket\/websocket$/i, "").replace(/\/socket$/i, "").replace(/\/websocket$/i, ""),
    e.pathname === "" || e.pathname === "/" ? e.pathname = "/api/broadcast" : e.pathname = e.pathname + "/api/broadcast",
    e.href
}
;
class Sl {
    constructor(e, r, n={}, s=Mu) {
        this.channel = e,
        this.event = r,
        this.payload = n,
        this.timeout = s,
        this.sent = !1,
        this.timeoutTimer = void 0,
        this.ref = "",
        this.receivedResp = null,
        this.recHooks = [],
        this.refEvent = null
    }
    resend(e) {
        this.timeout = e,
        this._cancelRefEvent(),
        this.ref = "",
        this.refEvent = null,
        this.receivedResp = null,
        this.sent = !1,
        this.send()
    }
    send() {
        this._hasReceived("timeout") || (this.startTimeout(),
        this.sent = !0,
        this.channel.socket.push({
            topic: this.channel.topic,
            event: this.event,
            payload: this.payload,
            ref: this.ref,
            join_ref: this.channel._joinRef()
        }))
    }
    updatePayload(e) {
        this.payload = Object.assign(Object.assign({}, this.payload), e)
    }
    receive(e, r) {
        var n;
        return this._hasReceived(e) && r((n = this.receivedResp) === null || n === void 0 ? void 0 : n.response),
        this.recHooks.push({
            status: e,
            callback: r
        }),
        this
    }
    startTimeout() {
        if (this.timeoutTimer)
            return;
        this.ref = this.channel.socket._makeRef(),
        this.refEvent = this.channel._replyEventName(this.ref);
        const e = r => {
            this._cancelRefEvent(),
            this._cancelTimeout(),
            this.receivedResp = r,
            this._matchReceive(r)
        }
        ;
        this.channel._on(this.refEvent, {}, e),
        this.timeoutTimer = setTimeout( () => {
            this.trigger("timeout", {})
        }
        , this.timeout)
    }
    trigger(e, r) {
        this.refEvent && this.channel._trigger(this.refEvent, {
            status: e,
            response: r
        })
    }
    destroy() {
        this._cancelRefEvent(),
        this._cancelTimeout()
    }
    _cancelRefEvent() {
        this.refEvent && this.channel._off(this.refEvent, {})
    }
    _cancelTimeout() {
        clearTimeout(this.timeoutTimer),
        this.timeoutTimer = void 0
    }
    _matchReceive({status: e, response: r}) {
        this.recHooks.filter(n => n.status === e).forEach(n => n.callback(r))
    }
    _hasReceived(e) {
        return this.receivedResp && this.receivedResp.status === e
    }
}
var Vu;
(function(t) {
    t.SYNC = "sync",
    t.JOIN = "join",
    t.LEAVE = "leave"
}
)(Vu || (Vu = {}));
let ly = class No {
    constructor(e, r) {
        this.channel = e,
        this.state = {},
        this.pendingDiffs = [],
        this.joinRef = null,
        this.enabled = !1,
        this.caller = {
            onJoin: () => {}
            ,
            onLeave: () => {}
            ,
            onSync: () => {}
        };
        const n = (r == null ? void 0 : r.events) || {
            state: "presence_state",
            diff: "presence_diff"
        };
        this.channel._on(n.state, {}, s => {
            const {onJoin: i, onLeave: o, onSync: a} = this.caller;
            this.joinRef = this.channel._joinRef(),
            this.state = No.syncState(this.state, s, i, o),
            this.pendingDiffs.forEach(l => {
                this.state = No.syncDiff(this.state, l, i, o)
            }
            ),
            this.pendingDiffs = [],
            a()
        }
        ),
        this.channel._on(n.diff, {}, s => {
            const {onJoin: i, onLeave: o, onSync: a} = this.caller;
            this.inPendingSyncState() ? this.pendingDiffs.push(s) : (this.state = No.syncDiff(this.state, s, i, o),
            a())
        }
        ),
        this.onJoin( (s, i, o) => {
            this.channel._trigger("presence", {
                event: "join",
                key: s,
                currentPresences: i,
                newPresences: o
            })
        }
        ),
        this.onLeave( (s, i, o) => {
            this.channel._trigger("presence", {
                event: "leave",
                key: s,
                currentPresences: i,
                leftPresences: o
            })
        }
        ),
        this.onSync( () => {
            this.channel._trigger("presence", {
                event: "sync"
            })
        }
        )
    }
    static syncState(e, r, n, s) {
        const i = this.cloneDeep(e)
          , o = this.transformState(r)
          , a = {}
          , l = {};
        return this.map(i, (c, d) => {
            o[c] || (l[c] = d)
        }
        ),
        this.map(o, (c, d) => {
            const h = i[c];
            if (h) {
                const f = d.map(b => b.presence_ref)
                  , p = h.map(b => b.presence_ref)
                  , v = d.filter(b => p.indexOf(b.presence_ref) < 0)
                  , w = h.filter(b => f.indexOf(b.presence_ref) < 0);
                v.length > 0 && (a[c] = v),
                w.length > 0 && (l[c] = w)
            } else
                a[c] = d
        }
        ),
        this.syncDiff(i, {
            joins: a,
            leaves: l
        }, n, s)
    }
    static syncDiff(e, r, n, s) {
        const {joins: i, leaves: o} = {
            joins: this.transformState(r.joins),
            leaves: this.transformState(r.leaves)
        };
        return n || (n = () => {}
        ),
        s || (s = () => {}
        ),
        this.map(i, (a, l) => {
            var c;
            const d = (c = e[a]) !== null && c !== void 0 ? c : [];
            if (e[a] = this.cloneDeep(l),
            d.length > 0) {
                const h = e[a].map(p => p.presence_ref)
                  , f = d.filter(p => h.indexOf(p.presence_ref) < 0);
                e[a].unshift(...f)
            }
            n(a, d, l)
        }
        ),
        this.map(o, (a, l) => {
            let c = e[a];
            if (!c)
                return;
            const d = l.map(h => h.presence_ref);
            c = c.filter(h => d.indexOf(h.presence_ref) < 0),
            e[a] = c,
            s(a, c, l),
            c.length === 0 && delete e[a]
        }
        ),
        e
    }
    static map(e, r) {
        return Object.getOwnPropertyNames(e).map(n => r(n, e[n]))
    }
    static transformState(e) {
        return e = this.cloneDeep(e),
        Object.getOwnPropertyNames(e).reduce( (r, n) => {
            const s = e[n];
            return "metas"in s ? r[n] = s.metas.map(i => (i.presence_ref = i.phx_ref,
            delete i.phx_ref,
            delete i.phx_ref_prev,
            i)) : r[n] = s,
            r
        }
        , {})
    }
    static cloneDeep(e) {
        return JSON.parse(JSON.stringify(e))
    }
    onJoin(e) {
        this.caller.onJoin = e
    }
    onLeave(e) {
        this.caller.onLeave = e
    }
    onSync(e) {
        this.caller.onSync = e
    }
    inPendingSyncState() {
        return !this.joinRef || this.joinRef !== this.channel._joinRef()
    }
}
;
var Hu;
(function(t) {
    t.ALL = "*",
    t.INSERT = "INSERT",
    t.UPDATE = "UPDATE",
    t.DELETE = "DELETE"
}
)(Hu || (Hu = {}));
var as;
(function(t) {
    t.BROADCAST = "broadcast",
    t.PRESENCE = "presence",
    t.POSTGRES_CHANGES = "postgres_changes",
    t.SYSTEM = "system"
}
)(as || (as = {}));
var Vt;
(function(t) {
    t.SUBSCRIBED = "SUBSCRIBED",
    t.TIMED_OUT = "TIMED_OUT",
    t.CLOSED = "CLOSED",
    t.CHANNEL_ERROR = "CHANNEL_ERROR"
}
)(Vt || (Vt = {}));
const Gx = Ce;
let uy = class Zs {
    constructor(e, r={
        config: {}
    }, n) {
        var s, i;
        if (this.topic = e,
        this.params = r,
        this.socket = n,
        this.bindings = {},
        this.state = Ce.closed,
        this.joinedOnce = !1,
        this.pushBuffer = [],
        this.subTopic = e.replace(/^realtime:/i, ""),
        this.params.config = Object.assign({
            broadcast: {
                ack: !1,
                self: !1
            },
            presence: {
                key: "",
                enabled: !1
            },
            private: !1
        }, r.config),
        this.timeout = this.socket.timeout,
        this.joinPush = new Sl(this,Dt.join,this.params,this.timeout),
        this.rejoinTimer = new iy( () => this._rejoinUntilConnected(),this.socket.reconnectAfterMs),
        this.joinPush.receive("ok", () => {
            this.state = Ce.joined,
            this.rejoinTimer.reset(),
            this.pushBuffer.forEach(o => o.send()),
            this.pushBuffer = []
        }
        ),
        this._onClose( () => {
            this.rejoinTimer.reset(),
            this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`),
            this.state = Ce.closed,
            this.socket._remove(this)
        }
        ),
        this._onError(o => {
            this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, o),
            this.state = Ce.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this.joinPush.receive("timeout", () => {
            this._isJoining() && (this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout),
            this.state = Ce.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this.joinPush.receive("error", o => {
            this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, o),
            this.state = Ce.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this._on(Dt.reply, {}, (o, a) => {
            this._trigger(this._replyEventName(a), o)
        }
        ),
        this.presence = new ly(this),
        this.broadcastEndpointURL = ay(this.socket.endPoint),
        this.private = this.params.config.private || !1,
        !this.private && (!((i = (s = this.params.config) === null || s === void 0 ? void 0 : s.broadcast) === null || i === void 0) && i.replay))
            throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`
    }
    subscribe(e, r=this.timeout) {
        var n, s, i;
        if (this.socket.isConnected() || this.socket.connect(),
        this.state == Ce.closed) {
            const {config: {broadcast: o, presence: a, private: l}} = this.params
              , c = (s = (n = this.bindings.postgres_changes) === null || n === void 0 ? void 0 : n.map(p => p.filter)) !== null && s !== void 0 ? s : []
              , d = !!this.bindings[as.PRESENCE] && this.bindings[as.PRESENCE].length > 0 || ((i = this.params.config.presence) === null || i === void 0 ? void 0 : i.enabled) === !0
              , h = {}
              , f = {
                broadcast: o,
                presence: Object.assign(Object.assign({}, a), {
                    enabled: d
                }),
                postgres_changes: c,
                private: l
            };
            this.socket.accessTokenValue && (h.access_token = this.socket.accessTokenValue),
            this._onError(p => e == null ? void 0 : e(Vt.CHANNEL_ERROR, p)),
            this._onClose( () => e == null ? void 0 : e(Vt.CLOSED)),
            this.updateJoinPayload(Object.assign({
                config: f
            }, h)),
            this.joinedOnce = !0,
            this._rejoin(r),
            this.joinPush.receive("ok", async ({postgres_changes: p}) => {
                var v;
                if (this.socket._isManualToken() || this.socket.setAuth(),
                p === void 0) {
                    e == null || e(Vt.SUBSCRIBED);
                    return
                } else {
                    const w = this.bindings.postgres_changes
                      , b = (v = w == null ? void 0 : w.length) !== null && v !== void 0 ? v : 0
                      , g = [];
                    for (let m = 0; m < b; m++) {
                        const y = w[m]
                          , {filter: {event: x, schema: k, table: C, filter: T}} = y
                          , I = p && p[m];
                        if (I && I.event === x && Zs.isFilterValueEqual(I.schema, k) && Zs.isFilterValueEqual(I.table, C) && Zs.isFilterValueEqual(I.filter, T))
                            g.push(Object.assign(Object.assign({}, y), {
                                id: I.id
                            }));
                        else {
                            this.unsubscribe(),
                            this.state = Ce.errored,
                            e == null || e(Vt.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
                            return
                        }
                    }
                    this.bindings.postgres_changes = g,
                    e && e(Vt.SUBSCRIBED);
                    return
                }
            }
            ).receive("error", p => {
                this.state = Ce.errored,
                e == null || e(Vt.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(p).join(", ") || "error")))
            }
            ).receive("timeout", () => {
                e == null || e(Vt.TIMED_OUT)
            }
            )
        }
        return this
    }
    presenceState() {
        return this.presence.state
    }
    async track(e, r={}) {
        return await this.send({
            type: "presence",
            event: "track",
            payload: e
        }, r.timeout || this.timeout)
    }
    async untrack(e={}) {
        return await this.send({
            type: "presence",
            event: "untrack"
        }, e)
    }
    on(e, r, n) {
        return this.state === Ce.joined && e === as.PRESENCE && (this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),
        this.unsubscribe().then(async () => await this.subscribe())),
        this._on(e, r, n)
    }
    async httpSend(e, r, n={}) {
        var s;
        const i = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
        if (r == null)
            return Promise.reject("Payload is required for httpSend()");
        const o = {
            method: "POST",
            headers: {
                Authorization: i,
                apikey: this.socket.apiKey ? this.socket.apiKey : "",
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                messages: [{
                    topic: this.subTopic,
                    event: e,
                    payload: r,
                    private: this.private
                }]
            })
        }
          , a = await this._fetchWithTimeout(this.broadcastEndpointURL, o, (s = n.timeout) !== null && s !== void 0 ? s : this.timeout);
        if (a.status === 202)
            return {
                success: !0
            };
        let l = a.statusText;
        try {
            const c = await a.json();
            l = c.error || c.message || l
        } catch {}
        return Promise.reject(new Error(l))
    }
    async send(e, r={}) {
        var n, s;
        if (!this._canPush() && e.type === "broadcast") {
            console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");
            const {event: i, payload: o} = e
              , l = {
                method: "POST",
                headers: {
                    Authorization: this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "",
                    apikey: this.socket.apiKey ? this.socket.apiKey : "",
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    messages: [{
                        topic: this.subTopic,
                        event: i,
                        payload: o,
                        private: this.private
                    }]
                })
            };
            try {
                const c = await this._fetchWithTimeout(this.broadcastEndpointURL, l, (n = r.timeout) !== null && n !== void 0 ? n : this.timeout);
                return await ((s = c.body) === null || s === void 0 ? void 0 : s.cancel()),
                c.ok ? "ok" : "error"
            } catch (c) {
                return c.name === "AbortError" ? "timed out" : "error"
            }
        } else
            return new Promise(i => {
                var o, a, l;
                const c = this._push(e.type, e, r.timeout || this.timeout);
                e.type === "broadcast" && !(!((l = (a = (o = this.params) === null || o === void 0 ? void 0 : o.config) === null || a === void 0 ? void 0 : a.broadcast) === null || l === void 0) && l.ack) && i("ok"),
                c.receive("ok", () => i("ok")),
                c.receive("error", () => i("error")),
                c.receive("timeout", () => i("timed out"))
            }
            )
    }
    updateJoinPayload(e) {
        this.joinPush.updatePayload(e)
    }
    unsubscribe(e=this.timeout) {
        this.state = Ce.leaving;
        const r = () => {
            this.socket.log("channel", `leave ${this.topic}`),
            this._trigger(Dt.close, "leave", this._joinRef())
        }
        ;
        this.joinPush.destroy();
        let n = null;
        return new Promise(s => {
            n = new Sl(this,Dt.leave,{},e),
            n.receive("ok", () => {
                r(),
                s("ok")
            }
            ).receive("timeout", () => {
                r(),
                s("timed out")
            }
            ).receive("error", () => {
                s("error")
            }
            ),
            n.send(),
            this._canPush() || n.trigger("ok", {})
        }
        ).finally( () => {
            n == null || n.destroy()
        }
        )
    }
    teardown() {
        this.pushBuffer.forEach(e => e.destroy()),
        this.pushBuffer = [],
        this.rejoinTimer.reset(),
        this.joinPush.destroy(),
        this.state = Ce.closed,
        this.bindings = {}
    }
    async _fetchWithTimeout(e, r, n) {
        const s = new AbortController
          , i = setTimeout( () => s.abort(), n)
          , o = await this.socket.fetch(e, Object.assign(Object.assign({}, r), {
            signal: s.signal
        }));
        return clearTimeout(i),
        o
    }
    _push(e, r, n=this.timeout) {
        if (!this.joinedOnce)
            throw `tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
        let s = new Sl(this,e,r,n);
        return this._canPush() ? s.send() : this._addToPushBuffer(s),
        s
    }
    _addToPushBuffer(e) {
        if (e.startTimeout(),
        this.pushBuffer.push(e),
        this.pushBuffer.length > Dx) {
            const r = this.pushBuffer.shift();
            r && (r.destroy(),
            this.socket.log("channel", `discarded push due to buffer overflow: ${r.event}`, r.payload))
        }
    }
    _onMessage(e, r, n) {
        return r
    }
    _isMember(e) {
        return this.topic === e
    }
    _joinRef() {
        return this.joinPush.ref
    }
    _trigger(e, r, n) {
        var s, i;
        const o = e.toLocaleLowerCase()
          , {close: a, error: l, leave: c, join: d} = Dt;
        if (n && [a, l, c, d].indexOf(o) >= 0 && n !== this._joinRef())
            return;
        let f = this._onMessage(o, r, n);
        if (r && !f)
            throw "channel onMessage callbacks must return the payload, modified or unmodified";
        ["insert", "update", "delete"].includes(o) ? (s = this.bindings.postgres_changes) === null || s === void 0 || s.filter(p => {
            var v, w, b;
            return ((v = p.filter) === null || v === void 0 ? void 0 : v.event) === "*" || ((b = (w = p.filter) === null || w === void 0 ? void 0 : w.event) === null || b === void 0 ? void 0 : b.toLocaleLowerCase()) === o
        }
        ).map(p => p.callback(f, n)) : (i = this.bindings[o]) === null || i === void 0 || i.filter(p => {
            var v, w, b, g, m, y;
            if (["broadcast", "presence", "postgres_changes"].includes(o))
                if ("id"in p) {
                    const x = p.id
                      , k = (v = p.filter) === null || v === void 0 ? void 0 : v.event;
                    return x && ((w = r.ids) === null || w === void 0 ? void 0 : w.includes(x)) && (k === "*" || (k == null ? void 0 : k.toLocaleLowerCase()) === ((b = r.data) === null || b === void 0 ? void 0 : b.type.toLocaleLowerCase()))
                } else {
                    const x = (m = (g = p == null ? void 0 : p.filter) === null || g === void 0 ? void 0 : g.event) === null || m === void 0 ? void 0 : m.toLocaleLowerCase();
                    return x === "*" || x === ((y = r == null ? void 0 : r.event) === null || y === void 0 ? void 0 : y.toLocaleLowerCase())
                }
            else
                return p.type.toLocaleLowerCase() === o
        }
        ).map(p => {
            if (typeof f == "object" && "ids"in f) {
                const v = f.data
                  , {schema: w, table: b, commit_timestamp: g, type: m, errors: y} = v;
                f = Object.assign(Object.assign({}, {
                    schema: w,
                    table: b,
                    commit_timestamp: g,
                    eventType: m,
                    new: {},
                    old: {},
                    errors: y
                }), this._getPayloadRecords(v))
            }
            p.callback(f, n)
        }
        )
    }
    _isClosed() {
        return this.state === Ce.closed
    }
    _isJoined() {
        return this.state === Ce.joined
    }
    _isJoining() {
        return this.state === Ce.joining
    }
    _isLeaving() {
        return this.state === Ce.leaving
    }
    _replyEventName(e) {
        return `chan_reply_${e}`
    }
    _on(e, r, n) {
        const s = e.toLocaleLowerCase()
          , i = {
            type: s,
            filter: r,
            callback: n
        };
        return this.bindings[s] ? this.bindings[s].push(i) : this.bindings[s] = [i],
        this
    }
    _off(e, r) {
        const n = e.toLocaleLowerCase();
        return this.bindings[n] && (this.bindings[n] = this.bindings[n].filter(s => {
            var i;
            return !(((i = s.type) === null || i === void 0 ? void 0 : i.toLocaleLowerCase()) === n && Zs.isEqual(s.filter, r))
        }
        )),
        this
    }
    static isEqual(e, r) {
        if (Object.keys(e).length !== Object.keys(r).length)
            return !1;
        for (const n in e)
            if (e[n] !== r[n])
                return !1;
        return !0
    }
    static isFilterValueEqual(e, r) {
        return (e ?? void 0) === (r ?? void 0)
    }
    _rejoinUntilConnected() {
        this.rejoinTimer.scheduleTimeout(),
        this.socket.isConnected() && this._rejoin()
    }
    _onClose(e) {
        this._on(Dt.close, {}, e)
    }
    _onError(e) {
        this._on(Dt.error, {}, r => e(r))
    }
    _canPush() {
        return this.socket.isConnected() && this._isJoined()
    }
    _rejoin(e=this.timeout) {
        this._isLeaving() || (this.socket._leaveOpenTopic(this.topic),
        this.state = Ce.joining,
        this.joinPush.resend(e))
    }
    _getPayloadRecords(e) {
        const r = {
            new: {},
            old: {}
        };
        return (e.type === "INSERT" || e.type === "UPDATE") && (r.new = tf(e.columns, e.record)),
        (e.type === "UPDATE" || e.type === "DELETE") && (r.old = tf(e.columns, e.old_record)),
        r
    }
}
;
const kl = () => {}
  , wo = {
    HEARTBEAT_INTERVAL: 25e3,
    RECONNECT_DELAY: 10,
    HEARTBEAT_TIMEOUT_FALLBACK: 100
}
  , Vx = [1e3, 2e3, 5e3, 1e4]
  , Hx = 1e4
  , qx = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
let Kx = class {
    constructor(e, r) {
        var n;
        if (this.accessTokenValue = null,
        this.apiKey = null,
        this._manuallySetToken = !1,
        this.channels = new Array,
        this.endPoint = "",
        this.httpEndpoint = "",
        this.headers = {},
        this.params = {},
        this.timeout = Mu,
        this.transport = null,
        this.heartbeatIntervalMs = wo.HEARTBEAT_INTERVAL,
        this.heartbeatTimer = void 0,
        this.pendingHeartbeatRef = null,
        this.heartbeatCallback = kl,
        this.ref = 0,
        this.reconnectTimer = null,
        this.vsn = ef,
        this.logger = kl,
        this.conn = null,
        this.sendBuffer = [],
        this.serializer = new $x,
        this.stateChangeCallbacks = {
            open: [],
            close: [],
            error: [],
            message: []
        },
        this.accessToken = null,
        this._connectionState = "disconnected",
        this._wasManualDisconnect = !1,
        this._authPromise = null,
        this._resolveFetch = s => s ? (...i) => s(...i) : (...i) => fetch(...i),
        !(!((n = r == null ? void 0 : r.params) === null || n === void 0) && n.apikey))
            throw new Error("API key is required to connect to Realtime");
        this.apiKey = r.params.apikey,
        this.endPoint = `${e}/${Wu.websocket}`,
        this.httpEndpoint = ay(e),
        this._initializeOptions(r),
        this._setupReconnectionTimer(),
        this.fetch = this._resolveFetch(r == null ? void 0 : r.fetch)
    }
    connect() {
        if (!(this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected())) {
            if (this._setConnectionState("connecting"),
            this.accessToken && !this._authPromise && this._setAuthSafely("connect"),
            this.transport)
                this.conn = new this.transport(this.endpointURL());
            else
                try {
                    this.conn = ny.createWebSocket(this.endpointURL())
                } catch (e) {
                    this._setConnectionState("disconnected");
                    const r = e.message;
                    throw r.includes("Node.js") ? new Error(`${r}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`) : new Error(`WebSocket not available: ${r}`)
                }
            this._setupConnectionHandlers()
        }
    }
    endpointURL() {
        return this._appendParams(this.endPoint, Object.assign({}, this.params, {
            vsn: this.vsn
        }))
    }
    disconnect(e, r) {
        if (!this.isDisconnecting())
            if (this._setConnectionState("disconnecting", !0),
            this.conn) {
                const n = setTimeout( () => {
                    this._setConnectionState("disconnected")
                }
                , 100);
                this.conn.onclose = () => {
                    clearTimeout(n),
                    this._setConnectionState("disconnected")
                }
                ,
                typeof this.conn.close == "function" && (e ? this.conn.close(e, r ?? "") : this.conn.close()),
                this._teardownConnection()
            } else
                this._setConnectionState("disconnected")
    }
    getChannels() {
        return this.channels
    }
    async removeChannel(e) {
        const r = await e.unsubscribe();
        return this.channels.length === 0 && this.disconnect(),
        r
    }
    async removeAllChannels() {
        const e = await Promise.all(this.channels.map(r => r.unsubscribe()));
        return this.channels = [],
        this.disconnect(),
        e
    }
    log(e, r, n) {
        this.logger(e, r, n)
    }
    connectionState() {
        switch (this.conn && this.conn.readyState) {
        case sn.connecting:
            return on.Connecting;
        case sn.open:
            return on.Open;
        case sn.closing:
            return on.Closing;
        default:
            return on.Closed
        }
    }
    isConnected() {
        return this.connectionState() === on.Open
    }
    isConnecting() {
        return this._connectionState === "connecting"
    }
    isDisconnecting() {
        return this._connectionState === "disconnecting"
    }
    channel(e, r={
        config: {}
    }) {
        const n = `realtime:${e}`
          , s = this.getChannels().find(i => i.topic === n);
        if (s)
            return s;
        {
            const i = new uy(`realtime:${e}`,r,this);
            return this.channels.push(i),
            i
        }
    }
    push(e) {
        const {topic: r, event: n, payload: s, ref: i} = e
          , o = () => {
            this.encode(e, a => {
                var l;
                (l = this.conn) === null || l === void 0 || l.send(a)
            }
            )
        }
        ;
        this.log("push", `${r} ${n} (${i})`, s),
        this.isConnected() ? o() : this.sendBuffer.push(o)
    }
    async setAuth(e=null) {
        this._authPromise = this._performAuth(e);
        try {
            await this._authPromise
        } finally {
            this._authPromise = null
        }
    }
    _isManualToken() {
        return this._manuallySetToken
    }
    async sendHeartbeat() {
        var e;
        if (!this.isConnected()) {
            try {
                this.heartbeatCallback("disconnected")
            } catch (r) {
                this.log("error", "error in heartbeat callback", r)
            }
            return
        }
        if (this.pendingHeartbeatRef) {
            this.pendingHeartbeatRef = null,
            this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
            try {
                this.heartbeatCallback("timeout")
            } catch (r) {
                this.log("error", "error in heartbeat callback", r)
            }
            this._wasManualDisconnect = !1,
            (e = this.conn) === null || e === void 0 || e.close(Lx, "heartbeat timeout"),
            setTimeout( () => {
                var r;
                this.isConnected() || (r = this.reconnectTimer) === null || r === void 0 || r.scheduleTimeout()
            }
            , wo.HEARTBEAT_TIMEOUT_FALLBACK);
            return
        }
        this.pendingHeartbeatRef = this._makeRef(),
        this.push({
            topic: "phoenix",
            event: "heartbeat",
            payload: {},
            ref: this.pendingHeartbeatRef
        });
        try {
            this.heartbeatCallback("sent")
        } catch (r) {
            this.log("error", "error in heartbeat callback", r)
        }
        this._setAuthSafely("heartbeat")
    }
    onHeartbeat(e) {
        this.heartbeatCallback = e
    }
    flushSendBuffer() {
        this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(e => e()),
        this.sendBuffer = [])
    }
    _makeRef() {
        let e = this.ref + 1;
        return e === this.ref ? this.ref = 0 : this.ref = e,
        this.ref.toString()
    }
    _leaveOpenTopic(e) {
        let r = this.channels.find(n => n.topic === e && (n._isJoined() || n._isJoining()));
        r && (this.log("transport", `leaving duplicate topic "${e}"`),
        r.unsubscribe())
    }
    _remove(e) {
        this.channels = this.channels.filter(r => r.topic !== e.topic)
    }
    _onConnMessage(e) {
        this.decode(e.data, r => {
            if (r.topic === "phoenix" && r.event === "phx_reply")
                try {
                    this.heartbeatCallback(r.payload.status === "ok" ? "ok" : "error")
                } catch (c) {
                    this.log("error", "error in heartbeat callback", c)
                }
            r.ref && r.ref === this.pendingHeartbeatRef && (this.pendingHeartbeatRef = null);
            const {topic: n, event: s, payload: i, ref: o} = r
              , a = o ? `(${o})` : ""
              , l = i.status || "";
            this.log("receive", `${l} ${n} ${s} ${a}`.trim(), i),
            this.channels.filter(c => c._isMember(n)).forEach(c => c._trigger(s, i, o)),
            this._triggerStateCallbacks("message", r)
        }
        )
    }
    _clearTimer(e) {
        var r;
        e === "heartbeat" && this.heartbeatTimer ? (clearInterval(this.heartbeatTimer),
        this.heartbeatTimer = void 0) : e === "reconnect" && ((r = this.reconnectTimer) === null || r === void 0 || r.reset())
    }
    _clearAllTimers() {
        this._clearTimer("heartbeat"),
        this._clearTimer("reconnect")
    }
    _setupConnectionHandlers() {
        this.conn && ("binaryType"in this.conn && (this.conn.binaryType = "arraybuffer"),
        this.conn.onopen = () => this._onConnOpen(),
        this.conn.onerror = e => this._onConnError(e),
        this.conn.onmessage = e => this._onConnMessage(e),
        this.conn.onclose = e => this._onConnClose(e))
    }
    _teardownConnection() {
        if (this.conn) {
            if (this.conn.readyState === sn.open || this.conn.readyState === sn.connecting)
                try {
                    this.conn.close()
                } catch (e) {
                    this.log("error", "Error closing connection", e)
                }
            this.conn.onopen = null,
            this.conn.onerror = null,
            this.conn.onmessage = null,
            this.conn.onclose = null,
            this.conn = null
        }
        this._clearAllTimers(),
        this.channels.forEach(e => e.teardown())
    }
    _onConnOpen() {
        this._setConnectionState("connected"),
        this.log("transport", `connected to ${this.endpointURL()}`),
        (this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve())).then( () => {
            this.flushSendBuffer()
        }
        ).catch(r => {
            this.log("error", "error waiting for auth on connect", r),
            this.flushSendBuffer()
        }
        ),
        this._clearTimer("reconnect"),
        this.worker ? this.workerRef || this._startWorkerHeartbeat() : this._startHeartbeat(),
        this._triggerStateCallbacks("open")
    }
    _startHeartbeat() {
        this.heartbeatTimer && clearInterval(this.heartbeatTimer),
        this.heartbeatTimer = setInterval( () => this.sendHeartbeat(), this.heartbeatIntervalMs)
    }
    _startWorkerHeartbeat() {
        this.workerUrl ? this.log("worker", `starting worker for from ${this.workerUrl}`) : this.log("worker", "starting default worker");
        const e = this._workerObjectUrl(this.workerUrl);
        this.workerRef = new Worker(e),
        this.workerRef.onerror = r => {
            this.log("worker", "worker error", r.message),
            this.workerRef.terminate()
        }
        ,
        this.workerRef.onmessage = r => {
            r.data.event === "keepAlive" && this.sendHeartbeat()
        }
        ,
        this.workerRef.postMessage({
            event: "start",
            interval: this.heartbeatIntervalMs
        })
    }
    _onConnClose(e) {
        var r;
        this._setConnectionState("disconnected"),
        this.log("transport", "close", e),
        this._triggerChanError(),
        this._clearTimer("heartbeat"),
        this._wasManualDisconnect || (r = this.reconnectTimer) === null || r === void 0 || r.scheduleTimeout(),
        this._triggerStateCallbacks("close", e)
    }
    _onConnError(e) {
        this._setConnectionState("disconnected"),
        this.log("transport", `${e}`),
        this._triggerChanError(),
        this._triggerStateCallbacks("error", e)
    }
    _triggerChanError() {
        this.channels.forEach(e => e._trigger(Dt.error))
    }
    _appendParams(e, r) {
        if (Object.keys(r).length === 0)
            return e;
        const n = e.match(/\?/) ? "&" : "?"
          , s = new URLSearchParams(r);
        return `${e}${n}${s}`
    }
    _workerObjectUrl(e) {
        let r;
        if (e)
            r = e;
        else {
            const n = new Blob([qx],{
                type: "application/javascript"
            });
            r = URL.createObjectURL(n)
        }
        return r
    }
    _setConnectionState(e, r=!1) {
        this._connectionState = e,
        e === "connecting" ? this._wasManualDisconnect = !1 : e === "disconnecting" && (this._wasManualDisconnect = r)
    }
    async _performAuth(e=null) {
        let r, n = !1;
        if (e)
            r = e,
            n = !0;
        else if (this.accessToken)
            try {
                r = await this.accessToken()
            } catch (s) {
                this.log("error", "Error fetching access token from callback", s),
                r = this.accessTokenValue
            }
        else
            r = this.accessTokenValue;
        n ? this._manuallySetToken = !0 : this.accessToken && (this._manuallySetToken = !1),
        this.accessTokenValue != r && (this.accessTokenValue = r,
        this.channels.forEach(s => {
            const i = {
                access_token: r,
                version: Ix
            };
            r && s.updateJoinPayload(i),
            s.joinedOnce && s._isJoined() && s._push(Dt.access_token, {
                access_token: r
            })
        }
        ))
    }
    async _waitForAuthIfNeeded() {
        this._authPromise && await this._authPromise
    }
    _setAuthSafely(e="general") {
        this._isManualToken() || this.setAuth().catch(r => {
            this.log("error", `Error setting auth in ${e}`, r)
        }
        )
    }
    _triggerStateCallbacks(e, r) {
        try {
            this.stateChangeCallbacks[e].forEach(n => {
                try {
                    n(r)
                } catch (s) {
                    this.log("error", `error in ${e} callback`, s)
                }
            }
            )
        } catch (n) {
            this.log("error", `error triggering ${e} callbacks`, n)
        }
    }
    _setupReconnectionTimer() {
        this.reconnectTimer = new iy(async () => {
            setTimeout(async () => {
                await this._waitForAuthIfNeeded(),
                this.isConnected() || this.connect()
            }
            , wo.RECONNECT_DELAY)
        }
        ,this.reconnectAfterMs)
    }
    _initializeOptions(e) {
        var r, n, s, i, o, a, l, c, d, h, f, p;
        switch (this.transport = (r = e == null ? void 0 : e.transport) !== null && r !== void 0 ? r : null,
        this.timeout = (n = e == null ? void 0 : e.timeout) !== null && n !== void 0 ? n : Mu,
        this.heartbeatIntervalMs = (s = e == null ? void 0 : e.heartbeatIntervalMs) !== null && s !== void 0 ? s : wo.HEARTBEAT_INTERVAL,
        this.worker = (i = e == null ? void 0 : e.worker) !== null && i !== void 0 ? i : !1,
        this.accessToken = (o = e == null ? void 0 : e.accessToken) !== null && o !== void 0 ? o : null,
        this.heartbeatCallback = (a = e == null ? void 0 : e.heartbeatCallback) !== null && a !== void 0 ? a : kl,
        this.vsn = (l = e == null ? void 0 : e.vsn) !== null && l !== void 0 ? l : ef,
        e != null && e.params && (this.params = e.params),
        e != null && e.logger && (this.logger = e.logger),
        (e != null && e.logLevel || e != null && e.log_level) && (this.logLevel = e.logLevel || e.log_level,
        this.params = Object.assign(Object.assign({}, this.params), {
            log_level: this.logLevel
        })),
        this.reconnectAfterMs = (c = e == null ? void 0 : e.reconnectAfterMs) !== null && c !== void 0 ? c : v => Vx[v - 1] || Hx,
        this.vsn) {
        case sy:
            this.encode = (d = e == null ? void 0 : e.encode) !== null && d !== void 0 ? d : (v, w) => w(JSON.stringify(v)),
            this.decode = (h = e == null ? void 0 : e.decode) !== null && h !== void 0 ? h : (v, w) => w(JSON.parse(v));
            break;
        case Nx:
            this.encode = (f = e == null ? void 0 : e.encode) !== null && f !== void 0 ? f : this.serializer.encode.bind(this.serializer),
            this.decode = (p = e == null ? void 0 : e.decode) !== null && p !== void 0 ? p : this.serializer.decode.bind(this.serializer);
            break;
        default:
            throw new Error(`Unsupported serializer version: ${this.vsn}`)
        }
        if (this.worker) {
            if (typeof window < "u" && !window.Worker)
                throw new Error("Web Worker is not supported");
            this.workerUrl = e == null ? void 0 : e.workerUrl
        }
    }
}
;
const Qx = Object.freeze(Object.defineProperty({
    __proto__: null,
    REALTIME_CHANNEL_STATES: Gx,
    get REALTIME_LISTEN_TYPES() {
        return as
    },
    get REALTIME_POSTGRES_CHANGES_LISTEN_EVENT() {
        return Hu
    },
    get REALTIME_PRESENCE_LISTEN_EVENTS() {
        return Vu
    },
    get REALTIME_SUBSCRIBE_STATES() {
        return Vt
    },
    RealtimeChannel: uy,
    RealtimeClient: Kx,
    RealtimePresence: ly,
    WebSocketFactory: ny
}, Symbol.toStringTag, {
    value: "Module"
}))
  , cy = Ui(Qx);
class Vi extends Error {
    constructor(e) {
        super(e),
        this.__isStorageError = !0,
        this.name = "StorageError"
    }
}
function me(t) {
    return typeof t == "object" && t !== null && "__isStorageError"in t
}
class dy extends Vi {
    constructor(e, r, n) {
        super(e),
        this.name = "StorageApiError",
        this.status = r,
        this.statusCode = n
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            statusCode: this.statusCode
        }
    }
}
class pa extends Vi {
    constructor(e, r) {
        super(e),
        this.name = "StorageUnknownError",
        this.originalError = r
    }
}
const ld = t => t ? (...e) => t(...e) : (...e) => fetch(...e)
  , Jx = () => Response
  , qu = t => {
    if (Array.isArray(t))
        return t.map(r => qu(r));
    if (typeof t == "function" || t !== Object(t))
        return t;
    const e = {};
    return Object.entries(t).forEach( ([r,n]) => {
        const s = r.replace(/([-_][a-z])/gi, i => i.toUpperCase().replace(/[-_]/g, ""));
        e[s] = qu(n)
    }
    ),
    e
}
  , Xx = t => {
    if (typeof t != "object" || t === null)
        return !1;
    const e = Object.getPrototypeOf(t);
    return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t)
}
  , Yx = t => !t || typeof t != "string" || t.length === 0 || t.length > 100 || t.trim() !== t || t.includes("/") || t.includes("\\") ? !1 : /^[\w!.\*'() &$@=;:+,?-]+$/.test(t)
  , El = t => {
    var e;
    return t.msg || t.message || t.error_description || (typeof t.error == "string" ? t.error : (e = t.error) === null || e === void 0 ? void 0 : e.message) || JSON.stringify(t)
}
  , Zx = (t, e, r) => F(void 0, void 0, void 0, function*() {
    const n = yield Jx();
    t instanceof n && !(r != null && r.noResolveJson) ? t.json().then(s => {
        const i = t.status || 500
          , o = (s == null ? void 0 : s.statusCode) || i + "";
        e(new dy(El(s),i,o))
    }
    ).catch(s => {
        e(new pa(El(s),s))
    }
    ) : e(new pa(El(t),t))
})
  , e_ = (t, e, r, n) => {
    const s = {
        method: t,
        headers: (e == null ? void 0 : e.headers) || {}
    };
    return t === "GET" || !n ? s : (Xx(n) ? (s.headers = Object.assign({
        "Content-Type": "application/json"
    }, e == null ? void 0 : e.headers),
    s.body = JSON.stringify(n)) : s.body = n,
    e != null && e.duplex && (s.duplex = e.duplex),
    Object.assign(Object.assign({}, s), r))
}
;
function Hi(t, e, r, n, s, i) {
    return F(this, void 0, void 0, function*() {
        return new Promise( (o, a) => {
            t(r, e_(e, n, s, i)).then(l => {
                if (!l.ok)
                    throw l;
                return n != null && n.noResolveJson ? l : l.json()
            }
            ).then(l => o(l)).catch(l => Zx(l, a, n))
        }
        )
    })
}
function Ri(t, e, r, n) {
    return F(this, void 0, void 0, function*() {
        return Hi(t, "GET", e, r, n)
    })
}
function At(t, e, r, n, s) {
    return F(this, void 0, void 0, function*() {
        return Hi(t, "POST", e, n, s, r)
    })
}
function Ku(t, e, r, n, s) {
    return F(this, void 0, void 0, function*() {
        return Hi(t, "PUT", e, n, s, r)
    })
}
function t_(t, e, r, n) {
    return F(this, void 0, void 0, function*() {
        return Hi(t, "HEAD", e, Object.assign(Object.assign({}, r), {
            noResolveJson: !0
        }), n)
    })
}
function ud(t, e, r, n, s) {
    return F(this, void 0, void 0, function*() {
        return Hi(t, "DELETE", e, n, s, r)
    })
}
class r_ {
    constructor(e, r) {
        this.downloadFn = e,
        this.shouldThrowOnError = r
    }
    then(e, r) {
        return this.execute().then(e, r)
    }
    execute() {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: (yield this.downloadFn()).body,
                    error: null
                }
            } catch (e) {
                if (this.shouldThrowOnError)
                    throw e;
                if (me(e))
                    return {
                        data: null,
                        error: e
                    };
                throw e
            }
        })
    }
}
var hy;
class n_ {
    constructor(e, r) {
        this.downloadFn = e,
        this.shouldThrowOnError = r,
        this[hy] = "BlobDownloadBuilder",
        this.promise = null
    }
    asStream() {
        return new r_(this.downloadFn,this.shouldThrowOnError)
    }
    then(e, r) {
        return this.getPromise().then(e, r)
    }
    catch(e) {
        return this.getPromise().catch(e)
    }
    finally(e) {
        return this.getPromise().finally(e)
    }
    getPromise() {
        return this.promise || (this.promise = this.execute()),
        this.promise
    }
    execute() {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield(yield this.downloadFn()).blob(),
                    error: null
                }
            } catch (e) {
                if (this.shouldThrowOnError)
                    throw e;
                if (me(e))
                    return {
                        data: null,
                        error: e
                    };
                throw e
            }
        })
    }
}
hy = Symbol.toStringTag;
const s_ = {
    limit: 100,
    offset: 0,
    sortBy: {
        column: "name",
        order: "asc"
    }
}
  , rf = {
    cacheControl: "3600",
    contentType: "text/plain;charset=UTF-8",
    upsert: !1
};
class i_ {
    constructor(e, r={}, n, s) {
        this.shouldThrowOnError = !1,
        this.url = e,
        this.headers = r,
        this.bucketId = n,
        this.fetch = ld(s)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    uploadOrUpdate(e, r, n, s) {
        return F(this, void 0, void 0, function*() {
            try {
                let i;
                const o = Object.assign(Object.assign({}, rf), s);
                let a = Object.assign(Object.assign({}, this.headers), e === "POST" && {
                    "x-upsert": String(o.upsert)
                });
                const l = o.metadata;
                typeof Blob < "u" && n instanceof Blob ? (i = new FormData,
                i.append("cacheControl", o.cacheControl),
                l && i.append("metadata", this.encodeMetadata(l)),
                i.append("", n)) : typeof FormData < "u" && n instanceof FormData ? (i = n,
                i.has("cacheControl") || i.append("cacheControl", o.cacheControl),
                l && !i.has("metadata") && i.append("metadata", this.encodeMetadata(l))) : (i = n,
                a["cache-control"] = `max-age=${o.cacheControl}`,
                a["content-type"] = o.contentType,
                l && (a["x-metadata"] = this.toBase64(this.encodeMetadata(l))),
                (typeof ReadableStream < "u" && i instanceof ReadableStream || i && typeof i == "object" && "pipe"in i && typeof i.pipe == "function") && !o.duplex && (o.duplex = "half")),
                s != null && s.headers && (a = Object.assign(Object.assign({}, a), s.headers));
                const c = this._removeEmptyFolders(r)
                  , d = this._getFinalPath(c)
                  , h = yield(e == "PUT" ? Ku : At)(this.fetch, `${this.url}/object/${d}`, i, Object.assign({
                    headers: a
                }, o != null && o.duplex ? {
                    duplex: o.duplex
                } : {}));
                return {
                    data: {
                        path: c,
                        id: h.Id,
                        fullPath: h.Key
                    },
                    error: null
                }
            } catch (i) {
                if (this.shouldThrowOnError)
                    throw i;
                if (me(i))
                    return {
                        data: null,
                        error: i
                    };
                throw i
            }
        })
    }
    upload(e, r, n) {
        return F(this, void 0, void 0, function*() {
            return this.uploadOrUpdate("POST", e, r, n)
        })
    }
    uploadToSignedUrl(e, r, n, s) {
        return F(this, void 0, void 0, function*() {
            const i = this._removeEmptyFolders(e)
              , o = this._getFinalPath(i)
              , a = new URL(this.url + `/object/upload/sign/${o}`);
            a.searchParams.set("token", r);
            try {
                let l;
                const c = Object.assign({
                    upsert: rf.upsert
                }, s)
                  , d = Object.assign(Object.assign({}, this.headers), {
                    "x-upsert": String(c.upsert)
                });
                typeof Blob < "u" && n instanceof Blob ? (l = new FormData,
                l.append("cacheControl", c.cacheControl),
                l.append("", n)) : typeof FormData < "u" && n instanceof FormData ? (l = n,
                l.append("cacheControl", c.cacheControl)) : (l = n,
                d["cache-control"] = `max-age=${c.cacheControl}`,
                d["content-type"] = c.contentType);
                const h = yield Ku(this.fetch, a.toString(), l, {
                    headers: d
                });
                return {
                    data: {
                        path: i,
                        fullPath: h.Key
                    },
                    error: null
                }
            } catch (l) {
                if (this.shouldThrowOnError)
                    throw l;
                if (me(l))
                    return {
                        data: null,
                        error: l
                    };
                throw l
            }
        })
    }
    createSignedUploadUrl(e, r) {
        return F(this, void 0, void 0, function*() {
            try {
                let n = this._getFinalPath(e);
                const s = Object.assign({}, this.headers);
                r != null && r.upsert && (s["x-upsert"] = "true");
                const i = yield At(this.fetch, `${this.url}/object/upload/sign/${n}`, {}, {
                    headers: s
                })
                  , o = new URL(this.url + i.url)
                  , a = o.searchParams.get("token");
                if (!a)
                    throw new Vi("No token returned by API");
                return {
                    data: {
                        signedUrl: o.toString(),
                        path: e,
                        token: a
                    },
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (me(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    update(e, r, n) {
        return F(this, void 0, void 0, function*() {
            return this.uploadOrUpdate("PUT", e, r, n)
        })
    }
    move(e, r, n) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield At(this.fetch, `${this.url}/object/move`, {
                        bucketId: this.bucketId,
                        sourceKey: e,
                        destinationKey: r,
                        destinationBucket: n == null ? void 0 : n.destinationBucket
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (me(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    copy(e, r, n) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: {
                        path: (yield At(this.fetch, `${this.url}/object/copy`, {
                            bucketId: this.bucketId,
                            sourceKey: e,
                            destinationKey: r,
                            destinationBucket: n == null ? void 0 : n.destinationBucket
                        }, {
                            headers: this.headers
                        })).Key
                    },
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (me(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    createSignedUrl(e, r, n) {
        return F(this, void 0, void 0, function*() {
            try {
                let s = this._getFinalPath(e)
                  , i = yield At(this.fetch, `${this.url}/object/sign/${s}`, Object.assign({
                    expiresIn: r
                }, n != null && n.transform ? {
                    transform: n.transform
                } : {}), {
                    headers: this.headers
                });
                const o = n != null && n.download ? `&download=${n.download === !0 ? "" : n.download}` : "";
                return i = {
                    signedUrl: encodeURI(`${this.url}${i.signedURL}${o}`)
                },
                {
                    data: i,
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (me(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    createSignedUrls(e, r, n) {
        return F(this, void 0, void 0, function*() {
            try {
                const s = yield At(this.fetch, `${this.url}/object/sign/${this.bucketId}`, {
                    expiresIn: r,
                    paths: e
                }, {
                    headers: this.headers
                })
                  , i = n != null && n.download ? `&download=${n.download === !0 ? "" : n.download}` : "";
                return {
                    data: s.map(o => Object.assign(Object.assign({}, o), {
                        signedUrl: o.signedURL ? encodeURI(`${this.url}${o.signedURL}${i}`) : null
                    })),
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (me(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    download(e, r) {
        const s = typeof (r == null ? void 0 : r.transform) < "u" ? "render/image/authenticated" : "object"
          , i = this.transformOptsToQueryString((r == null ? void 0 : r.transform) || {})
          , o = i ? `?${i}` : ""
          , a = this._getFinalPath(e)
          , l = () => Ri(this.fetch, `${this.url}/${s}/${a}${o}`, {
            headers: this.headers,
            noResolveJson: !0
        });
        return new n_(l,this.shouldThrowOnError)
    }
    info(e) {
        return F(this, void 0, void 0, function*() {
            const r = this._getFinalPath(e);
            try {
                const n = yield Ri(this.fetch, `${this.url}/object/info/${r}`, {
                    headers: this.headers
                });
                return {
                    data: qu(n),
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (me(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    exists(e) {
        return F(this, void 0, void 0, function*() {
            const r = this._getFinalPath(e);
            try {
                return yield t_(this.fetch, `${this.url}/object/${r}`, {
                    headers: this.headers
                }),
                {
                    data: !0,
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (me(n) && n instanceof pa) {
                    const s = n.originalError;
                    if ([400, 404].includes(s == null ? void 0 : s.status))
                        return {
                            data: !1,
                            error: n
                        }
                }
                throw n
            }
        })
    }
    getPublicUrl(e, r) {
        const n = this._getFinalPath(e)
          , s = []
          , i = r != null && r.download ? `download=${r.download === !0 ? "" : r.download}` : "";
        i !== "" && s.push(i);
        const a = typeof (r == null ? void 0 : r.transform) < "u" ? "render/image" : "object"
          , l = this.transformOptsToQueryString((r == null ? void 0 : r.transform) || {});
        l !== "" && s.push(l);
        let c = s.join("&");
        return c !== "" && (c = `?${c}`),
        {
            data: {
                publicUrl: encodeURI(`${this.url}/${a}/public/${n}${c}`)
            }
        }
    }
    remove(e) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield ud(this.fetch, `${this.url}/object/${this.bucketId}`, {
                        prefixes: e
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (me(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    list(e, r, n) {
        return F(this, void 0, void 0, function*() {
            try {
                const s = Object.assign(Object.assign(Object.assign({}, s_), r), {
                    prefix: e || ""
                });
                return {
                    data: yield At(this.fetch, `${this.url}/object/list/${this.bucketId}`, s, {
                        headers: this.headers
                    }, n),
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (me(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    listV2(e, r) {
        return F(this, void 0, void 0, function*() {
            try {
                const n = Object.assign({}, e);
                return {
                    data: yield At(this.fetch, `${this.url}/object/list-v2/${this.bucketId}`, n, {
                        headers: this.headers
                    }, r),
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (me(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    encodeMetadata(e) {
        return JSON.stringify(e)
    }
    toBase64(e) {
        return typeof Buffer < "u" ? Buffer.from(e).toString("base64") : btoa(e)
    }
    _getFinalPath(e) {
        return `${this.bucketId}/${e.replace(/^\/+/, "")}`
    }
    _removeEmptyFolders(e) {
        return e.replace(/^\/|\/$/g, "").replace(/\/+/g, "/")
    }
    transformOptsToQueryString(e) {
        const r = [];
        return e.width && r.push(`width=${e.width}`),
        e.height && r.push(`height=${e.height}`),
        e.resize && r.push(`resize=${e.resize}`),
        e.format && r.push(`format=${e.format}`),
        e.quality && r.push(`quality=${e.quality}`),
        r.join("&")
    }
}
const fy = "2.87.1"
  , py = {
    "X-Client-Info": `storage-js/${fy}`
};
class o_ {
    constructor(e, r={}, n, s) {
        this.shouldThrowOnError = !1;
        const i = new URL(e);
        s != null && s.useNewHostname && /supabase\.(co|in|red)$/.test(i.hostname) && !i.hostname.includes("storage.supabase.") && (i.hostname = i.hostname.replace("supabase.", "storage.supabase.")),
        this.url = i.href.replace(/\/$/, ""),
        this.headers = Object.assign(Object.assign({}, py), r),
        this.fetch = ld(n)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    listBuckets(e) {
        return F(this, void 0, void 0, function*() {
            try {
                const r = this.listBucketOptionsToQueryString(e);
                return {
                    data: yield Ri(this.fetch, `${this.url}/bucket${r}`, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (me(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    getBucket(e) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Ri(this.fetch, `${this.url}/bucket/${e}`, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (me(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    createBucket(e) {
        return F(this, arguments, void 0, function*(r, n={
            public: !1
        }) {
            try {
                return {
                    data: yield At(this.fetch, `${this.url}/bucket`, {
                        id: r,
                        name: r,
                        type: n.type,
                        public: n.public,
                        file_size_limit: n.fileSizeLimit,
                        allowed_mime_types: n.allowedMimeTypes
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (me(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    updateBucket(e, r) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Ku(this.fetch, `${this.url}/bucket/${e}`, {
                        id: e,
                        name: e,
                        public: r.public,
                        file_size_limit: r.fileSizeLimit,
                        allowed_mime_types: r.allowedMimeTypes
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (me(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    emptyBucket(e) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield At(this.fetch, `${this.url}/bucket/${e}/empty`, {}, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (me(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    deleteBucket(e) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield ud(this.fetch, `${this.url}/bucket/${e}`, {}, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (me(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    listBucketOptionsToQueryString(e) {
        const r = {};
        return e && ("limit"in e && (r.limit = String(e.limit)),
        "offset"in e && (r.offset = String(e.offset)),
        e.search && (r.search = e.search),
        e.sortColumn && (r.sortColumn = e.sortColumn),
        e.sortOrder && (r.sortOrder = e.sortOrder)),
        Object.keys(r).length > 0 ? "?" + new URLSearchParams(r).toString() : ""
    }
}
var Ai = class extends Error {
    constructor(t, e) {
        var r;
        super(t),
        this.name = "IcebergError",
        this.status = e.status,
        this.icebergType = e.icebergType,
        this.icebergCode = e.icebergCode,
        this.details = e.details,
        this.isCommitStateUnknown = e.icebergType === "CommitStateUnknownException" || [500, 502, 504].includes(e.status) && ((r = e.icebergType) == null ? void 0 : r.includes("CommitState")) === !0
    }
    isNotFound() {
        return this.status === 404
    }
    isConflict() {
        return this.status === 409
    }
    isAuthenticationTimeout() {
        return this.status === 419
    }
}
;
function a_(t, e, r) {
    const n = new URL(e,t);
    if (r)
        for (const [s,i] of Object.entries(r))
            i !== void 0 && n.searchParams.set(s, i);
    return n.toString()
}
async function l_(t) {
    return !t || t.type === "none" ? {} : t.type === "bearer" ? {
        Authorization: `Bearer ${t.token}`
    } : t.type === "header" ? {
        [t.name]: t.value
    } : t.type === "custom" ? await t.getHeaders() : {}
}
function u_(t) {
    const e = t.fetchImpl ?? globalThis.fetch;
    return {
        async request({method: r, path: n, query: s, body: i, headers: o}) {
            const a = a_(t.baseUrl, n, s)
              , l = await l_(t.auth)
              , c = await e(a, {
                method: r,
                headers: {
                    ...i ? {
                        "Content-Type": "application/json"
                    } : {},
                    ...l,
                    ...o
                },
                body: i ? JSON.stringify(i) : void 0
            })
              , d = await c.text()
              , h = (c.headers.get("content-type") || "").includes("application/json")
              , f = h && d ? JSON.parse(d) : d;
            if (!c.ok) {
                const p = h ? f : void 0
                  , v = p == null ? void 0 : p.error;
                throw new Ai((v == null ? void 0 : v.message) ?? `Request failed with status ${c.status}`,{
                    status: c.status,
                    icebergType: v == null ? void 0 : v.type,
                    icebergCode: v == null ? void 0 : v.code,
                    details: p
                })
            }
            return {
                status: c.status,
                headers: c.headers,
                data: f
            }
        }
    }
}
function bo(t) {
    return t.join("")
}
var c_ = class {
    constructor(t, e="") {
        this.client = t,
        this.prefix = e
    }
    async listNamespaces(t) {
        const e = t ? {
            parent: bo(t.namespace)
        } : void 0;
        return (await this.client.request({
            method: "GET",
            path: `${this.prefix}/namespaces`,
            query: e
        })).data.namespaces.map(n => ({
            namespace: n
        }))
    }
    async createNamespace(t, e) {
        const r = {
            namespace: t.namespace,
            properties: e == null ? void 0 : e.properties
        };
        return (await this.client.request({
            method: "POST",
            path: `${this.prefix}/namespaces`,
            body: r
        })).data
    }
    async dropNamespace(t) {
        await this.client.request({
            method: "DELETE",
            path: `${this.prefix}/namespaces/${bo(t.namespace)}`
        })
    }
    async loadNamespaceMetadata(t) {
        return {
            properties: (await this.client.request({
                method: "GET",
                path: `${this.prefix}/namespaces/${bo(t.namespace)}`
            })).data.properties
        }
    }
    async namespaceExists(t) {
        try {
            return await this.client.request({
                method: "HEAD",
                path: `${this.prefix}/namespaces/${bo(t.namespace)}`
            }),
            !0
        } catch (e) {
            if (e instanceof Ai && e.status === 404)
                return !1;
            throw e
        }
    }
    async createNamespaceIfNotExists(t, e) {
        try {
            return await this.createNamespace(t, e)
        } catch (r) {
            if (r instanceof Ai && r.status === 409)
                return;
            throw r
        }
    }
}
;
function Ln(t) {
    return t.join("")
}
var d_ = class {
    constructor(t, e="", r) {
        this.client = t,
        this.prefix = e,
        this.accessDelegation = r
    }
    async listTables(t) {
        return (await this.client.request({
            method: "GET",
            path: `${this.prefix}/namespaces/${Ln(t.namespace)}/tables`
        })).data.identifiers
    }
    async createTable(t, e) {
        const r = {};
        return this.accessDelegation && (r["X-Iceberg-Access-Delegation"] = this.accessDelegation),
        (await this.client.request({
            method: "POST",
            path: `${this.prefix}/namespaces/${Ln(t.namespace)}/tables`,
            body: e,
            headers: r
        })).data.metadata
    }
    async updateTable(t, e) {
        const r = await this.client.request({
            method: "POST",
            path: `${this.prefix}/namespaces/${Ln(t.namespace)}/tables/${t.name}`,
            body: e
        });
        return {
            "metadata-location": r.data["metadata-location"],
            metadata: r.data.metadata
        }
    }
    async dropTable(t, e) {
        await this.client.request({
            method: "DELETE",
            path: `${this.prefix}/namespaces/${Ln(t.namespace)}/tables/${t.name}`,
            query: {
                purgeRequested: String((e == null ? void 0 : e.purge) ?? !1)
            }
        })
    }
    async loadTable(t) {
        const e = {};
        return this.accessDelegation && (e["X-Iceberg-Access-Delegation"] = this.accessDelegation),
        (await this.client.request({
            method: "GET",
            path: `${this.prefix}/namespaces/${Ln(t.namespace)}/tables/${t.name}`,
            headers: e
        })).data.metadata
    }
    async tableExists(t) {
        const e = {};
        this.accessDelegation && (e["X-Iceberg-Access-Delegation"] = this.accessDelegation);
        try {
            return await this.client.request({
                method: "HEAD",
                path: `${this.prefix}/namespaces/${Ln(t.namespace)}/tables/${t.name}`,
                headers: e
            }),
            !0
        } catch (r) {
            if (r instanceof Ai && r.status === 404)
                return !1;
            throw r
        }
    }
    async createTableIfNotExists(t, e) {
        try {
            return await this.createTable(t, e)
        } catch (r) {
            if (r instanceof Ai && r.status === 409)
                return await this.loadTable({
                    namespace: t.namespace,
                    name: e.name
                });
            throw r
        }
    }
}
  , h_ = class {
    constructor(t) {
        var n;
        let e = "v1";
        t.catalogName && (e += `/${t.catalogName}`);
        const r = t.baseUrl.endsWith("/") ? t.baseUrl : `${t.baseUrl}/`;
        this.client = u_({
            baseUrl: r,
            auth: t.auth,
            fetchImpl: t.fetch
        }),
        this.accessDelegation = (n = t.accessDelegation) == null ? void 0 : n.join(","),
        this.namespaceOps = new c_(this.client,e),
        this.tableOps = new d_(this.client,e,this.accessDelegation)
    }
    async listNamespaces(t) {
        return this.namespaceOps.listNamespaces(t)
    }
    async createNamespace(t, e) {
        return this.namespaceOps.createNamespace(t, e)
    }
    async dropNamespace(t) {
        await this.namespaceOps.dropNamespace(t)
    }
    async loadNamespaceMetadata(t) {
        return this.namespaceOps.loadNamespaceMetadata(t)
    }
    async listTables(t) {
        return this.tableOps.listTables(t)
    }
    async createTable(t, e) {
        return this.tableOps.createTable(t, e)
    }
    async updateTable(t, e) {
        return this.tableOps.updateTable(t, e)
    }
    async dropTable(t, e) {
        await this.tableOps.dropTable(t, e)
    }
    async loadTable(t) {
        return this.tableOps.loadTable(t)
    }
    async namespaceExists(t) {
        return this.namespaceOps.namespaceExists(t)
    }
    async tableExists(t) {
        return this.tableOps.tableExists(t)
    }
    async createNamespaceIfNotExists(t, e) {
        return this.namespaceOps.createNamespaceIfNotExists(t, e)
    }
    async createTableIfNotExists(t, e) {
        return this.tableOps.createTableIfNotExists(t, e)
    }
}
;
class gy {
    constructor(e, r={}, n) {
        this.shouldThrowOnError = !1,
        this.url = e.replace(/\/$/, ""),
        this.headers = Object.assign(Object.assign({}, py), r),
        this.fetch = ld(n)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    createBucket(e) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield At(this.fetch, `${this.url}/bucket`, {
                        name: e
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (me(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    listBuckets(e) {
        return F(this, void 0, void 0, function*() {
            try {
                const r = new URLSearchParams;
                (e == null ? void 0 : e.limit) !== void 0 && r.set("limit", e.limit.toString()),
                (e == null ? void 0 : e.offset) !== void 0 && r.set("offset", e.offset.toString()),
                e != null && e.sortColumn && r.set("sortColumn", e.sortColumn),
                e != null && e.sortOrder && r.set("sortOrder", e.sortOrder),
                e != null && e.search && r.set("search", e.search);
                const n = r.toString()
                  , s = n ? `${this.url}/bucket?${n}` : `${this.url}/bucket`;
                return {
                    data: yield Ri(this.fetch, s, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (me(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    deleteBucket(e) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield ud(this.fetch, `${this.url}/bucket/${e}`, {}, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (me(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    from(e) {
        if (!Yx(e))
            throw new Vi("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.");
        const r = new h_({
            baseUrl: this.url,
            catalogName: e,
            auth: {
                type: "custom",
                getHeaders: () => F(this, void 0, void 0, function*() {
                    return this.headers
                })
            },
            fetch: this.fetch
        })
          , n = this.shouldThrowOnError;
        return new Proxy(r,{
            get(i, o) {
                const a = i[o];
                return typeof a != "function" ? a : (...l) => F(this, void 0, void 0, function*() {
                    try {
                        return {
                            data: yield a.apply(i, l),
                            error: null
                        }
                    } catch (c) {
                        if (n)
                            throw c;
                        return {
                            data: null,
                            error: c
                        }
                    }
                })
            }
        })
    }
}
const cd = {
    "X-Client-Info": `storage-js/${fy}`,
    "Content-Type": "application/json"
};
class dd extends Error {
    constructor(e) {
        super(e),
        this.__isStorageVectorsError = !0,
        this.name = "StorageVectorsError"
    }
}
function ut(t) {
    return typeof t == "object" && t !== null && "__isStorageVectorsError"in t
}
class Lo extends dd {
    constructor(e, r, n) {
        super(e),
        this.name = "StorageVectorsApiError",
        this.status = r,
        this.statusCode = n
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            statusCode: this.statusCode
        }
    }
}
class my extends dd {
    constructor(e, r) {
        super(e),
        this.name = "StorageVectorsUnknownError",
        this.originalError = r
    }
}
var Qu;
(function(t) {
    t.InternalError = "InternalError",
    t.S3VectorConflictException = "S3VectorConflictException",
    t.S3VectorNotFoundException = "S3VectorNotFoundException",
    t.S3VectorBucketNotEmpty = "S3VectorBucketNotEmpty",
    t.S3VectorMaxBucketsExceeded = "S3VectorMaxBucketsExceeded",
    t.S3VectorMaxIndexesExceeded = "S3VectorMaxIndexesExceeded"
}
)(Qu || (Qu = {}));
const za = t => t ? (...e) => t(...e) : (...e) => fetch(...e)
  , f_ = () => Response
  , yy = t => {
    if (typeof t != "object" || t === null)
        return !1;
    const e = Object.getPrototypeOf(t);
    return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t)
}
  , p_ = t => Array.from(new Float32Array(t))
  , g_ = (t, e) => {
    if (e !== void 0 && t.float32.length !== e)
        throw new Error(`Vector dimension mismatch: expected ${e}, got ${t.float32.length}`)
}
  , nf = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t)
  , m_ = (t, e, r) => F(void 0, void 0, void 0, function*() {
    if (t && typeof t == "object" && "status"in t && "ok"in t && typeof t.status == "number" && !(r != null && r.noResolveJson)) {
        const s = t.status || 500
          , i = t;
        if (typeof i.json == "function")
            i.json().then(o => {
                const a = (o == null ? void 0 : o.statusCode) || (o == null ? void 0 : o.code) || s + "";
                e(new Lo(nf(o),s,a))
            }
            ).catch( () => {
                const o = s + ""
                  , a = i.statusText || `HTTP ${s} error`;
                e(new Lo(a,s,o))
            }
            );
        else {
            const o = s + ""
              , a = i.statusText || `HTTP ${s} error`;
            e(new Lo(a,s,o))
        }
    } else
        e(new my(nf(t),t))
})
  , y_ = (t, e, r, n) => {
    const s = {
        method: t,
        headers: (e == null ? void 0 : e.headers) || {}
    };
    return n ? (yy(n) ? (s.headers = Object.assign({
        "Content-Type": "application/json"
    }, e == null ? void 0 : e.headers),
    s.body = JSON.stringify(n)) : s.body = n,
    Object.assign(Object.assign({}, s), r)) : s
}
;
function v_(t, e, r, n, s, i) {
    return F(this, void 0, void 0, function*() {
        return new Promise( (o, a) => {
            t(r, y_(e, n, s, i)).then(l => {
                if (!l.ok)
                    throw l;
                if (n != null && n.noResolveJson)
                    return l;
                const c = l.headers.get("content-type");
                return !c || !c.includes("application/json") ? {} : l.json()
            }
            ).then(l => o(l)).catch(l => m_(l, a, n))
        }
        )
    })
}
function gt(t, e, r, n, s) {
    return F(this, void 0, void 0, function*() {
        return v_(t, "POST", e, n, s, r)
    })
}
class vy {
    constructor(e, r={}, n) {
        this.shouldThrowOnError = !1,
        this.url = e.replace(/\/$/, ""),
        this.headers = Object.assign(Object.assign({}, cd), r),
        this.fetch = za(n)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    createIndex(e) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: (yield gt(this.fetch, `${this.url}/CreateIndex`, e, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (ut(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    getIndex(e, r) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield gt(this.fetch, `${this.url}/GetIndex`, {
                        vectorBucketName: e,
                        indexName: r
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (ut(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    listIndexes(e) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield gt(this.fetch, `${this.url}/ListIndexes`, e, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (ut(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    deleteIndex(e, r) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: (yield gt(this.fetch, `${this.url}/DeleteIndex`, {
                        vectorBucketName: e,
                        indexName: r
                    }, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (ut(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
}
class wy {
    constructor(e, r={}, n) {
        this.shouldThrowOnError = !1,
        this.url = e.replace(/\/$/, ""),
        this.headers = Object.assign(Object.assign({}, cd), r),
        this.fetch = za(n)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    putVectors(e) {
        return F(this, void 0, void 0, function*() {
            try {
                if (e.vectors.length < 1 || e.vectors.length > 500)
                    throw new Error("Vector batch size must be between 1 and 500 items");
                return {
                    data: (yield gt(this.fetch, `${this.url}/PutVectors`, e, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (ut(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    getVectors(e) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield gt(this.fetch, `${this.url}/GetVectors`, e, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (ut(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    listVectors(e) {
        return F(this, void 0, void 0, function*() {
            try {
                if (e.segmentCount !== void 0) {
                    if (e.segmentCount < 1 || e.segmentCount > 16)
                        throw new Error("segmentCount must be between 1 and 16");
                    if (e.segmentIndex !== void 0 && (e.segmentIndex < 0 || e.segmentIndex >= e.segmentCount))
                        throw new Error(`segmentIndex must be between 0 and ${e.segmentCount - 1}`)
                }
                return {
                    data: yield gt(this.fetch, `${this.url}/ListVectors`, e, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (ut(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    queryVectors(e) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield gt(this.fetch, `${this.url}/QueryVectors`, e, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (ut(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    deleteVectors(e) {
        return F(this, void 0, void 0, function*() {
            try {
                if (e.keys.length < 1 || e.keys.length > 500)
                    throw new Error("Keys batch size must be between 1 and 500 items");
                return {
                    data: (yield gt(this.fetch, `${this.url}/DeleteVectors`, e, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (ut(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
}
class by {
    constructor(e, r={}, n) {
        this.shouldThrowOnError = !1,
        this.url = e.replace(/\/$/, ""),
        this.headers = Object.assign(Object.assign({}, cd), r),
        this.fetch = za(n)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    createBucket(e) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: (yield gt(this.fetch, `${this.url}/CreateVectorBucket`, {
                        vectorBucketName: e
                    }, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (ut(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    getBucket(e) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield gt(this.fetch, `${this.url}/GetVectorBucket`, {
                        vectorBucketName: e
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (ut(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    listBuckets() {
        return F(this, arguments, void 0, function*(e={}) {
            try {
                return {
                    data: yield gt(this.fetch, `${this.url}/ListVectorBuckets`, e, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (ut(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    deleteBucket(e) {
        return F(this, void 0, void 0, function*() {
            try {
                return {
                    data: (yield gt(this.fetch, `${this.url}/DeleteVectorBucket`, {
                        vectorBucketName: e
                    }, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (ut(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
}
class xy extends by {
    constructor(e, r={}) {
        super(e, r.headers || {}, r.fetch)
    }
    from(e) {
        return new _y(this.url,this.headers,e,this.fetch)
    }
    createBucket(e) {
        const r = Object.create(null, {
            createBucket: {
                get: () => super.createBucket
            }
        });
        return F(this, void 0, void 0, function*() {
            return r.createBucket.call(this, e)
        })
    }
    getBucket(e) {
        const r = Object.create(null, {
            getBucket: {
                get: () => super.getBucket
            }
        });
        return F(this, void 0, void 0, function*() {
            return r.getBucket.call(this, e)
        })
    }
    listBuckets() {
        const e = Object.create(null, {
            listBuckets: {
                get: () => super.listBuckets
            }
        });
        return F(this, arguments, void 0, function*(r={}) {
            return e.listBuckets.call(this, r)
        })
    }
    deleteBucket(e) {
        const r = Object.create(null, {
            deleteBucket: {
                get: () => super.deleteBucket
            }
        });
        return F(this, void 0, void 0, function*() {
            return r.deleteBucket.call(this, e)
        })
    }
}
class _y extends vy {
    constructor(e, r, n, s) {
        super(e, r, s),
        this.vectorBucketName = n
    }
    createIndex(e) {
        const r = Object.create(null, {
            createIndex: {
                get: () => super.createIndex
            }
        });
        return F(this, void 0, void 0, function*() {
            return r.createIndex.call(this, Object.assign(Object.assign({}, e), {
                vectorBucketName: this.vectorBucketName
            }))
        })
    }
    listIndexes() {
        const e = Object.create(null, {
            listIndexes: {
                get: () => super.listIndexes
            }
        });
        return F(this, arguments, void 0, function*(r={}) {
            return e.listIndexes.call(this, Object.assign(Object.assign({}, r), {
                vectorBucketName: this.vectorBucketName
            }))
        })
    }
    getIndex(e) {
        const r = Object.create(null, {
            getIndex: {
                get: () => super.getIndex
            }
        });
        return F(this, void 0, void 0, function*() {
            return r.getIndex.call(this, this.vectorBucketName, e)
        })
    }
    deleteIndex(e) {
        const r = Object.create(null, {
            deleteIndex: {
                get: () => super.deleteIndex
            }
        });
        return F(this, void 0, void 0, function*() {
            return r.deleteIndex.call(this, this.vectorBucketName, e)
        })
    }
    index(e) {
        return new Sy(this.url,this.headers,this.vectorBucketName,e,this.fetch)
    }
}
class Sy extends wy {
    constructor(e, r, n, s, i) {
        super(e, r, i),
        this.vectorBucketName = n,
        this.indexName = s
    }
    putVectors(e) {
        const r = Object.create(null, {
            putVectors: {
                get: () => super.putVectors
            }
        });
        return F(this, void 0, void 0, function*() {
            return r.putVectors.call(this, Object.assign(Object.assign({}, e), {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName
            }))
        })
    }
    getVectors(e) {
        const r = Object.create(null, {
            getVectors: {
                get: () => super.getVectors
            }
        });
        return F(this, void 0, void 0, function*() {
            return r.getVectors.call(this, Object.assign(Object.assign({}, e), {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName
            }))
        })
    }
    listVectors() {
        const e = Object.create(null, {
            listVectors: {
                get: () => super.listVectors
            }
        });
        return F(this, arguments, void 0, function*(r={}) {
            return e.listVectors.call(this, Object.assign(Object.assign({}, r), {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName
            }))
        })
    }
    queryVectors(e) {
        const r = Object.create(null, {
            queryVectors: {
                get: () => super.queryVectors
            }
        });
        return F(this, void 0, void 0, function*() {
            return r.queryVectors.call(this, Object.assign(Object.assign({}, e), {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName
            }))
        })
    }
    deleteVectors(e) {
        const r = Object.create(null, {
            deleteVectors: {
                get: () => super.deleteVectors
            }
        });
        return F(this, void 0, void 0, function*() {
            return r.deleteVectors.call(this, Object.assign(Object.assign({}, e), {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName
            }))
        })
    }
}
class w_ extends o_ {
    constructor(e, r={}, n, s) {
        super(e, r, n, s)
    }
    from(e) {
        return new i_(this.url,this.headers,e,this.fetch)
    }
    get vectors() {
        return new xy(this.url + "/vector",{
            headers: this.headers,
            fetch: this.fetch
        })
    }
    get analytics() {
        return new gy(this.url + "/iceberg",this.headers,this.fetch)
    }
}
const b_ = Object.freeze(Object.defineProperty({
    __proto__: null,
    StorageAnalyticsClient: gy,
    StorageApiError: dy,
    StorageClient: w_,
    StorageError: Vi,
    StorageUnknownError: pa,
    StorageVectorsApiError: Lo,
    StorageVectorsClient: xy,
    StorageVectorsError: dd,
    get StorageVectorsErrorCode() {
        return Qu
    },
    StorageVectorsUnknownError: my,
    VectorBucketApi: by,
    VectorBucketScope: _y,
    VectorDataApi: wy,
    VectorIndexApi: vy,
    VectorIndexScope: Sy,
    isPlainObject: yy,
    isStorageError: me,
    isStorageVectorsError: ut,
    normalizeToFloat32: p_,
    resolveFetch: za,
    resolveResponse: f_,
    validateVectorDimension: g_
}, Symbol.toStringTag, {
    value: "Module"
}))
  , x_ = Ui(b_);
var ky = {}
  , Ma = {};
Object.defineProperty(Ma, "__esModule", {
    value: !0
});
Ma.version = void 0;
Ma.version = "2.87.1";
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.DEFAULT_REALTIME_OPTIONS = t.DEFAULT_AUTH_OPTIONS = t.DEFAULT_DB_OPTIONS = t.DEFAULT_GLOBAL_OPTIONS = t.DEFAULT_HEADERS = void 0;
    const e = Ma;
    let r = "";
    typeof Deno < "u" ? r = "deno" : typeof document < "u" ? r = "web" : typeof navigator < "u" && navigator.product === "ReactNative" ? r = "react-native" : r = "node",
    t.DEFAULT_HEADERS = {
        "X-Client-Info": `supabase-js-${r}/${e.version}`
    },
    t.DEFAULT_GLOBAL_OPTIONS = {
        headers: t.DEFAULT_HEADERS
    },
    t.DEFAULT_DB_OPTIONS = {
        schema: "public"
    },
    t.DEFAULT_AUTH_OPTIONS = {
        autoRefreshToken: !0,
        persistSession: !0,
        detectSessionInUrl: !0,
        flowType: "implicit"
    },
    t.DEFAULT_REALTIME_OPTIONS = {}
}
)(ky);
var Ey = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.fetchWithAuth = t.resolveHeadersConstructor = t.resolveFetch = void 0;
    const e = s => s ? (...i) => s(...i) : (...i) => fetch(...i);
    t.resolveFetch = e;
    const r = () => Headers;
    t.resolveHeadersConstructor = r;
    const n = (s, i, o) => {
        const a = (0,
        t.resolveFetch)(o)
          , l = (0,
        t.resolveHeadersConstructor)();
        return async (c, d) => {
            var h;
            const f = (h = await i()) !== null && h !== void 0 ? h : s;
            let p = new l(d == null ? void 0 : d.headers);
            return p.has("apikey") || p.set("apikey", s),
            p.has("Authorization") || p.set("Authorization", `Bearer ${f}`),
            a(c, Object.assign(Object.assign({}, d), {
                headers: p
            }))
        }
    }
    ;
    t.fetchWithAuth = n
}
)(Ey);
var Qr = {};
Object.defineProperty(Qr, "__esModule", {
    value: !0
});
Qr.isBrowser = void 0;
Qr.uuid = __;
Qr.ensureTrailingSlash = Cy;
Qr.applySettingDefaults = k_;
Qr.validateSupabaseUrl = E_;
function __() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(t) {
        var e = Math.random() * 16 | 0
          , r = t == "x" ? e : e & 3 | 8;
        return r.toString(16)
    })
}
function Cy(t) {
    return t.endsWith("/") ? t : t + "/"
}
const S_ = () => typeof window < "u";
Qr.isBrowser = S_;
function k_(t, e) {
    var r, n;
    const {db: s, auth: i, realtime: o, global: a} = t
      , {db: l, auth: c, realtime: d, global: h} = e
      , f = {
        db: Object.assign(Object.assign({}, l), s),
        auth: Object.assign(Object.assign({}, c), i),
        realtime: Object.assign(Object.assign({}, d), o),
        storage: {},
        global: Object.assign(Object.assign(Object.assign({}, h), a), {
            headers: Object.assign(Object.assign({}, (r = h == null ? void 0 : h.headers) !== null && r !== void 0 ? r : {}), (n = a == null ? void 0 : a.headers) !== null && n !== void 0 ? n : {})
        }),
        accessToken: async () => ""
    };
    return t.accessToken ? f.accessToken = t.accessToken : delete f.accessToken,
    f
}
function E_(t) {
    const e = t == null ? void 0 : t.trim();
    if (!e)
        throw new Error("supabaseUrl is required.");
    if (!e.match(/^https?:\/\//i))
        throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
    try {
        return new URL(Cy(e))
    } catch {
        throw Error("Invalid supabaseUrl: Provided URL is malformed.")
    }
}
var Wa = {};
const jy = "2.87.1"
  , Bn = 30 * 1e3
  , Ju = 3
  , Cl = Ju * Bn
  , C_ = "http://localhost:9999"
  , j_ = "supabase.auth.token"
  , T_ = {
    "X-Client-Info": `gotrue-js/${jy}`
}
  , Xu = "X-Supabase-Api-Version"
  , Ty = {
    "2024-01-01": {
        timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
        name: "2024-01-01"
    }
}
  , P_ = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i
  , O_ = 10 * 60 * 1e3;
let Os = class extends Error {
    constructor(e, r, n) {
        super(e),
        this.__isAuthError = !0,
        this.name = "AuthError",
        this.status = r,
        this.code = n
    }
}
;
function B(t) {
    return typeof t == "object" && t !== null && "__isAuthError"in t
}
let Py = class extends Os {
    constructor(e, r, n) {
        super(e, r, n),
        this.name = "AuthApiError",
        this.status = r,
        this.code = n
    }
}
;
function Oy(t) {
    return B(t) && t.name === "AuthApiError"
}
let xr = class extends Os {
    constructor(e, r) {
        super(e),
        this.name = "AuthUnknownError",
        this.originalError = r
    }
}
  , hr = class extends Os {
    constructor(e, r, n, s) {
        super(e, n, s),
        this.name = r,
        this.status = n
    }
}
  , it = class extends hr {
    constructor() {
        super("Auth session missing!", "AuthSessionMissingError", 400, void 0)
    }
}
;
function Ry(t) {
    return B(t) && t.name === "AuthSessionMissingError"
}
let tn = class extends hr {
    constructor() {
        super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0)
    }
}
  , ei = class extends hr {
    constructor(e) {
        super(e, "AuthInvalidCredentialsError", 400, void 0)
    }
}
  , ti = class extends hr {
    constructor(e, r=null) {
        super(e, "AuthImplicitGrantRedirectError", 500, void 0),
        this.details = null,
        this.details = r
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            details: this.details
        }
    }
}
;
function Ay(t) {
    return B(t) && t.name === "AuthImplicitGrantRedirectError"
}
let Yu = class extends hr {
    constructor(e, r=null) {
        super(e, "AuthPKCEGrantCodeExchangeError", 500, void 0),
        this.details = null,
        this.details = r
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            details: this.details
        }
    }
}
  , ga = class extends hr {
    constructor(e, r) {
        super(e, "AuthRetryableFetchError", r, void 0)
    }
}
;
function Do(t) {
    return B(t) && t.name === "AuthRetryableFetchError"
}
let Zu = class extends hr {
    constructor(e, r, n) {
        super(e, "AuthWeakPasswordError", r, "weak_password"),
        this.reasons = n
    }
}
;
function R_(t) {
    return B(t) && t.name === "AuthWeakPasswordError"
}
let ma = class extends hr {
    constructor(e) {
        super(e, "AuthInvalidJwtError", 400, "invalid_jwt")
    }
}
;
const ya = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split("")
  , sf = ` 	
\r=`.split("")
  , A_ = ( () => {
    const t = new Array(128);
    for (let e = 0; e < t.length; e += 1)
        t[e] = -1;
    for (let e = 0; e < sf.length; e += 1)
        t[sf[e].charCodeAt(0)] = -2;
    for (let e = 0; e < ya.length; e += 1)
        t[ya[e].charCodeAt(0)] = e;
    return t
}
)();
function of(t, e, r) {
    if (t !== null)
        for (e.queue = e.queue << 8 | t,
        e.queuedBits += 8; e.queuedBits >= 6; ) {
            const n = e.queue >> e.queuedBits - 6 & 63;
            r(ya[n]),
            e.queuedBits -= 6
        }
    else if (e.queuedBits > 0)
        for (e.queue = e.queue << 6 - e.queuedBits,
        e.queuedBits = 6; e.queuedBits >= 6; ) {
            const n = e.queue >> e.queuedBits - 6 & 63;
            r(ya[n]),
            e.queuedBits -= 6
        }
}
function Iy(t, e, r) {
    const n = A_[t];
    if (n > -1)
        for (e.queue = e.queue << 6 | n,
        e.queuedBits += 6; e.queuedBits >= 8; )
            r(e.queue >> e.queuedBits - 8 & 255),
            e.queuedBits -= 8;
    else {
        if (n === -2)
            return;
        throw new Error(`Invalid Base64-URL character "${String.fromCharCode(t)}"`)
    }
}
function af(t) {
    const e = []
      , r = o => {
        e.push(String.fromCodePoint(o))
    }
      , n = {
        utf8seq: 0,
        codepoint: 0
    }
      , s = {
        queue: 0,
        queuedBits: 0
    }
      , i = o => {
        L_(o, n, r)
    }
    ;
    for (let o = 0; o < t.length; o += 1)
        Iy(t.charCodeAt(o), s, i);
    return e.join("")
}
function I_(t, e) {
    if (t <= 127) {
        e(t);
        return
    } else if (t <= 2047) {
        e(192 | t >> 6),
        e(128 | t & 63);
        return
    } else if (t <= 65535) {
        e(224 | t >> 12),
        e(128 | t >> 6 & 63),
        e(128 | t & 63);
        return
    } else if (t <= 1114111) {
        e(240 | t >> 18),
        e(128 | t >> 12 & 63),
        e(128 | t >> 6 & 63),
        e(128 | t & 63);
        return
    }
    throw new Error(`Unrecognized Unicode codepoint: ${t.toString(16)}`)
}
function N_(t, e) {
    for (let r = 0; r < t.length; r += 1) {
        let n = t.charCodeAt(r);
        if (n > 55295 && n <= 56319) {
            const s = (n - 55296) * 1024 & 65535;
            n = (t.charCodeAt(r + 1) - 56320 & 65535 | s) + 65536,
            r += 1
        }
        I_(n, e)
    }
}
function L_(t, e, r) {
    if (e.utf8seq === 0) {
        if (t <= 127) {
            r(t);
            return
        }
        for (let n = 1; n < 6; n += 1)
            if (!(t >> 7 - n & 1)) {
                e.utf8seq = n;
                break
            }
        if (e.utf8seq === 2)
            e.codepoint = t & 31;
        else if (e.utf8seq === 3)
            e.codepoint = t & 15;
        else if (e.utf8seq === 4)
            e.codepoint = t & 7;
        else
            throw new Error("Invalid UTF-8 sequence");
        e.utf8seq -= 1
    } else if (e.utf8seq > 0) {
        if (t <= 127)
            throw new Error("Invalid UTF-8 sequence");
        e.codepoint = e.codepoint << 6 | t & 63,
        e.utf8seq -= 1,
        e.utf8seq === 0 && r(e.codepoint)
    }
}
function ls(t) {
    const e = []
      , r = {
        queue: 0,
        queuedBits: 0
    }
      , n = s => {
        e.push(s)
    }
    ;
    for (let s = 0; s < t.length; s += 1)
        Iy(t.charCodeAt(s), r, n);
    return new Uint8Array(e)
}
function D_(t) {
    const e = [];
    return N_(t, r => e.push(r)),
    new Uint8Array(e)
}
function dn(t) {
    const e = []
      , r = {
        queue: 0,
        queuedBits: 0
    }
      , n = s => {
        e.push(s)
    }
    ;
    return t.forEach(s => of(s, r, n)),
    of(null, r, n),
    e.join("")
}
function $_(t) {
    return Math.round(Date.now() / 1e3) + t
}
function U_() {
    return Symbol("auth-callback")
}
const $e = () => typeof window < "u" && typeof document < "u"
  , Xr = {
    tested: !1,
    writable: !1
}
  , Ny = () => {
    if (!$e())
        return !1;
    try {
        if (typeof globalThis.localStorage != "object")
            return !1
    } catch {
        return !1
    }
    if (Xr.tested)
        return Xr.writable;
    const t = `lswt-${Math.random()}${Math.random()}`;
    try {
        globalThis.localStorage.setItem(t, t),
        globalThis.localStorage.removeItem(t),
        Xr.tested = !0,
        Xr.writable = !0
    } catch {
        Xr.tested = !0,
        Xr.writable = !1
    }
    return Xr.writable
}
;
function F_(t) {
    const e = {}
      , r = new URL(t);
    if (r.hash && r.hash[0] === "#")
        try {
            new URLSearchParams(r.hash.substring(1)).forEach( (s, i) => {
                e[i] = s
            }
            )
        } catch {}
    return r.searchParams.forEach( (n, s) => {
        e[s] = n
    }
    ),
    e
}
const Ly = t => t ? (...e) => t(...e) : (...e) => fetch(...e)
  , B_ = t => typeof t == "object" && t !== null && "status"in t && "ok"in t && "json"in t && typeof t.json == "function"
  , zn = async (t, e, r) => {
    await t.setItem(e, JSON.stringify(r))
}
  , Yr = async (t, e) => {
    const r = await t.getItem(e);
    if (!r)
        return null;
    try {
        return JSON.parse(r)
    } catch {
        return r
    }
}
  , De = async (t, e) => {
    await t.removeItem(e)
}
;
class Ga {
    constructor() {
        this.promise = new Ga.promiseConstructor( (e, r) => {
            this.resolve = e,
            this.reject = r
        }
        )
    }
}
Ga.promiseConstructor = Promise;
function jl(t) {
    const e = t.split(".");
    if (e.length !== 3)
        throw new ma("Invalid JWT structure");
    for (let n = 0; n < e.length; n++)
        if (!P_.test(e[n]))
            throw new ma("JWT not in base64url format");
    return {
        header: JSON.parse(af(e[0])),
        payload: JSON.parse(af(e[1])),
        signature: ls(e[2]),
        raw: {
            header: e[0],
            payload: e[1]
        }
    }
}
async function z_(t) {
    return await new Promise(e => {
        setTimeout( () => e(null), t)
    }
    )
}
function M_(t, e) {
    return new Promise( (n, s) => {
        (async () => {
            for (let i = 0; i < 1 / 0; i++)
                try {
                    const o = await t(i);
                    if (!e(i, null, o)) {
                        n(o);
                        return
                    }
                } catch (o) {
                    if (!e(i, o)) {
                        s(o);
                        return
                    }
                }
        }
        )()
    }
    )
}
function W_(t) {
    return ("0" + t.toString(16)).substr(-2)
}
function G_() {
    const e = new Uint32Array(56);
    if (typeof crypto > "u") {
        const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
          , n = r.length;
        let s = "";
        for (let i = 0; i < 56; i++)
            s += r.charAt(Math.floor(Math.random() * n));
        return s
    }
    return crypto.getRandomValues(e),
    Array.from(e, W_).join("")
}
async function V_(t) {
    const r = new TextEncoder().encode(t)
      , n = await crypto.subtle.digest("SHA-256", r)
      , s = new Uint8Array(n);
    return Array.from(s).map(i => String.fromCharCode(i)).join("")
}
async function H_(t) {
    if (!(typeof crypto < "u" && typeof crypto.subtle < "u" && typeof TextEncoder < "u"))
        return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),
        t;
    const r = await V_(t);
    return btoa(r).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "")
}
async function Dn(t, e, r=!1) {
    const n = G_();
    let s = n;
    r && (s += "/PASSWORD_RECOVERY"),
    await zn(t, `${e}-code-verifier`, s);
    const i = await H_(n);
    return [i, n === i ? "plain" : "s256"]
}
const q_ = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function K_(t) {
    const e = t.headers.get(Xu);
    if (!e || !e.match(q_))
        return null;
    try {
        return new Date(`${e}T00:00:00.0Z`)
    } catch {
        return null
    }
}
function Q_(t) {
    if (!t)
        throw new Error("Missing exp claim");
    const e = Math.floor(Date.now() / 1e3);
    if (t <= e)
        throw new Error("JWT has expired")
}
function J_(t) {
    switch (t) {
    case "RS256":
        return {
            name: "RSASSA-PKCS1-v1_5",
            hash: {
                name: "SHA-256"
            }
        };
    case "ES256":
        return {
            name: "ECDSA",
            namedCurve: "P-256",
            hash: {
                name: "SHA-256"
            }
        };
    default:
        throw new Error("Invalid alg claim")
    }
}
const X_ = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
function $n(t) {
    if (!X_.test(t))
        throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")
}
function Tl() {
    const t = {};
    return new Proxy(t,{
        get: (e, r) => {
            if (r === "__isUserNotAvailableProxy")
                return !0;
            if (typeof r == "symbol") {
                const n = r.toString();
                if (n === "Symbol(Symbol.toPrimitive)" || n === "Symbol(Symbol.toStringTag)" || n === "Symbol(util.inspect.custom)")
                    return
            }
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${r}" property of the session object is not supported. Please use getUser() instead.`)
        }
        ,
        set: (e, r) => {
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${r}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)
        }
        ,
        deleteProperty: (e, r) => {
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${r}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)
        }
    })
}
function Y_(t, e) {
    return new Proxy(t,{
        get: (r, n, s) => {
            if (n === "__isInsecureUserWarningProxy")
                return !0;
            if (typeof n == "symbol") {
                const i = n.toString();
                if (i === "Symbol(Symbol.toPrimitive)" || i === "Symbol(Symbol.toStringTag)" || i === "Symbol(util.inspect.custom)" || i === "Symbol(nodejs.util.inspect.custom)")
                    return Reflect.get(r, n, s)
            }
            return !e.value && typeof n == "string" && (console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."),
            e.value = !0),
            Reflect.get(r, n, s)
        }
    })
}
function lf(t) {
    return JSON.parse(JSON.stringify(t))
}
const rn = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t)
  , Z_ = [502, 503, 504];
async function uf(t) {
    var e;
    if (!B_(t))
        throw new ga(rn(t),0);
    if (Z_.includes(t.status))
        throw new ga(rn(t),t.status);
    let r;
    try {
        r = await t.json()
    } catch (i) {
        throw new xr(rn(i),i)
    }
    let n;
    const s = K_(t);
    if (s && s.getTime() >= Ty["2024-01-01"].timestamp && typeof r == "object" && r && typeof r.code == "string" ? n = r.code : typeof r == "object" && r && typeof r.error_code == "string" && (n = r.error_code),
    n) {
        if (n === "weak_password")
            throw new Zu(rn(r),t.status,((e = r.weak_password) === null || e === void 0 ? void 0 : e.reasons) || []);
        if (n === "session_not_found")
            throw new it
    } else if (typeof r == "object" && r && typeof r.weak_password == "object" && r.weak_password && Array.isArray(r.weak_password.reasons) && r.weak_password.reasons.length && r.weak_password.reasons.reduce( (i, o) => i && typeof o == "string", !0))
        throw new Zu(rn(r),t.status,r.weak_password.reasons);
    throw new Py(rn(r),t.status || 500,n)
}
const eS = (t, e, r, n) => {
    const s = {
        method: t,
        headers: (e == null ? void 0 : e.headers) || {}
    };
    return t === "GET" ? s : (s.headers = Object.assign({
        "Content-Type": "application/json;charset=UTF-8"
    }, e == null ? void 0 : e.headers),
    s.body = JSON.stringify(n),
    Object.assign(Object.assign({}, s), r))
}
;
async function H(t, e, r, n) {
    var s;
    const i = Object.assign({}, n == null ? void 0 : n.headers);
    i[Xu] || (i[Xu] = Ty["2024-01-01"].name),
    n != null && n.jwt && (i.Authorization = `Bearer ${n.jwt}`);
    const o = (s = n == null ? void 0 : n.query) !== null && s !== void 0 ? s : {};
    n != null && n.redirectTo && (o.redirect_to = n.redirectTo);
    const a = Object.keys(o).length ? "?" + new URLSearchParams(o).toString() : ""
      , l = await tS(t, e, r + a, {
        headers: i,
        noResolveJson: n == null ? void 0 : n.noResolveJson
    }, {}, n == null ? void 0 : n.body);
    return n != null && n.xform ? n == null ? void 0 : n.xform(l) : {
        data: Object.assign({}, l),
        error: null
    }
}
async function tS(t, e, r, n, s, i) {
    const o = eS(e, n, s, i);
    let a;
    try {
        a = await t(r, Object.assign({}, o))
    } catch (l) {
        throw console.error(l),
        new ga(rn(l),0)
    }
    if (a.ok || await uf(a),
    n != null && n.noResolveJson)
        return a;
    try {
        return await a.json()
    } catch (l) {
        await uf(l)
    }
}
function Ot(t) {
    var e;
    let r = null;
    sS(t) && (r = Object.assign({}, t),
    t.expires_at || (r.expires_at = $_(t.expires_in)));
    const n = (e = t.user) !== null && e !== void 0 ? e : t;
    return {
        data: {
            session: r,
            user: n
        },
        error: null
    }
}
function cf(t) {
    const e = Ot(t);
    return !e.error && t.weak_password && typeof t.weak_password == "object" && Array.isArray(t.weak_password.reasons) && t.weak_password.reasons.length && t.weak_password.message && typeof t.weak_password.message == "string" && t.weak_password.reasons.reduce( (r, n) => r && typeof n == "string", !0) && (e.data.weak_password = t.weak_password),
    e
}
function _r(t) {
    var e;
    return {
        data: {
            user: (e = t.user) !== null && e !== void 0 ? e : t
        },
        error: null
    }
}
function rS(t) {
    return {
        data: t,
        error: null
    }
}
function nS(t) {
    const {action_link: e, email_otp: r, hashed_token: n, redirect_to: s, verification_type: i} = t
      , o = Ls(t, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"])
      , a = {
        action_link: e,
        email_otp: r,
        hashed_token: n,
        redirect_to: s,
        verification_type: i
    }
      , l = Object.assign({}, o);
    return {
        data: {
            properties: a,
            user: l
        },
        error: null
    }
}
function df(t) {
    return t
}
function sS(t) {
    return t.access_token && t.refresh_token && t.expires_in
}
const $o = ["global", "local", "others"];
let hd = class {
    constructor({url: e="", headers: r={}, fetch: n}) {
        this.url = e,
        this.headers = r,
        this.fetch = Ly(n),
        this.mfa = {
            listFactors: this._listFactors.bind(this),
            deleteFactor: this._deleteFactor.bind(this)
        },
        this.oauth = {
            listClients: this._listOAuthClients.bind(this),
            createClient: this._createOAuthClient.bind(this),
            getClient: this._getOAuthClient.bind(this),
            updateClient: this._updateOAuthClient.bind(this),
            deleteClient: this._deleteOAuthClient.bind(this),
            regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)
        }
    }
    async signOut(e, r=$o[0]) {
        if ($o.indexOf(r) < 0)
            throw new Error(`@supabase/auth-js: Parameter scope must be one of ${$o.join(", ")}`);
        try {
            return await H(this.fetch, "POST", `${this.url}/logout?scope=${r}`, {
                headers: this.headers,
                jwt: e,
                noResolveJson: !0
            }),
            {
                data: null,
                error: null
            }
        } catch (n) {
            if (B(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async inviteUserByEmail(e, r={}) {
        try {
            return await H(this.fetch, "POST", `${this.url}/invite`, {
                body: {
                    email: e,
                    data: r.data
                },
                headers: this.headers,
                redirectTo: r.redirectTo,
                xform: _r
            })
        } catch (n) {
            if (B(n))
                return {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async generateLink(e) {
        try {
            const {options: r} = e
              , n = Ls(e, ["options"])
              , s = Object.assign(Object.assign({}, n), r);
            return "newEmail"in n && (s.new_email = n == null ? void 0 : n.newEmail,
            delete s.newEmail),
            await H(this.fetch, "POST", `${this.url}/admin/generate_link`, {
                body: s,
                headers: this.headers,
                xform: nS,
                redirectTo: r == null ? void 0 : r.redirectTo
            })
        } catch (r) {
            if (B(r))
                return {
                    data: {
                        properties: null,
                        user: null
                    },
                    error: r
                };
            throw r
        }
    }
    async createUser(e) {
        try {
            return await H(this.fetch, "POST", `${this.url}/admin/users`, {
                body: e,
                headers: this.headers,
                xform: _r
            })
        } catch (r) {
            if (B(r))
                return {
                    data: {
                        user: null
                    },
                    error: r
                };
            throw r
        }
    }
    async listUsers(e) {
        var r, n, s, i, o, a, l;
        try {
            const c = {
                nextPage: null,
                lastPage: 0,
                total: 0
            }
              , d = await H(this.fetch, "GET", `${this.url}/admin/users`, {
                headers: this.headers,
                noResolveJson: !0,
                query: {
                    page: (n = (r = e == null ? void 0 : e.page) === null || r === void 0 ? void 0 : r.toString()) !== null && n !== void 0 ? n : "",
                    per_page: (i = (s = e == null ? void 0 : e.perPage) === null || s === void 0 ? void 0 : s.toString()) !== null && i !== void 0 ? i : ""
                },
                xform: df
            });
            if (d.error)
                throw d.error;
            const h = await d.json()
              , f = (o = d.headers.get("x-total-count")) !== null && o !== void 0 ? o : 0
              , p = (l = (a = d.headers.get("link")) === null || a === void 0 ? void 0 : a.split(",")) !== null && l !== void 0 ? l : [];
            return p.length > 0 && (p.forEach(v => {
                const w = parseInt(v.split(";")[0].split("=")[1].substring(0, 1))
                  , b = JSON.parse(v.split(";")[1].split("=")[1]);
                c[`${b}Page`] = w
            }
            ),
            c.total = parseInt(f)),
            {
                data: Object.assign(Object.assign({}, h), c),
                error: null
            }
        } catch (c) {
            if (B(c))
                return {
                    data: {
                        users: []
                    },
                    error: c
                };
            throw c
        }
    }
    async getUserById(e) {
        $n(e);
        try {
            return await H(this.fetch, "GET", `${this.url}/admin/users/${e}`, {
                headers: this.headers,
                xform: _r
            })
        } catch (r) {
            if (B(r))
                return {
                    data: {
                        user: null
                    },
                    error: r
                };
            throw r
        }
    }
    async updateUserById(e, r) {
        $n(e);
        try {
            return await H(this.fetch, "PUT", `${this.url}/admin/users/${e}`, {
                body: r,
                headers: this.headers,
                xform: _r
            })
        } catch (n) {
            if (B(n))
                return {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async deleteUser(e, r=!1) {
        $n(e);
        try {
            return await H(this.fetch, "DELETE", `${this.url}/admin/users/${e}`, {
                headers: this.headers,
                body: {
                    should_soft_delete: r
                },
                xform: _r
            })
        } catch (n) {
            if (B(n))
                return {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async _listFactors(e) {
        $n(e.userId);
        try {
            const {data: r, error: n} = await H(this.fetch, "GET", `${this.url}/admin/users/${e.userId}/factors`, {
                headers: this.headers,
                xform: s => ({
                    data: {
                        factors: s
                    },
                    error: null
                })
            });
            return {
                data: r,
                error: n
            }
        } catch (r) {
            if (B(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _deleteFactor(e) {
        $n(e.userId),
        $n(e.id);
        try {
            return {
                data: await H(this.fetch, "DELETE", `${this.url}/admin/users/${e.userId}/factors/${e.id}`, {
                    headers: this.headers
                }),
                error: null
            }
        } catch (r) {
            if (B(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _listOAuthClients(e) {
        var r, n, s, i, o, a, l;
        try {
            const c = {
                nextPage: null,
                lastPage: 0,
                total: 0
            }
              , d = await H(this.fetch, "GET", `${this.url}/admin/oauth/clients`, {
                headers: this.headers,
                noResolveJson: !0,
                query: {
                    page: (n = (r = e == null ? void 0 : e.page) === null || r === void 0 ? void 0 : r.toString()) !== null && n !== void 0 ? n : "",
                    per_page: (i = (s = e == null ? void 0 : e.perPage) === null || s === void 0 ? void 0 : s.toString()) !== null && i !== void 0 ? i : ""
                },
                xform: df
            });
            if (d.error)
                throw d.error;
            const h = await d.json()
              , f = (o = d.headers.get("x-total-count")) !== null && o !== void 0 ? o : 0
              , p = (l = (a = d.headers.get("link")) === null || a === void 0 ? void 0 : a.split(",")) !== null && l !== void 0 ? l : [];
            return p.length > 0 && (p.forEach(v => {
                const w = parseInt(v.split(";")[0].split("=")[1].substring(0, 1))
                  , b = JSON.parse(v.split(";")[1].split("=")[1]);
                c[`${b}Page`] = w
            }
            ),
            c.total = parseInt(f)),
            {
                data: Object.assign(Object.assign({}, h), c),
                error: null
            }
        } catch (c) {
            if (B(c))
                return {
                    data: {
                        clients: []
                    },
                    error: c
                };
            throw c
        }
    }
    async _createOAuthClient(e) {
        try {
            return await H(this.fetch, "POST", `${this.url}/admin/oauth/clients`, {
                body: e,
                headers: this.headers,
                xform: r => ({
                    data: r,
                    error: null
                })
            })
        } catch (r) {
            if (B(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _getOAuthClient(e) {
        try {
            return await H(this.fetch, "GET", `${this.url}/admin/oauth/clients/${e}`, {
                headers: this.headers,
                xform: r => ({
                    data: r,
                    error: null
                })
            })
        } catch (r) {
            if (B(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _updateOAuthClient(e, r) {
        try {
            return await H(this.fetch, "PUT", `${this.url}/admin/oauth/clients/${e}`, {
                body: r,
                headers: this.headers,
                xform: n => ({
                    data: n,
                    error: null
                })
            })
        } catch (n) {
            if (B(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async _deleteOAuthClient(e) {
        try {
            return await H(this.fetch, "DELETE", `${this.url}/admin/oauth/clients/${e}`, {
                headers: this.headers,
                noResolveJson: !0
            }),
            {
                data: null,
                error: null
            }
        } catch (r) {
            if (B(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _regenerateOAuthClientSecret(e) {
        try {
            return await H(this.fetch, "POST", `${this.url}/admin/oauth/clients/${e}/regenerate_secret`, {
                headers: this.headers,
                xform: r => ({
                    data: r,
                    error: null
                })
            })
        } catch (r) {
            if (B(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
}
;
function hf(t={}) {
    return {
        getItem: e => t[e] || null,
        setItem: (e, r) => {
            t[e] = r
        }
        ,
        removeItem: e => {
            delete t[e]
        }
    }
}
const nn = {
    debug: !!(globalThis && Ny() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
class fd extends Error {
    constructor(e) {
        super(e),
        this.isAcquireTimeout = !0
    }
}
let Dy = class extends fd {
}
;
class iS extends fd {
}
async function $y(t, e, r) {
    nn.debug && console.log("@supabase/gotrue-js: navigatorLock: acquire lock", t, e);
    const n = new globalThis.AbortController;
    return e > 0 && setTimeout( () => {
        n.abort(),
        nn.debug && console.log("@supabase/gotrue-js: navigatorLock acquire timed out", t)
    }
    , e),
    await Promise.resolve().then( () => globalThis.navigator.locks.request(t, e === 0 ? {
        mode: "exclusive",
        ifAvailable: !0
    } : {
        mode: "exclusive",
        signal: n.signal
    }, async s => {
        if (s) {
            nn.debug && console.log("@supabase/gotrue-js: navigatorLock: acquired", t, s.name);
            try {
                return await r()
            } finally {
                nn.debug && console.log("@supabase/gotrue-js: navigatorLock: released", t, s.name)
            }
        } else {
            if (e === 0)
                throw nn.debug && console.log("@supabase/gotrue-js: navigatorLock: not immediately available", t),
                new Dy(`Acquiring an exclusive Navigator LockManager lock "${t}" immediately failed`);
            if (nn.debug)
                try {
                    const i = await globalThis.navigator.locks.query();
                    console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(i, null, "  "))
                } catch (i) {
                    console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", i)
                }
            return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),
            await r()
        }
    }
    ))
}
const ff = {};
async function oS(t, e, r) {
    var n;
    const s = (n = ff[t]) !== null && n !== void 0 ? n : Promise.resolve()
      , i = Promise.race([s.catch( () => null), e >= 0 ? new Promise( (o, a) => {
        setTimeout( () => {
            a(new iS(`Acquring process lock with name "${t}" timed out`))
        }
        , e)
    }
    ) : null].filter(o => o)).catch(o => {
        if (o && o.isAcquireTimeout)
            throw o;
        return null
    }
    ).then(async () => await r());
    return ff[t] = i.catch(async o => {
        if (o && o.isAcquireTimeout)
            return await s,
            null;
        throw o
    }
    ),
    await i
}
function aS() {
    if (typeof globalThis != "object")
        try {
            Object.defineProperty(Object.prototype, "__magic__", {
                get: function() {
                    return this
                },
                configurable: !0
            }),
            __magic__.globalThis = __magic__,
            delete Object.prototype.__magic__
        } catch {
            typeof self < "u" && (self.globalThis = self)
        }
}
function Uy(t) {
    if (!/^0x[a-fA-F0-9]{40}$/.test(t))
        throw new Error(`@supabase/auth-js: Address "${t}" is invalid.`);
    return t.toLowerCase()
}
function lS(t) {
    return parseInt(t, 16)
}
function uS(t) {
    const e = new TextEncoder().encode(t);
    return "0x" + Array.from(e, n => n.toString(16).padStart(2, "0")).join("")
}
function cS(t) {
    var e;
    const {chainId: r, domain: n, expirationTime: s, issuedAt: i=new Date, nonce: o, notBefore: a, requestId: l, resources: c, scheme: d, uri: h, version: f} = t;
    {
        if (!Number.isInteger(r))
            throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${r}`);
        if (!n)
            throw new Error('@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.');
        if (o && o.length < 8)
            throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${o}`);
        if (!h)
            throw new Error('@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.');
        if (f !== "1")
            throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${f}`);
        if (!((e = t.statement) === null || e === void 0) && e.includes(`
`))
            throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${t.statement}`)
    }
    const p = Uy(t.address)
      , v = d ? `${d}://${n}` : n
      , w = t.statement ? `${t.statement}
` : ""
      , b = `${v} wants you to sign in with your Ethereum account:
${p}

${w}`;
    let g = `URI: ${h}
Version: ${f}
Chain ID: ${r}${o ? `
Nonce: ${o}` : ""}
Issued At: ${i.toISOString()}`;
    if (s && (g += `
Expiration Time: ${s.toISOString()}`),
    a && (g += `
Not Before: ${a.toISOString()}`),
    l && (g += `
Request ID: ${l}`),
    c) {
        let m = `
Resources:`;
        for (const y of c) {
            if (!y || typeof y != "string")
                throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${y}`);
            m += `
- ${y}`
        }
        g += m
    }
    return `${b}
${g}`
}
class je extends Error {
    constructor({message: e, code: r, cause: n, name: s}) {
        var i;
        super(e, {
            cause: n
        }),
        this.__isWebAuthnError = !0,
        this.name = (i = s ?? (n instanceof Error ? n.name : void 0)) !== null && i !== void 0 ? i : "Unknown Error",
        this.code = r
    }
}
class va extends je {
    constructor(e, r) {
        super({
            code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
            cause: r,
            message: e
        }),
        this.name = "WebAuthnUnknownError",
        this.originalError = r
    }
}
function dS({error: t, options: e}) {
    var r, n, s;
    const {publicKey: i} = e;
    if (!i)
        throw Error("options was missing required publicKey property");
    if (t.name === "AbortError") {
        if (e.signal instanceof AbortSignal)
            return new je({
                message: "Registration ceremony was sent an abort signal",
                code: "ERROR_CEREMONY_ABORTED",
                cause: t
            })
    } else if (t.name === "ConstraintError") {
        if (((r = i.authenticatorSelection) === null || r === void 0 ? void 0 : r.requireResidentKey) === !0)
            return new je({
                message: "Discoverable credentials were required but no available authenticator supported it",
                code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
                cause: t
            });
        if (e.mediation === "conditional" && ((n = i.authenticatorSelection) === null || n === void 0 ? void 0 : n.userVerification) === "required")
            return new je({
                message: "User verification was required during automatic registration but it could not be performed",
                code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
                cause: t
            });
        if (((s = i.authenticatorSelection) === null || s === void 0 ? void 0 : s.userVerification) === "required")
            return new je({
                message: "User verification was required but no available authenticator supported it",
                code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
                cause: t
            })
    } else {
        if (t.name === "InvalidStateError")
            return new je({
                message: "The authenticator was previously registered",
                code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
                cause: t
            });
        if (t.name === "NotAllowedError")
            return new je({
                message: t.message,
                code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
                cause: t
            });
        if (t.name === "NotSupportedError")
            return i.pubKeyCredParams.filter(a => a.type === "public-key").length === 0 ? new je({
                message: 'No entry in pubKeyCredParams was of type "public-key"',
                code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
                cause: t
            }) : new je({
                message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
                code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
                cause: t
            });
        if (t.name === "SecurityError") {
            const o = window.location.hostname;
            if (Fy(o)) {
                if (i.rp.id !== o)
                    return new je({
                        message: `The RP ID "${i.rp.id}" is invalid for this domain`,
                        code: "ERROR_INVALID_RP_ID",
                        cause: t
                    })
            } else
                return new je({
                    message: `${window.location.hostname} is an invalid domain`,
                    code: "ERROR_INVALID_DOMAIN",
                    cause: t
                })
        } else if (t.name === "TypeError") {
            if (i.user.id.byteLength < 1 || i.user.id.byteLength > 64)
                return new je({
                    message: "User ID was not between 1 and 64 characters",
                    code: "ERROR_INVALID_USER_ID_LENGTH",
                    cause: t
                })
        } else if (t.name === "UnknownError")
            return new je({
                message: "The authenticator was unable to process the specified options, or could not create a new credential",
                code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
                cause: t
            })
    }
    return new je({
        message: "a Non-Webauthn related error has occurred",
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: t
    })
}
function hS({error: t, options: e}) {
    const {publicKey: r} = e;
    if (!r)
        throw Error("options was missing required publicKey property");
    if (t.name === "AbortError") {
        if (e.signal instanceof AbortSignal)
            return new je({
                message: "Authentication ceremony was sent an abort signal",
                code: "ERROR_CEREMONY_ABORTED",
                cause: t
            })
    } else {
        if (t.name === "NotAllowedError")
            return new je({
                message: t.message,
                code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
                cause: t
            });
        if (t.name === "SecurityError") {
            const n = window.location.hostname;
            if (Fy(n)) {
                if (r.rpId !== n)
                    return new je({
                        message: `The RP ID "${r.rpId}" is invalid for this domain`,
                        code: "ERROR_INVALID_RP_ID",
                        cause: t
                    })
            } else
                return new je({
                    message: `${window.location.hostname} is an invalid domain`,
                    code: "ERROR_INVALID_DOMAIN",
                    cause: t
                })
        } else if (t.name === "UnknownError")
            return new je({
                message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
                code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
                cause: t
            })
    }
    return new je({
        message: "a Non-Webauthn related error has occurred",
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: t
    })
}
class fS {
    createNewAbortSignal() {
        if (this.controller) {
            const r = new Error("Cancelling existing WebAuthn API call for new one");
            r.name = "AbortError",
            this.controller.abort(r)
        }
        const e = new AbortController;
        return this.controller = e,
        e.signal
    }
    cancelCeremony() {
        if (this.controller) {
            const e = new Error("Manually cancelling existing WebAuthn API call");
            e.name = "AbortError",
            this.controller.abort(e),
            this.controller = void 0
        }
    }
}
const pS = new fS;
function gS(t) {
    if (!t)
        throw new Error("Credential creation options are required");
    if (typeof PublicKeyCredential < "u" && "parseCreationOptionsFromJSON"in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON == "function")
        return PublicKeyCredential.parseCreationOptionsFromJSON(t);
    const {challenge: e, user: r, excludeCredentials: n} = t
      , s = Ls(t, ["challenge", "user", "excludeCredentials"])
      , i = ls(e).buffer
      , o = Object.assign(Object.assign({}, r), {
        id: ls(r.id).buffer
    })
      , a = Object.assign(Object.assign({}, s), {
        challenge: i,
        user: o
    });
    if (n && n.length > 0) {
        a.excludeCredentials = new Array(n.length);
        for (let l = 0; l < n.length; l++) {
            const c = n[l];
            a.excludeCredentials[l] = Object.assign(Object.assign({}, c), {
                id: ls(c.id).buffer,
                type: c.type || "public-key",
                transports: c.transports
            })
        }
    }
    return a
}
function mS(t) {
    if (!t)
        throw new Error("Credential request options are required");
    if (typeof PublicKeyCredential < "u" && "parseRequestOptionsFromJSON"in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON == "function")
        return PublicKeyCredential.parseRequestOptionsFromJSON(t);
    const {challenge: e, allowCredentials: r} = t
      , n = Ls(t, ["challenge", "allowCredentials"])
      , s = ls(e).buffer
      , i = Object.assign(Object.assign({}, n), {
        challenge: s
    });
    if (r && r.length > 0) {
        i.allowCredentials = new Array(r.length);
        for (let o = 0; o < r.length; o++) {
            const a = r[o];
            i.allowCredentials[o] = Object.assign(Object.assign({}, a), {
                id: ls(a.id).buffer,
                type: a.type || "public-key",
                transports: a.transports
            })
        }
    }
    return i
}
function yS(t) {
    var e;
    if ("toJSON"in t && typeof t.toJSON == "function")
        return t.toJSON();
    const r = t;
    return {
        id: t.id,
        rawId: t.id,
        response: {
            attestationObject: dn(new Uint8Array(t.response.attestationObject)),
            clientDataJSON: dn(new Uint8Array(t.response.clientDataJSON))
        },
        type: "public-key",
        clientExtensionResults: t.getClientExtensionResults(),
        authenticatorAttachment: (e = r.authenticatorAttachment) !== null && e !== void 0 ? e : void 0
    }
}
function vS(t) {
    var e;
    if ("toJSON"in t && typeof t.toJSON == "function")
        return t.toJSON();
    const r = t
      , n = t.getClientExtensionResults()
      , s = t.response;
    return {
        id: t.id,
        rawId: t.id,
        response: {
            authenticatorData: dn(new Uint8Array(s.authenticatorData)),
            clientDataJSON: dn(new Uint8Array(s.clientDataJSON)),
            signature: dn(new Uint8Array(s.signature)),
            userHandle: s.userHandle ? dn(new Uint8Array(s.userHandle)) : void 0
        },
        type: "public-key",
        clientExtensionResults: n,
        authenticatorAttachment: (e = r.authenticatorAttachment) !== null && e !== void 0 ? e : void 0
    }
}
function Fy(t) {
    return t === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(t)
}
function pf() {
    var t, e;
    return !!($e() && "PublicKeyCredential"in window && window.PublicKeyCredential && "credentials"in navigator && typeof ((t = navigator == null ? void 0 : navigator.credentials) === null || t === void 0 ? void 0 : t.create) == "function" && typeof ((e = navigator == null ? void 0 : navigator.credentials) === null || e === void 0 ? void 0 : e.get) == "function")
}
async function wS(t) {
    try {
        const e = await navigator.credentials.create(t);
        return e ? e instanceof PublicKeyCredential ? {
            data: e,
            error: null
        } : {
            data: null,
            error: new va("Browser returned unexpected credential type",e)
        } : {
            data: null,
            error: new va("Empty credential response",e)
        }
    } catch (e) {
        return {
            data: null,
            error: dS({
                error: e,
                options: t
            })
        }
    }
}
async function bS(t) {
    try {
        const e = await navigator.credentials.get(t);
        return e ? e instanceof PublicKeyCredential ? {
            data: e,
            error: null
        } : {
            data: null,
            error: new va("Browser returned unexpected credential type",e)
        } : {
            data: null,
            error: new va("Empty credential response",e)
        }
    } catch (e) {
        return {
            data: null,
            error: hS({
                error: e,
                options: t
            })
        }
    }
}
const xS = {
    hints: ["security-key"],
    authenticatorSelection: {
        authenticatorAttachment: "cross-platform",
        requireResidentKey: !1,
        userVerification: "preferred",
        residentKey: "discouraged"
    },
    attestation: "direct"
}
  , _S = {
    userVerification: "preferred",
    hints: ["security-key"],
    attestation: "direct"
};
function wa(...t) {
    const e = s => s !== null && typeof s == "object" && !Array.isArray(s)
      , r = s => s instanceof ArrayBuffer || ArrayBuffer.isView(s)
      , n = {};
    for (const s of t)
        if (s)
            for (const i in s) {
                const o = s[i];
                if (o !== void 0)
                    if (Array.isArray(o))
                        n[i] = o;
                    else if (r(o))
                        n[i] = o;
                    else if (e(o)) {
                        const a = n[i];
                        e(a) ? n[i] = wa(a, o) : n[i] = wa(o)
                    } else
                        n[i] = o
            }
    return n
}
function SS(t, e) {
    return wa(xS, t, e || {})
}
function kS(t, e) {
    return wa(_S, t, e || {})
}
class ES {
    constructor(e) {
        this.client = e,
        this.enroll = this._enroll.bind(this),
        this.challenge = this._challenge.bind(this),
        this.verify = this._verify.bind(this),
        this.authenticate = this._authenticate.bind(this),
        this.register = this._register.bind(this)
    }
    async _enroll(e) {
        return this.client.mfa.enroll(Object.assign(Object.assign({}, e), {
            factorType: "webauthn"
        }))
    }
    async _challenge({factorId: e, webauthn: r, friendlyName: n, signal: s}, i) {
        try {
            const {data: o, error: a} = await this.client.mfa.challenge({
                factorId: e,
                webauthn: r
            });
            if (!o)
                return {
                    data: null,
                    error: a
                };
            const l = s ?? pS.createNewAbortSignal();
            if (o.webauthn.type === "create") {
                const {user: c} = o.webauthn.credential_options.publicKey;
                c.name || (c.name = `${c.id}:${n}`),
                c.displayName || (c.displayName = c.name)
            }
            switch (o.webauthn.type) {
            case "create":
                {
                    const c = SS(o.webauthn.credential_options.publicKey, i == null ? void 0 : i.create)
                      , {data: d, error: h} = await wS({
                        publicKey: c,
                        signal: l
                    });
                    return d ? {
                        data: {
                            factorId: e,
                            challengeId: o.id,
                            webauthn: {
                                type: o.webauthn.type,
                                credential_response: d
                            }
                        },
                        error: null
                    } : {
                        data: null,
                        error: h
                    }
                }
            case "request":
                {
                    const c = kS(o.webauthn.credential_options.publicKey, i == null ? void 0 : i.request)
                      , {data: d, error: h} = await bS(Object.assign(Object.assign({}, o.webauthn.credential_options), {
                        publicKey: c,
                        signal: l
                    }));
                    return d ? {
                        data: {
                            factorId: e,
                            challengeId: o.id,
                            webauthn: {
                                type: o.webauthn.type,
                                credential_response: d
                            }
                        },
                        error: null
                    } : {
                        data: null,
                        error: h
                    }
                }
            }
        } catch (o) {
            return B(o) ? {
                data: null,
                error: o
            } : {
                data: null,
                error: new xr("Unexpected error in challenge",o)
            }
        }
    }
    async _verify({challengeId: e, factorId: r, webauthn: n}) {
        return this.client.mfa.verify({
            factorId: r,
            challengeId: e,
            webauthn: n
        })
    }
    async _authenticate({factorId: e, webauthn: {rpId: r=typeof window < "u" ? window.location.hostname : void 0, rpOrigins: n=typeof window < "u" ? [window.location.origin] : void 0, signal: s}={}}, i) {
        if (!r)
            return {
                data: null,
                error: new Os("rpId is required for WebAuthn authentication")
            };
        try {
            if (!pf())
                return {
                    data: null,
                    error: new xr("Browser does not support WebAuthn",null)
                };
            const {data: o, error: a} = await this.challenge({
                factorId: e,
                webauthn: {
                    rpId: r,
                    rpOrigins: n
                },
                signal: s
            }, {
                request: i
            });
            if (!o)
                return {
                    data: null,
                    error: a
                };
            const {webauthn: l} = o;
            return this._verify({
                factorId: e,
                challengeId: o.challengeId,
                webauthn: {
                    type: l.type,
                    rpId: r,
                    rpOrigins: n,
                    credential_response: l.credential_response
                }
            })
        } catch (o) {
            return B(o) ? {
                data: null,
                error: o
            } : {
                data: null,
                error: new xr("Unexpected error in authenticate",o)
            }
        }
    }
    async _register({friendlyName: e, webauthn: {rpId: r=typeof window < "u" ? window.location.hostname : void 0, rpOrigins: n=typeof window < "u" ? [window.location.origin] : void 0, signal: s}={}}, i) {
        if (!r)
            return {
                data: null,
                error: new Os("rpId is required for WebAuthn registration")
            };
        try {
            if (!pf())
                return {
                    data: null,
                    error: new xr("Browser does not support WebAuthn",null)
                };
            const {data: o, error: a} = await this._enroll({
                friendlyName: e
            });
            if (!o)
                return await this.client.mfa.listFactors().then(d => {
                    var h;
                    return (h = d.data) === null || h === void 0 ? void 0 : h.all.find(f => f.factor_type === "webauthn" && f.friendly_name === e && f.status !== "unverified")
                }
                ).then(d => d ? this.client.mfa.unenroll({
                    factorId: d == null ? void 0 : d.id
                }) : void 0),
                {
                    data: null,
                    error: a
                };
            const {data: l, error: c} = await this._challenge({
                factorId: o.id,
                friendlyName: o.friendly_name,
                webauthn: {
                    rpId: r,
                    rpOrigins: n
                },
                signal: s
            }, {
                create: i
            });
            return l ? this._verify({
                factorId: o.id,
                challengeId: l.challengeId,
                webauthn: {
                    rpId: r,
                    rpOrigins: n,
                    type: l.webauthn.type,
                    credential_response: l.webauthn.credential_response
                }
            }) : {
                data: null,
                error: c
            }
        } catch (o) {
            return B(o) ? {
                data: null,
                error: o
            } : {
                data: null,
                error: new xr("Unexpected error in register",o)
            }
        }
    }
}
aS();
const CS = {
    url: C_,
    storageKey: j_,
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    headers: T_,
    flowType: "implicit",
    debug: !1,
    hasCustomAuthorizationHeader: !1,
    throwOnError: !1
};
async function gf(t, e, r) {
    return await r()
}
const Un = {};
let pd = class ec {
    get jwks() {
        var e, r;
        return (r = (e = Un[this.storageKey]) === null || e === void 0 ? void 0 : e.jwks) !== null && r !== void 0 ? r : {
            keys: []
        }
    }
    set jwks(e) {
        Un[this.storageKey] = Object.assign(Object.assign({}, Un[this.storageKey]), {
            jwks: e
        })
    }
    get jwks_cached_at() {
        var e, r;
        return (r = (e = Un[this.storageKey]) === null || e === void 0 ? void 0 : e.cachedAt) !== null && r !== void 0 ? r : Number.MIN_SAFE_INTEGER
    }
    set jwks_cached_at(e) {
        Un[this.storageKey] = Object.assign(Object.assign({}, Un[this.storageKey]), {
            cachedAt: e
        })
    }
    constructor(e) {
        var r, n, s;
        this.userStorage = null,
        this.memoryStorage = null,
        this.stateChangeEmitters = new Map,
        this.autoRefreshTicker = null,
        this.visibilityChangedCallback = null,
        this.refreshingDeferred = null,
        this.initializePromise = null,
        this.detectSessionInUrl = !0,
        this.hasCustomAuthorizationHeader = !1,
        this.suppressGetSessionWarning = !1,
        this.lockAcquired = !1,
        this.pendingInLock = [],
        this.broadcastChannel = null,
        this.logger = console.log;
        const i = Object.assign(Object.assign({}, CS), e);
        if (this.storageKey = i.storageKey,
        this.instanceID = (r = ec.nextInstanceID[this.storageKey]) !== null && r !== void 0 ? r : 0,
        ec.nextInstanceID[this.storageKey] = this.instanceID + 1,
        this.logDebugMessages = !!i.debug,
        typeof i.debug == "function" && (this.logger = i.debug),
        this.instanceID > 0 && $e()) {
            const o = `${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;
            console.warn(o),
            this.logDebugMessages && console.trace(o)
        }
        if (this.persistSession = i.persistSession,
        this.autoRefreshToken = i.autoRefreshToken,
        this.admin = new hd({
            url: i.url,
            headers: i.headers,
            fetch: i.fetch
        }),
        this.url = i.url,
        this.headers = i.headers,
        this.fetch = Ly(i.fetch),
        this.lock = i.lock || gf,
        this.detectSessionInUrl = i.detectSessionInUrl,
        this.flowType = i.flowType,
        this.hasCustomAuthorizationHeader = i.hasCustomAuthorizationHeader,
        this.throwOnError = i.throwOnError,
        i.lock ? this.lock = i.lock : this.persistSession && $e() && (!((n = globalThis == null ? void 0 : globalThis.navigator) === null || n === void 0) && n.locks) ? this.lock = $y : this.lock = gf,
        this.jwks || (this.jwks = {
            keys: []
        },
        this.jwks_cached_at = Number.MIN_SAFE_INTEGER),
        this.mfa = {
            verify: this._verify.bind(this),
            enroll: this._enroll.bind(this),
            unenroll: this._unenroll.bind(this),
            challenge: this._challenge.bind(this),
            listFactors: this._listFactors.bind(this),
            challengeAndVerify: this._challengeAndVerify.bind(this),
            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),
            webauthn: new ES(this)
        },
        this.oauth = {
            getAuthorizationDetails: this._getAuthorizationDetails.bind(this),
            approveAuthorization: this._approveAuthorization.bind(this),
            denyAuthorization: this._denyAuthorization.bind(this),
            listGrants: this._listOAuthGrants.bind(this),
            revokeGrant: this._revokeOAuthGrant.bind(this)
        },
        this.persistSession ? (i.storage ? this.storage = i.storage : Ny() ? this.storage = globalThis.localStorage : (this.memoryStorage = {},
        this.storage = hf(this.memoryStorage)),
        i.userStorage && (this.userStorage = i.userStorage)) : (this.memoryStorage = {},
        this.storage = hf(this.memoryStorage)),
        $e() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
            try {
                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey)
            } catch (o) {
                console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", o)
            }
            (s = this.broadcastChannel) === null || s === void 0 || s.addEventListener("message", async o => {
                this._debug("received broadcast notification from other tab or client", o),
                await this._notifyAllSubscribers(o.data.event, o.data.session, !1)
            }
            )
        }
        this.initialize()
    }
    isThrowOnErrorEnabled() {
        return this.throwOnError
    }
    _returnResult(e) {
        if (this.throwOnError && e && e.error)
            throw e.error;
        return e
    }
    _logPrefix() {
        return `GoTrueClient@${this.storageKey}:${this.instanceID} (${jy}) ${new Date().toISOString()}`
    }
    _debug(...e) {
        return this.logDebugMessages && this.logger(this._logPrefix(), ...e),
        this
    }
    async initialize() {
        return this.initializePromise ? await this.initializePromise : (this.initializePromise = (async () => await this._acquireLock(-1, async () => await this._initialize()))(),
        await this.initializePromise)
    }
    async _initialize() {
        var e;
        try {
            let r = {}
              , n = "none";
            if ($e() && (r = F_(window.location.href),
            this._isImplicitGrantCallback(r) ? n = "implicit" : await this._isPKCECallback(r) && (n = "pkce")),
            $e() && this.detectSessionInUrl && n !== "none") {
                const {data: s, error: i} = await this._getSessionFromURL(r, n);
                if (i) {
                    if (this._debug("#_initialize()", "error detecting session from URL", i),
                    Ay(i)) {
                        const l = (e = i.details) === null || e === void 0 ? void 0 : e.code;
                        if (l === "identity_already_exists" || l === "identity_not_found" || l === "single_identity_not_deletable")
                            return {
                                error: i
                            }
                    }
                    return await this._removeSession(),
                    {
                        error: i
                    }
                }
                const {session: o, redirectType: a} = s;
                return this._debug("#_initialize()", "detected session in URL", o, "redirect type", a),
                await this._saveSession(o),
                setTimeout(async () => {
                    a === "recovery" ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", o) : await this._notifyAllSubscribers("SIGNED_IN", o)
                }
                , 0),
                {
                    error: null
                }
            }
            return await this._recoverAndRefresh(),
            {
                error: null
            }
        } catch (r) {
            return B(r) ? this._returnResult({
                error: r
            }) : this._returnResult({
                error: new xr("Unexpected error during initialization",r)
            })
        } finally {
            await this._handleVisibilityChange(),
            this._debug("#_initialize()", "end")
        }
    }
    async signInAnonymously(e) {
        var r, n, s;
        try {
            const i = await H(this.fetch, "POST", `${this.url}/signup`, {
                headers: this.headers,
                body: {
                    data: (n = (r = e == null ? void 0 : e.options) === null || r === void 0 ? void 0 : r.data) !== null && n !== void 0 ? n : {},
                    gotrue_meta_security: {
                        captcha_token: (s = e == null ? void 0 : e.options) === null || s === void 0 ? void 0 : s.captchaToken
                    }
                },
                xform: Ot
            })
              , {data: o, error: a} = i;
            if (a || !o)
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                });
            const l = o.session
              , c = o.user;
            return o.session && (await this._saveSession(o.session),
            await this._notifyAllSubscribers("SIGNED_IN", l)),
            this._returnResult({
                data: {
                    user: c,
                    session: l
                },
                error: null
            })
        } catch (i) {
            if (B(i))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                });
            throw i
        }
    }
    async signUp(e) {
        var r, n, s;
        try {
            let i;
            if ("email"in e) {
                const {email: d, password: h, options: f} = e;
                let p = null
                  , v = null;
                this.flowType === "pkce" && ([p,v] = await Dn(this.storage, this.storageKey)),
                i = await H(this.fetch, "POST", `${this.url}/signup`, {
                    headers: this.headers,
                    redirectTo: f == null ? void 0 : f.emailRedirectTo,
                    body: {
                        email: d,
                        password: h,
                        data: (r = f == null ? void 0 : f.data) !== null && r !== void 0 ? r : {},
                        gotrue_meta_security: {
                            captcha_token: f == null ? void 0 : f.captchaToken
                        },
                        code_challenge: p,
                        code_challenge_method: v
                    },
                    xform: Ot
                })
            } else if ("phone"in e) {
                const {phone: d, password: h, options: f} = e;
                i = await H(this.fetch, "POST", `${this.url}/signup`, {
                    headers: this.headers,
                    body: {
                        phone: d,
                        password: h,
                        data: (n = f == null ? void 0 : f.data) !== null && n !== void 0 ? n : {},
                        channel: (s = f == null ? void 0 : f.channel) !== null && s !== void 0 ? s : "sms",
                        gotrue_meta_security: {
                            captcha_token: f == null ? void 0 : f.captchaToken
                        }
                    },
                    xform: Ot
                })
            } else
                throw new ei("You must provide either an email or phone number and a password");
            const {data: o, error: a} = i;
            if (a || !o)
                return await De(this.storage, `${this.storageKey}-code-verifier`),
                this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                });
            const l = o.session
              , c = o.user;
            return o.session && (await this._saveSession(o.session),
            await this._notifyAllSubscribers("SIGNED_IN", l)),
            this._returnResult({
                data: {
                    user: c,
                    session: l
                },
                error: null
            })
        } catch (i) {
            if (await De(this.storage, `${this.storageKey}-code-verifier`),
            B(i))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                });
            throw i
        }
    }
    async signInWithPassword(e) {
        try {
            let r;
            if ("email"in e) {
                const {email: i, password: o, options: a} = e;
                r = await H(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
                    headers: this.headers,
                    body: {
                        email: i,
                        password: o,
                        gotrue_meta_security: {
                            captcha_token: a == null ? void 0 : a.captchaToken
                        }
                    },
                    xform: cf
                })
            } else if ("phone"in e) {
                const {phone: i, password: o, options: a} = e;
                r = await H(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
                    headers: this.headers,
                    body: {
                        phone: i,
                        password: o,
                        gotrue_meta_security: {
                            captcha_token: a == null ? void 0 : a.captchaToken
                        }
                    },
                    xform: cf
                })
            } else
                throw new ei("You must provide either an email or phone number and a password");
            const {data: n, error: s} = r;
            if (s)
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                });
            if (!n || !n.session || !n.user) {
                const i = new tn;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                })
            }
            return n.session && (await this._saveSession(n.session),
            await this._notifyAllSubscribers("SIGNED_IN", n.session)),
            this._returnResult({
                data: Object.assign({
                    user: n.user,
                    session: n.session
                }, n.weak_password ? {
                    weakPassword: n.weak_password
                } : null),
                error: s
            })
        } catch (r) {
            if (B(r))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                });
            throw r
        }
    }
    async signInWithOAuth(e) {
        var r, n, s, i;
        return await this._handleProviderSignIn(e.provider, {
            redirectTo: (r = e.options) === null || r === void 0 ? void 0 : r.redirectTo,
            scopes: (n = e.options) === null || n === void 0 ? void 0 : n.scopes,
            queryParams: (s = e.options) === null || s === void 0 ? void 0 : s.queryParams,
            skipBrowserRedirect: (i = e.options) === null || i === void 0 ? void 0 : i.skipBrowserRedirect
        })
    }
    async exchangeCodeForSession(e) {
        return await this.initializePromise,
        this._acquireLock(-1, async () => this._exchangeCodeForSession(e))
    }
    async signInWithWeb3(e) {
        const {chain: r} = e;
        switch (r) {
        case "ethereum":
            return await this.signInWithEthereum(e);
        case "solana":
            return await this.signInWithSolana(e);
        default:
            throw new Error(`@supabase/auth-js: Unsupported chain "${r}"`)
        }
    }
    async signInWithEthereum(e) {
        var r, n, s, i, o, a, l, c, d, h, f;
        let p, v;
        if ("message"in e)
            p = e.message,
            v = e.signature;
        else {
            const {chain: w, wallet: b, statement: g, options: m} = e;
            let y;
            if ($e())
                if (typeof b == "object")
                    y = b;
                else {
                    const z = window;
                    if ("ethereum"in z && typeof z.ethereum == "object" && "request"in z.ethereum && typeof z.ethereum.request == "function")
                        y = z.ethereum;
                    else
                        throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.")
                }
            else {
                if (typeof b != "object" || !(m != null && m.url))
                    throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
                y = b
            }
            const x = new URL((r = m == null ? void 0 : m.url) !== null && r !== void 0 ? r : window.location.href)
              , k = await y.request({
                method: "eth_requestAccounts"
            }).then(z => z).catch( () => {
                throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid")
            }
            );
            if (!k || k.length === 0)
                throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");
            const C = Uy(k[0]);
            let T = (n = m == null ? void 0 : m.signInWithEthereum) === null || n === void 0 ? void 0 : n.chainId;
            if (!T) {
                const z = await y.request({
                    method: "eth_chainId"
                });
                T = lS(z)
            }
            const I = {
                domain: x.host,
                address: C,
                statement: g,
                uri: x.href,
                version: "1",
                chainId: T,
                nonce: (s = m == null ? void 0 : m.signInWithEthereum) === null || s === void 0 ? void 0 : s.nonce,
                issuedAt: (o = (i = m == null ? void 0 : m.signInWithEthereum) === null || i === void 0 ? void 0 : i.issuedAt) !== null && o !== void 0 ? o : new Date,
                expirationTime: (a = m == null ? void 0 : m.signInWithEthereum) === null || a === void 0 ? void 0 : a.expirationTime,
                notBefore: (l = m == null ? void 0 : m.signInWithEthereum) === null || l === void 0 ? void 0 : l.notBefore,
                requestId: (c = m == null ? void 0 : m.signInWithEthereum) === null || c === void 0 ? void 0 : c.requestId,
                resources: (d = m == null ? void 0 : m.signInWithEthereum) === null || d === void 0 ? void 0 : d.resources
            };
            p = cS(I),
            v = await y.request({
                method: "personal_sign",
                params: [uS(p), C]
            })
        }
        try {
            const {data: w, error: b} = await H(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
                headers: this.headers,
                body: Object.assign({
                    chain: "ethereum",
                    message: p,
                    signature: v
                }, !((h = e.options) === null || h === void 0) && h.captchaToken ? {
                    gotrue_meta_security: {
                        captcha_token: (f = e.options) === null || f === void 0 ? void 0 : f.captchaToken
                    }
                } : null),
                xform: Ot
            });
            if (b)
                throw b;
            if (!w || !w.session || !w.user) {
                const g = new tn;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: g
                })
            }
            return w.session && (await this._saveSession(w.session),
            await this._notifyAllSubscribers("SIGNED_IN", w.session)),
            this._returnResult({
                data: Object.assign({}, w),
                error: b
            })
        } catch (w) {
            if (B(w))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: w
                });
            throw w
        }
    }
    async signInWithSolana(e) {
        var r, n, s, i, o, a, l, c, d, h, f, p;
        let v, w;
        if ("message"in e)
            v = e.message,
            w = e.signature;
        else {
            const {chain: b, wallet: g, statement: m, options: y} = e;
            let x;
            if ($e())
                if (typeof g == "object")
                    x = g;
                else {
                    const C = window;
                    if ("solana"in C && typeof C.solana == "object" && ("signIn"in C.solana && typeof C.solana.signIn == "function" || "signMessage"in C.solana && typeof C.solana.signMessage == "function"))
                        x = C.solana;
                    else
                        throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")
                }
            else {
                if (typeof g != "object" || !(y != null && y.url))
                    throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
                x = g
            }
            const k = new URL((r = y == null ? void 0 : y.url) !== null && r !== void 0 ? r : window.location.href);
            if ("signIn"in x && x.signIn) {
                const C = await x.signIn(Object.assign(Object.assign(Object.assign({
                    issuedAt: new Date().toISOString()
                }, y == null ? void 0 : y.signInWithSolana), {
                    version: "1",
                    domain: k.host,
                    uri: k.href
                }), m ? {
                    statement: m
                } : null));
                let T;
                if (Array.isArray(C) && C[0] && typeof C[0] == "object")
                    T = C[0];
                else if (C && typeof C == "object" && "signedMessage"in C && "signature"in C)
                    T = C;
                else
                    throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");
                if ("signedMessage"in T && "signature"in T && (typeof T.signedMessage == "string" || T.signedMessage instanceof Uint8Array) && T.signature instanceof Uint8Array)
                    v = typeof T.signedMessage == "string" ? T.signedMessage : new TextDecoder().decode(T.signedMessage),
                    w = T.signature;
                else
                    throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")
            } else {
                if (!("signMessage"in x) || typeof x.signMessage != "function" || !("publicKey"in x) || typeof x != "object" || !x.publicKey || !("toBase58"in x.publicKey) || typeof x.publicKey.toBase58 != "function")
                    throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");
                v = [`${k.host} wants you to sign in with your Solana account:`, x.publicKey.toBase58(), ...m ? ["", m, ""] : [""], "Version: 1", `URI: ${k.href}`, `Issued At: ${(s = (n = y == null ? void 0 : y.signInWithSolana) === null || n === void 0 ? void 0 : n.issuedAt) !== null && s !== void 0 ? s : new Date().toISOString()}`, ...!((i = y == null ? void 0 : y.signInWithSolana) === null || i === void 0) && i.notBefore ? [`Not Before: ${y.signInWithSolana.notBefore}`] : [], ...!((o = y == null ? void 0 : y.signInWithSolana) === null || o === void 0) && o.expirationTime ? [`Expiration Time: ${y.signInWithSolana.expirationTime}`] : [], ...!((a = y == null ? void 0 : y.signInWithSolana) === null || a === void 0) && a.chainId ? [`Chain ID: ${y.signInWithSolana.chainId}`] : [], ...!((l = y == null ? void 0 : y.signInWithSolana) === null || l === void 0) && l.nonce ? [`Nonce: ${y.signInWithSolana.nonce}`] : [], ...!((c = y == null ? void 0 : y.signInWithSolana) === null || c === void 0) && c.requestId ? [`Request ID: ${y.signInWithSolana.requestId}`] : [], ...!((h = (d = y == null ? void 0 : y.signInWithSolana) === null || d === void 0 ? void 0 : d.resources) === null || h === void 0) && h.length ? ["Resources", ...y.signInWithSolana.resources.map(T => `- ${T}`)] : []].join(`
`);
                const C = await x.signMessage(new TextEncoder().encode(v), "utf8");
                if (!C || !(C instanceof Uint8Array))
                    throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");
                w = C
            }
        }
        try {
            const {data: b, error: g} = await H(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
                headers: this.headers,
                body: Object.assign({
                    chain: "solana",
                    message: v,
                    signature: dn(w)
                }, !((f = e.options) === null || f === void 0) && f.captchaToken ? {
                    gotrue_meta_security: {
                        captcha_token: (p = e.options) === null || p === void 0 ? void 0 : p.captchaToken
                    }
                } : null),
                xform: Ot
            });
            if (g)
                throw g;
            if (!b || !b.session || !b.user) {
                const m = new tn;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: m
                })
            }
            return b.session && (await this._saveSession(b.session),
            await this._notifyAllSubscribers("SIGNED_IN", b.session)),
            this._returnResult({
                data: Object.assign({}, b),
                error: g
            })
        } catch (b) {
            if (B(b))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: b
                });
            throw b
        }
    }
    async _exchangeCodeForSession(e) {
        const r = await Yr(this.storage, `${this.storageKey}-code-verifier`)
          , [n,s] = (r ?? "").split("/");
        try {
            const {data: i, error: o} = await H(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
                headers: this.headers,
                body: {
                    auth_code: e,
                    code_verifier: n
                },
                xform: Ot
            });
            if (await De(this.storage, `${this.storageKey}-code-verifier`),
            o)
                throw o;
            if (!i || !i.session || !i.user) {
                const a = new tn;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null,
                        redirectType: null
                    },
                    error: a
                })
            }
            return i.session && (await this._saveSession(i.session),
            await this._notifyAllSubscribers("SIGNED_IN", i.session)),
            this._returnResult({
                data: Object.assign(Object.assign({}, i), {
                    redirectType: s ?? null
                }),
                error: o
            })
        } catch (i) {
            if (await De(this.storage, `${this.storageKey}-code-verifier`),
            B(i))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null,
                        redirectType: null
                    },
                    error: i
                });
            throw i
        }
    }
    async signInWithIdToken(e) {
        try {
            const {options: r, provider: n, token: s, access_token: i, nonce: o} = e
              , a = await H(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
                headers: this.headers,
                body: {
                    provider: n,
                    id_token: s,
                    access_token: i,
                    nonce: o,
                    gotrue_meta_security: {
                        captcha_token: r == null ? void 0 : r.captchaToken
                    }
                },
                xform: Ot
            })
              , {data: l, error: c} = a;
            if (c)
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: c
                });
            if (!l || !l.session || !l.user) {
                const d = new tn;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: d
                })
            }
            return l.session && (await this._saveSession(l.session),
            await this._notifyAllSubscribers("SIGNED_IN", l.session)),
            this._returnResult({
                data: l,
                error: c
            })
        } catch (r) {
            if (B(r))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                });
            throw r
        }
    }
    async signInWithOtp(e) {
        var r, n, s, i, o;
        try {
            if ("email"in e) {
                const {email: a, options: l} = e;
                let c = null
                  , d = null;
                this.flowType === "pkce" && ([c,d] = await Dn(this.storage, this.storageKey));
                const {error: h} = await H(this.fetch, "POST", `${this.url}/otp`, {
                    headers: this.headers,
                    body: {
                        email: a,
                        data: (r = l == null ? void 0 : l.data) !== null && r !== void 0 ? r : {},
                        create_user: (n = l == null ? void 0 : l.shouldCreateUser) !== null && n !== void 0 ? n : !0,
                        gotrue_meta_security: {
                            captcha_token: l == null ? void 0 : l.captchaToken
                        },
                        code_challenge: c,
                        code_challenge_method: d
                    },
                    redirectTo: l == null ? void 0 : l.emailRedirectTo
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: h
                })
            }
            if ("phone"in e) {
                const {phone: a, options: l} = e
                  , {data: c, error: d} = await H(this.fetch, "POST", `${this.url}/otp`, {
                    headers: this.headers,
                    body: {
                        phone: a,
                        data: (s = l == null ? void 0 : l.data) !== null && s !== void 0 ? s : {},
                        create_user: (i = l == null ? void 0 : l.shouldCreateUser) !== null && i !== void 0 ? i : !0,
                        gotrue_meta_security: {
                            captcha_token: l == null ? void 0 : l.captchaToken
                        },
                        channel: (o = l == null ? void 0 : l.channel) !== null && o !== void 0 ? o : "sms"
                    }
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null,
                        messageId: c == null ? void 0 : c.message_id
                    },
                    error: d
                })
            }
            throw new ei("You must provide either an email or phone number.")
        } catch (a) {
            if (await De(this.storage, `${this.storageKey}-code-verifier`),
            B(a))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                });
            throw a
        }
    }
    async verifyOtp(e) {
        var r, n;
        try {
            let s, i;
            "options"in e && (s = (r = e.options) === null || r === void 0 ? void 0 : r.redirectTo,
            i = (n = e.options) === null || n === void 0 ? void 0 : n.captchaToken);
            const {data: o, error: a} = await H(this.fetch, "POST", `${this.url}/verify`, {
                headers: this.headers,
                body: Object.assign(Object.assign({}, e), {
                    gotrue_meta_security: {
                        captcha_token: i
                    }
                }),
                redirectTo: s,
                xform: Ot
            });
            if (a)
                throw a;
            if (!o)
                throw new Error("An error occurred on token verification.");
            const l = o.session
              , c = o.user;
            return l != null && l.access_token && (await this._saveSession(l),
            await this._notifyAllSubscribers(e.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", l)),
            this._returnResult({
                data: {
                    user: c,
                    session: l
                },
                error: null
            })
        } catch (s) {
            if (B(s))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                });
            throw s
        }
    }
    async signInWithSSO(e) {
        var r, n, s, i, o;
        try {
            let a = null
              , l = null;
            this.flowType === "pkce" && ([a,l] = await Dn(this.storage, this.storageKey));
            const c = await H(this.fetch, "POST", `${this.url}/sso`, {
                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId"in e ? {
                    provider_id: e.providerId
                } : null), "domain"in e ? {
                    domain: e.domain
                } : null), {
                    redirect_to: (n = (r = e.options) === null || r === void 0 ? void 0 : r.redirectTo) !== null && n !== void 0 ? n : void 0
                }), !((s = e == null ? void 0 : e.options) === null || s === void 0) && s.captchaToken ? {
                    gotrue_meta_security: {
                        captcha_token: e.options.captchaToken
                    }
                } : null), {
                    skip_http_redirect: !0,
                    code_challenge: a,
                    code_challenge_method: l
                }),
                headers: this.headers,
                xform: rS
            });
            return !((i = c.data) === null || i === void 0) && i.url && $e() && !(!((o = e.options) === null || o === void 0) && o.skipBrowserRedirect) && window.location.assign(c.data.url),
            this._returnResult(c)
        } catch (a) {
            if (await De(this.storage, `${this.storageKey}-code-verifier`),
            B(a))
                return this._returnResult({
                    data: null,
                    error: a
                });
            throw a
        }
    }
    async reauthenticate() {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._reauthenticate())
    }
    async _reauthenticate() {
        try {
            return await this._useSession(async e => {
                const {data: {session: r}, error: n} = e;
                if (n)
                    throw n;
                if (!r)
                    throw new it;
                const {error: s} = await H(this.fetch, "GET", `${this.url}/reauthenticate`, {
                    headers: this.headers,
                    jwt: r.access_token
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                })
            }
            )
        } catch (e) {
            if (B(e))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: e
                });
            throw e
        }
    }
    async resend(e) {
        try {
            const r = `${this.url}/resend`;
            if ("email"in e) {
                const {email: n, type: s, options: i} = e
                  , {error: o} = await H(this.fetch, "POST", r, {
                    headers: this.headers,
                    body: {
                        email: n,
                        type: s,
                        gotrue_meta_security: {
                            captcha_token: i == null ? void 0 : i.captchaToken
                        }
                    },
                    redirectTo: i == null ? void 0 : i.emailRedirectTo
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: o
                })
            } else if ("phone"in e) {
                const {phone: n, type: s, options: i} = e
                  , {data: o, error: a} = await H(this.fetch, "POST", r, {
                    headers: this.headers,
                    body: {
                        phone: n,
                        type: s,
                        gotrue_meta_security: {
                            captcha_token: i == null ? void 0 : i.captchaToken
                        }
                    }
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null,
                        messageId: o == null ? void 0 : o.message_id
                    },
                    error: a
                })
            }
            throw new ei("You must provide either an email or phone number and a type")
        } catch (r) {
            if (B(r))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                });
            throw r
        }
    }
    async getSession() {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => this._useSession(async r => r))
    }
    async _acquireLock(e, r) {
        this._debug("#_acquireLock", "begin", e);
        try {
            if (this.lockAcquired) {
                const n = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve()
                  , s = (async () => (await n,
                await r()))();
                return this.pendingInLock.push((async () => {
                    try {
                        await s
                    } catch {}
                }
                )()),
                s
            }
            return await this.lock(`lock:${this.storageKey}`, e, async () => {
                this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
                try {
                    this.lockAcquired = !0;
                    const n = r();
                    for (this.pendingInLock.push((async () => {
                        try {
                            await n
                        } catch {}
                    }
                    )()),
                    await n; this.pendingInLock.length; ) {
                        const s = [...this.pendingInLock];
                        await Promise.all(s),
                        this.pendingInLock.splice(0, s.length)
                    }
                    return await n
                } finally {
                    this._debug("#_acquireLock", "lock released for storage key", this.storageKey),
                    this.lockAcquired = !1
                }
            }
            )
        } finally {
            this._debug("#_acquireLock", "end")
        }
    }
    async _useSession(e) {
        this._debug("#_useSession", "begin");
        try {
            const r = await this.__loadSession();
            return await e(r)
        } finally {
            this._debug("#_useSession", "end")
        }
    }
    async __loadSession() {
        this._debug("#__loadSession()", "begin"),
        this.lockAcquired || this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
        try {
            let e = null;
            const r = await Yr(this.storage, this.storageKey);
            if (this._debug("#getSession()", "session from storage", r),
            r !== null && (this._isValidSession(r) ? e = r : (this._debug("#getSession()", "session from storage is not valid"),
            await this._removeSession())),
            !e)
                return {
                    data: {
                        session: null
                    },
                    error: null
                };
            const n = e.expires_at ? e.expires_at * 1e3 - Date.now() < Cl : !1;
            if (this._debug("#__loadSession()", `session has${n ? "" : " not"} expired`, "expires_at", e.expires_at),
            !n) {
                if (this.userStorage) {
                    const o = await Yr(this.userStorage, this.storageKey + "-user");
                    o != null && o.user ? e.user = o.user : e.user = Tl()
                }
                if (this.storage.isServer && e.user && !e.user.__isUserNotAvailableProxy) {
                    const o = {
                        value: this.suppressGetSessionWarning
                    };
                    e.user = Y_(e.user, o),
                    o.value && (this.suppressGetSessionWarning = !0)
                }
                return {
                    data: {
                        session: e
                    },
                    error: null
                }
            }
            const {data: s, error: i} = await this._callRefreshToken(e.refresh_token);
            return i ? this._returnResult({
                data: {
                    session: null
                },
                error: i
            }) : this._returnResult({
                data: {
                    session: s
                },
                error: null
            })
        } finally {
            this._debug("#__loadSession()", "end")
        }
    }
    async getUser(e) {
        if (e)
            return await this._getUser(e);
        await this.initializePromise;
        const r = await this._acquireLock(-1, async () => await this._getUser());
        return r.data.user && (this.suppressGetSessionWarning = !0),
        r
    }
    async _getUser(e) {
        try {
            return e ? await H(this.fetch, "GET", `${this.url}/user`, {
                headers: this.headers,
                jwt: e,
                xform: _r
            }) : await this._useSession(async r => {
                var n, s, i;
                const {data: o, error: a} = r;
                if (a)
                    throw a;
                return !(!((n = o.session) === null || n === void 0) && n.access_token) && !this.hasCustomAuthorizationHeader ? {
                    data: {
                        user: null
                    },
                    error: new it
                } : await H(this.fetch, "GET", `${this.url}/user`, {
                    headers: this.headers,
                    jwt: (i = (s = o.session) === null || s === void 0 ? void 0 : s.access_token) !== null && i !== void 0 ? i : void 0,
                    xform: _r
                })
            }
            )
        } catch (r) {
            if (B(r))
                return Ry(r) && (await this._removeSession(),
                await De(this.storage, `${this.storageKey}-code-verifier`)),
                this._returnResult({
                    data: {
                        user: null
                    },
                    error: r
                });
            throw r
        }
    }
    async updateUser(e, r={}) {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._updateUser(e, r))
    }
    async _updateUser(e, r={}) {
        try {
            return await this._useSession(async n => {
                const {data: s, error: i} = n;
                if (i)
                    throw i;
                if (!s.session)
                    throw new it;
                const o = s.session;
                let a = null
                  , l = null;
                this.flowType === "pkce" && e.email != null && ([a,l] = await Dn(this.storage, this.storageKey));
                const {data: c, error: d} = await H(this.fetch, "PUT", `${this.url}/user`, {
                    headers: this.headers,
                    redirectTo: r == null ? void 0 : r.emailRedirectTo,
                    body: Object.assign(Object.assign({}, e), {
                        code_challenge: a,
                        code_challenge_method: l
                    }),
                    jwt: o.access_token,
                    xform: _r
                });
                if (d)
                    throw d;
                return o.user = c.user,
                await this._saveSession(o),
                await this._notifyAllSubscribers("USER_UPDATED", o),
                this._returnResult({
                    data: {
                        user: o.user
                    },
                    error: null
                })
            }
            )
        } catch (n) {
            if (await De(this.storage, `${this.storageKey}-code-verifier`),
            B(n))
                return this._returnResult({
                    data: {
                        user: null
                    },
                    error: n
                });
            throw n
        }
    }
    async setSession(e) {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._setSession(e))
    }
    async _setSession(e) {
        try {
            if (!e.access_token || !e.refresh_token)
                throw new it;
            const r = Date.now() / 1e3;
            let n = r
              , s = !0
              , i = null;
            const {payload: o} = jl(e.access_token);
            if (o.exp && (n = o.exp,
            s = n <= r),
            s) {
                const {data: a, error: l} = await this._callRefreshToken(e.refresh_token);
                if (l)
                    return this._returnResult({
                        data: {
                            user: null,
                            session: null
                        },
                        error: l
                    });
                if (!a)
                    return {
                        data: {
                            user: null,
                            session: null
                        },
                        error: null
                    };
                i = a
            } else {
                const {data: a, error: l} = await this._getUser(e.access_token);
                if (l)
                    throw l;
                i = {
                    access_token: e.access_token,
                    refresh_token: e.refresh_token,
                    user: a.user,
                    token_type: "bearer",
                    expires_in: n - r,
                    expires_at: n
                },
                await this._saveSession(i),
                await this._notifyAllSubscribers("SIGNED_IN", i)
            }
            return this._returnResult({
                data: {
                    user: i.user,
                    session: i
                },
                error: null
            })
        } catch (r) {
            if (B(r))
                return this._returnResult({
                    data: {
                        session: null,
                        user: null
                    },
                    error: r
                });
            throw r
        }
    }
    async refreshSession(e) {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._refreshSession(e))
    }
    async _refreshSession(e) {
        try {
            return await this._useSession(async r => {
                var n;
                if (!e) {
                    const {data: o, error: a} = r;
                    if (a)
                        throw a;
                    e = (n = o.session) !== null && n !== void 0 ? n : void 0
                }
                if (!(e != null && e.refresh_token))
                    throw new it;
                const {data: s, error: i} = await this._callRefreshToken(e.refresh_token);
                return i ? this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                }) : s ? this._returnResult({
                    data: {
                        user: s.user,
                        session: s
                    },
                    error: null
                }) : this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: null
                })
            }
            )
        } catch (r) {
            if (B(r))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                });
            throw r
        }
    }
    async _getSessionFromURL(e, r) {
        try {
            if (!$e())
                throw new ti("No browser detected.");
            if (e.error || e.error_description || e.error_code)
                throw new ti(e.error_description || "Error in URL with unspecified error_description",{
                    error: e.error || "unspecified_error",
                    code: e.error_code || "unspecified_code"
                });
            switch (r) {
            case "implicit":
                if (this.flowType === "pkce")
                    throw new Yu("Not a valid PKCE flow url.");
                break;
            case "pkce":
                if (this.flowType === "implicit")
                    throw new ti("Not a valid implicit grant flow url.");
                break;
            default:
            }
            if (r === "pkce") {
                if (this._debug("#_initialize()", "begin", "is PKCE flow", !0),
                !e.code)
                    throw new Yu("No code detected.");
                const {data: m, error: y} = await this._exchangeCodeForSession(e.code);
                if (y)
                    throw y;
                const x = new URL(window.location.href);
                return x.searchParams.delete("code"),
                window.history.replaceState(window.history.state, "", x.toString()),
                {
                    data: {
                        session: m.session,
                        redirectType: null
                    },
                    error: null
                }
            }
            const {provider_token: n, provider_refresh_token: s, access_token: i, refresh_token: o, expires_in: a, expires_at: l, token_type: c} = e;
            if (!i || !a || !o || !c)
                throw new ti("No session defined in URL");
            const d = Math.round(Date.now() / 1e3)
              , h = parseInt(a);
            let f = d + h;
            l && (f = parseInt(l));
            const p = f - d;
            p * 1e3 <= Bn && console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${p}s, should have been closer to ${h}s`);
            const v = f - h;
            d - v >= 120 ? console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", v, f, d) : d - v < 0 && console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", v, f, d);
            const {data: w, error: b} = await this._getUser(i);
            if (b)
                throw b;
            const g = {
                provider_token: n,
                provider_refresh_token: s,
                access_token: i,
                expires_in: h,
                expires_at: f,
                refresh_token: o,
                token_type: c,
                user: w.user
            };
            return window.location.hash = "",
            this._debug("#_getSessionFromURL()", "clearing window.location.hash"),
            this._returnResult({
                data: {
                    session: g,
                    redirectType: e.type
                },
                error: null
            })
        } catch (n) {
            if (B(n))
                return this._returnResult({
                    data: {
                        session: null,
                        redirectType: null
                    },
                    error: n
                });
            throw n
        }
    }
    _isImplicitGrantCallback(e) {
        return !!(e.access_token || e.error_description)
    }
    async _isPKCECallback(e) {
        const r = await Yr(this.storage, `${this.storageKey}-code-verifier`);
        return !!(e.code && r)
    }
    async signOut(e={
        scope: "global"
    }) {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._signOut(e))
    }
    async _signOut({scope: e}={
        scope: "global"
    }) {
        return await this._useSession(async r => {
            var n;
            const {data: s, error: i} = r;
            if (i)
                return this._returnResult({
                    error: i
                });
            const o = (n = s.session) === null || n === void 0 ? void 0 : n.access_token;
            if (o) {
                const {error: a} = await this.admin.signOut(o, e);
                if (a && !(Oy(a) && (a.status === 404 || a.status === 401 || a.status === 403)))
                    return this._returnResult({
                        error: a
                    })
            }
            return e !== "others" && (await this._removeSession(),
            await De(this.storage, `${this.storageKey}-code-verifier`)),
            this._returnResult({
                error: null
            })
        }
        )
    }
    onAuthStateChange(e) {
        const r = U_()
          , n = {
            id: r,
            callback: e,
            unsubscribe: () => {
                this._debug("#unsubscribe()", "state change callback with id removed", r),
                this.stateChangeEmitters.delete(r)
            }
        };
        return this._debug("#onAuthStateChange()", "registered callback with id", r),
        this.stateChangeEmitters.set(r, n),
        (async () => (await this.initializePromise,
        await this._acquireLock(-1, async () => {
            this._emitInitialSession(r)
        }
        )))(),
        {
            data: {
                subscription: n
            }
        }
    }
    async _emitInitialSession(e) {
        return await this._useSession(async r => {
            var n, s;
            try {
                const {data: {session: i}, error: o} = r;
                if (o)
                    throw o;
                await ((n = this.stateChangeEmitters.get(e)) === null || n === void 0 ? void 0 : n.callback("INITIAL_SESSION", i)),
                this._debug("INITIAL_SESSION", "callback id", e, "session", i)
            } catch (i) {
                await ((s = this.stateChangeEmitters.get(e)) === null || s === void 0 ? void 0 : s.callback("INITIAL_SESSION", null)),
                this._debug("INITIAL_SESSION", "callback id", e, "error", i),
                console.error(i)
            }
        }
        )
    }
    async resetPasswordForEmail(e, r={}) {
        let n = null
          , s = null;
        this.flowType === "pkce" && ([n,s] = await Dn(this.storage, this.storageKey, !0));
        try {
            return await H(this.fetch, "POST", `${this.url}/recover`, {
                body: {
                    email: e,
                    code_challenge: n,
                    code_challenge_method: s,
                    gotrue_meta_security: {
                        captcha_token: r.captchaToken
                    }
                },
                headers: this.headers,
                redirectTo: r.redirectTo
            })
        } catch (i) {
            if (await De(this.storage, `${this.storageKey}-code-verifier`),
            B(i))
                return this._returnResult({
                    data: null,
                    error: i
                });
            throw i
        }
    }
    async getUserIdentities() {
        var e;
        try {
            const {data: r, error: n} = await this.getUser();
            if (n)
                throw n;
            return this._returnResult({
                data: {
                    identities: (e = r.user.identities) !== null && e !== void 0 ? e : []
                },
                error: null
            })
        } catch (r) {
            if (B(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async linkIdentity(e) {
        return "token"in e ? this.linkIdentityIdToken(e) : this.linkIdentityOAuth(e)
    }
    async linkIdentityOAuth(e) {
        var r;
        try {
            const {data: n, error: s} = await this._useSession(async i => {
                var o, a, l, c, d;
                const {data: h, error: f} = i;
                if (f)
                    throw f;
                const p = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, e.provider, {
                    redirectTo: (o = e.options) === null || o === void 0 ? void 0 : o.redirectTo,
                    scopes: (a = e.options) === null || a === void 0 ? void 0 : a.scopes,
                    queryParams: (l = e.options) === null || l === void 0 ? void 0 : l.queryParams,
                    skipBrowserRedirect: !0
                });
                return await H(this.fetch, "GET", p, {
                    headers: this.headers,
                    jwt: (d = (c = h.session) === null || c === void 0 ? void 0 : c.access_token) !== null && d !== void 0 ? d : void 0
                })
            }
            );
            if (s)
                throw s;
            return $e() && !(!((r = e.options) === null || r === void 0) && r.skipBrowserRedirect) && window.location.assign(n == null ? void 0 : n.url),
            this._returnResult({
                data: {
                    provider: e.provider,
                    url: n == null ? void 0 : n.url
                },
                error: null
            })
        } catch (n) {
            if (B(n))
                return this._returnResult({
                    data: {
                        provider: e.provider,
                        url: null
                    },
                    error: n
                });
            throw n
        }
    }
    async linkIdentityIdToken(e) {
        return await this._useSession(async r => {
            var n;
            try {
                const {error: s, data: {session: i}} = r;
                if (s)
                    throw s;
                const {options: o, provider: a, token: l, access_token: c, nonce: d} = e
                  , h = await H(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
                    headers: this.headers,
                    jwt: (n = i == null ? void 0 : i.access_token) !== null && n !== void 0 ? n : void 0,
                    body: {
                        provider: a,
                        id_token: l,
                        access_token: c,
                        nonce: d,
                        link_identity: !0,
                        gotrue_meta_security: {
                            captcha_token: o == null ? void 0 : o.captchaToken
                        }
                    },
                    xform: Ot
                })
                  , {data: f, error: p} = h;
                return p ? this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: p
                }) : !f || !f.session || !f.user ? this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: new tn
                }) : (f.session && (await this._saveSession(f.session),
                await this._notifyAllSubscribers("USER_UPDATED", f.session)),
                this._returnResult({
                    data: f,
                    error: p
                }))
            } catch (s) {
                if (await De(this.storage, `${this.storageKey}-code-verifier`),
                B(s))
                    return this._returnResult({
                        data: {
                            user: null,
                            session: null
                        },
                        error: s
                    });
                throw s
            }
        }
        )
    }
    async unlinkIdentity(e) {
        try {
            return await this._useSession(async r => {
                var n, s;
                const {data: i, error: o} = r;
                if (o)
                    throw o;
                return await H(this.fetch, "DELETE", `${this.url}/user/identities/${e.identity_id}`, {
                    headers: this.headers,
                    jwt: (s = (n = i.session) === null || n === void 0 ? void 0 : n.access_token) !== null && s !== void 0 ? s : void 0
                })
            }
            )
        } catch (r) {
            if (B(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async _refreshAccessToken(e) {
        const r = `#_refreshAccessToken(${e.substring(0, 5)}...)`;
        this._debug(r, "begin");
        try {
            const n = Date.now();
            return await M_(async s => (s > 0 && await z_(200 * Math.pow(2, s - 1)),
            this._debug(r, "refreshing attempt", s),
            await H(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
                body: {
                    refresh_token: e
                },
                headers: this.headers,
                xform: Ot
            })), (s, i) => {
                const o = 200 * Math.pow(2, s);
                return i && Do(i) && Date.now() + o - n < Bn
            }
            )
        } catch (n) {
            if (this._debug(r, "error", n),
            B(n))
                return this._returnResult({
                    data: {
                        session: null,
                        user: null
                    },
                    error: n
                });
            throw n
        } finally {
            this._debug(r, "end")
        }
    }
    _isValidSession(e) {
        return typeof e == "object" && e !== null && "access_token"in e && "refresh_token"in e && "expires_at"in e
    }
    async _handleProviderSignIn(e, r) {
        const n = await this._getUrlForProvider(`${this.url}/authorize`, e, {
            redirectTo: r.redirectTo,
            scopes: r.scopes,
            queryParams: r.queryParams
        });
        return this._debug("#_handleProviderSignIn()", "provider", e, "options", r, "url", n),
        $e() && !r.skipBrowserRedirect && window.location.assign(n),
        {
            data: {
                provider: e,
                url: n
            },
            error: null
        }
    }
    async _recoverAndRefresh() {
        var e, r;
        const n = "#_recoverAndRefresh()";
        this._debug(n, "begin");
        try {
            const s = await Yr(this.storage, this.storageKey);
            if (s && this.userStorage) {
                let o = await Yr(this.userStorage, this.storageKey + "-user");
                !this.storage.isServer && Object.is(this.storage, this.userStorage) && !o && (o = {
                    user: s.user
                },
                await zn(this.userStorage, this.storageKey + "-user", o)),
                s.user = (e = o == null ? void 0 : o.user) !== null && e !== void 0 ? e : Tl()
            } else if (s && !s.user && !s.user) {
                const o = await Yr(this.storage, this.storageKey + "-user");
                o && (o != null && o.user) ? (s.user = o.user,
                await De(this.storage, this.storageKey + "-user"),
                await zn(this.storage, this.storageKey, s)) : s.user = Tl()
            }
            if (this._debug(n, "session from storage", s),
            !this._isValidSession(s)) {
                this._debug(n, "session is not valid"),
                s !== null && await this._removeSession();
                return
            }
            const i = ((r = s.expires_at) !== null && r !== void 0 ? r : 1 / 0) * 1e3 - Date.now() < Cl;
            if (this._debug(n, `session has${i ? "" : " not"} expired with margin of ${Cl}s`),
            i) {
                if (this.autoRefreshToken && s.refresh_token) {
                    const {error: o} = await this._callRefreshToken(s.refresh_token);
                    o && (console.error(o),
                    Do(o) || (this._debug(n, "refresh failed with a non-retryable error, removing the session", o),
                    await this._removeSession()))
                }
            } else if (s.user && s.user.__isUserNotAvailableProxy === !0)
                try {
                    const {data: o, error: a} = await this._getUser(s.access_token);
                    !a && (o != null && o.user) ? (s.user = o.user,
                    await this._saveSession(s),
                    await this._notifyAllSubscribers("SIGNED_IN", s)) : this._debug(n, "could not get user data, skipping SIGNED_IN notification")
                } catch (o) {
                    console.error("Error getting user data:", o),
                    this._debug(n, "error getting user data, skipping SIGNED_IN notification", o)
                }
            else
                await this._notifyAllSubscribers("SIGNED_IN", s)
        } catch (s) {
            this._debug(n, "error", s),
            console.error(s);
            return
        } finally {
            this._debug(n, "end")
        }
    }
    async _callRefreshToken(e) {
        var r, n;
        if (!e)
            throw new it;
        if (this.refreshingDeferred)
            return this.refreshingDeferred.promise;
        const s = `#_callRefreshToken(${e.substring(0, 5)}...)`;
        this._debug(s, "begin");
        try {
            this.refreshingDeferred = new Ga;
            const {data: i, error: o} = await this._refreshAccessToken(e);
            if (o)
                throw o;
            if (!i.session)
                throw new it;
            await this._saveSession(i.session),
            await this._notifyAllSubscribers("TOKEN_REFRESHED", i.session);
            const a = {
                data: i.session,
                error: null
            };
            return this.refreshingDeferred.resolve(a),
            a
        } catch (i) {
            if (this._debug(s, "error", i),
            B(i)) {
                const o = {
                    data: null,
                    error: i
                };
                return Do(i) || await this._removeSession(),
                (r = this.refreshingDeferred) === null || r === void 0 || r.resolve(o),
                o
            }
            throw (n = this.refreshingDeferred) === null || n === void 0 || n.reject(i),
            i
        } finally {
            this.refreshingDeferred = null,
            this._debug(s, "end")
        }
    }
    async _notifyAllSubscribers(e, r, n=!0) {
        const s = `#_notifyAllSubscribers(${e})`;
        this._debug(s, "begin", r, `broadcast = ${n}`);
        try {
            this.broadcastChannel && n && this.broadcastChannel.postMessage({
                event: e,
                session: r
            });
            const i = []
              , o = Array.from(this.stateChangeEmitters.values()).map(async a => {
                try {
                    await a.callback(e, r)
                } catch (l) {
                    i.push(l)
                }
            }
            );
            if (await Promise.all(o),
            i.length > 0) {
                for (let a = 0; a < i.length; a += 1)
                    console.error(i[a]);
                throw i[0]
            }
        } finally {
            this._debug(s, "end")
        }
    }
    async _saveSession(e) {
        this._debug("#_saveSession()", e),
        this.suppressGetSessionWarning = !0,
        await De(this.storage, `${this.storageKey}-code-verifier`);
        const r = Object.assign({}, e)
          , n = r.user && r.user.__isUserNotAvailableProxy === !0;
        if (this.userStorage) {
            !n && r.user && await zn(this.userStorage, this.storageKey + "-user", {
                user: r.user
            });
            const s = Object.assign({}, r);
            delete s.user;
            const i = lf(s);
            await zn(this.storage, this.storageKey, i)
        } else {
            const s = lf(r);
            await zn(this.storage, this.storageKey, s)
        }
    }
    async _removeSession() {
        this._debug("#_removeSession()"),
        this.suppressGetSessionWarning = !1,
        await De(this.storage, this.storageKey),
        await De(this.storage, this.storageKey + "-code-verifier"),
        await De(this.storage, this.storageKey + "-user"),
        this.userStorage && await De(this.userStorage, this.storageKey + "-user"),
        await this._notifyAllSubscribers("SIGNED_OUT", null)
    }
    _removeVisibilityChangedCallback() {
        this._debug("#_removeVisibilityChangedCallback()");
        const e = this.visibilityChangedCallback;
        this.visibilityChangedCallback = null;
        try {
            e && $e() && (window != null && window.removeEventListener) && window.removeEventListener("visibilitychange", e)
        } catch (r) {
            console.error("removing visibilitychange callback failed", r)
        }
    }
    async _startAutoRefresh() {
        await this._stopAutoRefresh(),
        this._debug("#_startAutoRefresh()");
        const e = setInterval( () => this._autoRefreshTokenTick(), Bn);
        this.autoRefreshTicker = e,
        e && typeof e == "object" && typeof e.unref == "function" ? e.unref() : typeof Deno < "u" && typeof Deno.unrefTimer == "function" && Deno.unrefTimer(e),
        setTimeout(async () => {
            await this.initializePromise,
            await this._autoRefreshTokenTick()
        }
        , 0)
    }
    async _stopAutoRefresh() {
        this._debug("#_stopAutoRefresh()");
        const e = this.autoRefreshTicker;
        this.autoRefreshTicker = null,
        e && clearInterval(e)
    }
    async startAutoRefresh() {
        this._removeVisibilityChangedCallback(),
        await this._startAutoRefresh()
    }
    async stopAutoRefresh() {
        this._removeVisibilityChangedCallback(),
        await this._stopAutoRefresh()
    }
    async _autoRefreshTokenTick() {
        this._debug("#_autoRefreshTokenTick()", "begin");
        try {
            await this._acquireLock(0, async () => {
                try {
                    const e = Date.now();
                    try {
                        return await this._useSession(async r => {
                            const {data: {session: n}} = r;
                            if (!n || !n.refresh_token || !n.expires_at) {
                                this._debug("#_autoRefreshTokenTick()", "no session");
                                return
                            }
                            const s = Math.floor((n.expires_at * 1e3 - e) / Bn);
                            this._debug("#_autoRefreshTokenTick()", `access token expires in ${s} ticks, a tick lasts ${Bn}ms, refresh threshold is ${Ju} ticks`),
                            s <= Ju && await this._callRefreshToken(n.refresh_token)
                        }
                        )
                    } catch (r) {
                        console.error("Auto refresh tick failed with error. This is likely a transient error.", r)
                    }
                } finally {
                    this._debug("#_autoRefreshTokenTick()", "end")
                }
            }
            )
        } catch (e) {
            if (e.isAcquireTimeout || e instanceof fd)
                this._debug("auto refresh token tick lock not available");
            else
                throw e
        }
    }
    async _handleVisibilityChange() {
        if (this._debug("#_handleVisibilityChange()"),
        !$e() || !(window != null && window.addEventListener))
            return this.autoRefreshToken && this.startAutoRefresh(),
            !1;
        try {
            this.visibilityChangedCallback = async () => await this._onVisibilityChanged(!1),
            window == null || window.addEventListener("visibilitychange", this.visibilityChangedCallback),
            await this._onVisibilityChanged(!0)
        } catch (e) {
            console.error("_handleVisibilityChange", e)
        }
    }
    async _onVisibilityChanged(e) {
        const r = `#_onVisibilityChanged(${e})`;
        this._debug(r, "visibilityState", document.visibilityState),
        document.visibilityState === "visible" ? (this.autoRefreshToken && this._startAutoRefresh(),
        e || (await this.initializePromise,
        await this._acquireLock(-1, async () => {
            if (document.visibilityState !== "visible") {
                this._debug(r, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
                return
            }
            await this._recoverAndRefresh()
        }
        ))) : document.visibilityState === "hidden" && this.autoRefreshToken && this._stopAutoRefresh()
    }
    async _getUrlForProvider(e, r, n) {
        const s = [`provider=${encodeURIComponent(r)}`];
        if (n != null && n.redirectTo && s.push(`redirect_to=${encodeURIComponent(n.redirectTo)}`),
        n != null && n.scopes && s.push(`scopes=${encodeURIComponent(n.scopes)}`),
        this.flowType === "pkce") {
            const [i,o] = await Dn(this.storage, this.storageKey)
              , a = new URLSearchParams({
                code_challenge: `${encodeURIComponent(i)}`,
                code_challenge_method: `${encodeURIComponent(o)}`
            });
            s.push(a.toString())
        }
        if (n != null && n.queryParams) {
            const i = new URLSearchParams(n.queryParams);
            s.push(i.toString())
        }
        return n != null && n.skipBrowserRedirect && s.push(`skip_http_redirect=${n.skipBrowserRedirect}`),
        `${e}?${s.join("&")}`
    }
    async _unenroll(e) {
        try {
            return await this._useSession(async r => {
                var n;
                const {data: s, error: i} = r;
                return i ? this._returnResult({
                    data: null,
                    error: i
                }) : await H(this.fetch, "DELETE", `${this.url}/factors/${e.factorId}`, {
                    headers: this.headers,
                    jwt: (n = s == null ? void 0 : s.session) === null || n === void 0 ? void 0 : n.access_token
                })
            }
            )
        } catch (r) {
            if (B(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async _enroll(e) {
        try {
            return await this._useSession(async r => {
                var n, s;
                const {data: i, error: o} = r;
                if (o)
                    return this._returnResult({
                        data: null,
                        error: o
                    });
                const a = Object.assign({
                    friendly_name: e.friendlyName,
                    factor_type: e.factorType
                }, e.factorType === "phone" ? {
                    phone: e.phone
                } : e.factorType === "totp" ? {
                    issuer: e.issuer
                } : {})
                  , {data: l, error: c} = await H(this.fetch, "POST", `${this.url}/factors`, {
                    body: a,
                    headers: this.headers,
                    jwt: (n = i == null ? void 0 : i.session) === null || n === void 0 ? void 0 : n.access_token
                });
                return c ? this._returnResult({
                    data: null,
                    error: c
                }) : (e.factorType === "totp" && l.type === "totp" && (!((s = l == null ? void 0 : l.totp) === null || s === void 0) && s.qr_code) && (l.totp.qr_code = `data:image/svg+xml;utf-8,${l.totp.qr_code}`),
                this._returnResult({
                    data: l,
                    error: null
                }))
            }
            )
        } catch (r) {
            if (B(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async _verify(e) {
        return this._acquireLock(-1, async () => {
            try {
                return await this._useSession(async r => {
                    var n;
                    const {data: s, error: i} = r;
                    if (i)
                        return this._returnResult({
                            data: null,
                            error: i
                        });
                    const o = Object.assign({
                        challenge_id: e.challengeId
                    }, "webauthn"in e ? {
                        webauthn: Object.assign(Object.assign({}, e.webauthn), {
                            credential_response: e.webauthn.type === "create" ? yS(e.webauthn.credential_response) : vS(e.webauthn.credential_response)
                        })
                    } : {
                        code: e.code
                    })
                      , {data: a, error: l} = await H(this.fetch, "POST", `${this.url}/factors/${e.factorId}/verify`, {
                        body: o,
                        headers: this.headers,
                        jwt: (n = s == null ? void 0 : s.session) === null || n === void 0 ? void 0 : n.access_token
                    });
                    return l ? this._returnResult({
                        data: null,
                        error: l
                    }) : (await this._saveSession(Object.assign({
                        expires_at: Math.round(Date.now() / 1e3) + a.expires_in
                    }, a)),
                    await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", a),
                    this._returnResult({
                        data: a,
                        error: l
                    }))
                }
                )
            } catch (r) {
                if (B(r))
                    return this._returnResult({
                        data: null,
                        error: r
                    });
                throw r
            }
        }
        )
    }
    async _challenge(e) {
        return this._acquireLock(-1, async () => {
            try {
                return await this._useSession(async r => {
                    var n;
                    const {data: s, error: i} = r;
                    if (i)
                        return this._returnResult({
                            data: null,
                            error: i
                        });
                    const o = await H(this.fetch, "POST", `${this.url}/factors/${e.factorId}/challenge`, {
                        body: e,
                        headers: this.headers,
                        jwt: (n = s == null ? void 0 : s.session) === null || n === void 0 ? void 0 : n.access_token
                    });
                    if (o.error)
                        return o;
                    const {data: a} = o;
                    if (a.type !== "webauthn")
                        return {
                            data: a,
                            error: null
                        };
                    switch (a.webauthn.type) {
                    case "create":
                        return {
                            data: Object.assign(Object.assign({}, a), {
                                webauthn: Object.assign(Object.assign({}, a.webauthn), {
                                    credential_options: Object.assign(Object.assign({}, a.webauthn.credential_options), {
                                        publicKey: gS(a.webauthn.credential_options.publicKey)
                                    })
                                })
                            }),
                            error: null
                        };
                    case "request":
                        return {
                            data: Object.assign(Object.assign({}, a), {
                                webauthn: Object.assign(Object.assign({}, a.webauthn), {
                                    credential_options: Object.assign(Object.assign({}, a.webauthn.credential_options), {
                                        publicKey: mS(a.webauthn.credential_options.publicKey)
                                    })
                                })
                            }),
                            error: null
                        }
                    }
                }
                )
            } catch (r) {
                if (B(r))
                    return this._returnResult({
                        data: null,
                        error: r
                    });
                throw r
            }
        }
        )
    }
    async _challengeAndVerify(e) {
        const {data: r, error: n} = await this._challenge({
            factorId: e.factorId
        });
        return n ? this._returnResult({
            data: null,
            error: n
        }) : await this._verify({
            factorId: e.factorId,
            challengeId: r.id,
            code: e.code
        })
    }
    async _listFactors() {
        var e;
        const {data: {user: r}, error: n} = await this.getUser();
        if (n)
            return {
                data: null,
                error: n
            };
        const s = {
            all: [],
            phone: [],
            totp: [],
            webauthn: []
        };
        for (const i of (e = r == null ? void 0 : r.factors) !== null && e !== void 0 ? e : [])
            s.all.push(i),
            i.status === "verified" && s[i.factor_type].push(i);
        return {
            data: s,
            error: null
        }
    }
    async _getAuthenticatorAssuranceLevel() {
        var e, r;
        const {data: {session: n}, error: s} = await this.getSession();
        if (s)
            return this._returnResult({
                data: null,
                error: s
            });
        if (!n)
            return {
                data: {
                    currentLevel: null,
                    nextLevel: null,
                    currentAuthenticationMethods: []
                },
                error: null
            };
        const {payload: i} = jl(n.access_token);
        let o = null;
        i.aal && (o = i.aal);
        let a = o;
        ((r = (e = n.user.factors) === null || e === void 0 ? void 0 : e.filter(d => d.status === "verified")) !== null && r !== void 0 ? r : []).length > 0 && (a = "aal2");
        const c = i.amr || [];
        return {
            data: {
                currentLevel: o,
                nextLevel: a,
                currentAuthenticationMethods: c
            },
            error: null
        }
    }
    async _getAuthorizationDetails(e) {
        try {
            return await this._useSession(async r => {
                const {data: {session: n}, error: s} = r;
                return s ? this._returnResult({
                    data: null,
                    error: s
                }) : n ? await H(this.fetch, "GET", `${this.url}/oauth/authorizations/${e}`, {
                    headers: this.headers,
                    jwt: n.access_token,
                    xform: i => ({
                        data: i,
                        error: null
                    })
                }) : this._returnResult({
                    data: null,
                    error: new it
                })
            }
            )
        } catch (r) {
            if (B(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async _approveAuthorization(e, r) {
        try {
            return await this._useSession(async n => {
                const {data: {session: s}, error: i} = n;
                if (i)
                    return this._returnResult({
                        data: null,
                        error: i
                    });
                if (!s)
                    return this._returnResult({
                        data: null,
                        error: new it
                    });
                const o = await H(this.fetch, "POST", `${this.url}/oauth/authorizations/${e}/consent`, {
                    headers: this.headers,
                    jwt: s.access_token,
                    body: {
                        action: "approve"
                    },
                    xform: a => ({
                        data: a,
                        error: null
                    })
                });
                return o.data && o.data.redirect_url && $e() && !(r != null && r.skipBrowserRedirect) && window.location.assign(o.data.redirect_url),
                o
            }
            )
        } catch (n) {
            if (B(n))
                return this._returnResult({
                    data: null,
                    error: n
                });
            throw n
        }
    }
    async _denyAuthorization(e, r) {
        try {
            return await this._useSession(async n => {
                const {data: {session: s}, error: i} = n;
                if (i)
                    return this._returnResult({
                        data: null,
                        error: i
                    });
                if (!s)
                    return this._returnResult({
                        data: null,
                        error: new it
                    });
                const o = await H(this.fetch, "POST", `${this.url}/oauth/authorizations/${e}/consent`, {
                    headers: this.headers,
                    jwt: s.access_token,
                    body: {
                        action: "deny"
                    },
                    xform: a => ({
                        data: a,
                        error: null
                    })
                });
                return o.data && o.data.redirect_url && $e() && !(r != null && r.skipBrowserRedirect) && window.location.assign(o.data.redirect_url),
                o
            }
            )
        } catch (n) {
            if (B(n))
                return this._returnResult({
                    data: null,
                    error: n
                });
            throw n
        }
    }
    async _listOAuthGrants() {
        try {
            return await this._useSession(async e => {
                const {data: {session: r}, error: n} = e;
                return n ? this._returnResult({
                    data: null,
                    error: n
                }) : r ? await H(this.fetch, "GET", `${this.url}/user/oauth/grants`, {
                    headers: this.headers,
                    jwt: r.access_token,
                    xform: s => ({
                        data: s,
                        error: null
                    })
                }) : this._returnResult({
                    data: null,
                    error: new it
                })
            }
            )
        } catch (e) {
            if (B(e))
                return this._returnResult({
                    data: null,
                    error: e
                });
            throw e
        }
    }
    async _revokeOAuthGrant(e) {
        try {
            return await this._useSession(async r => {
                const {data: {session: n}, error: s} = r;
                return s ? this._returnResult({
                    data: null,
                    error: s
                }) : n ? (await H(this.fetch, "DELETE", `${this.url}/user/oauth/grants`, {
                    headers: this.headers,
                    jwt: n.access_token,
                    query: {
                        client_id: e.clientId
                    },
                    noResolveJson: !0
                }),
                {
                    data: {},
                    error: null
                }) : this._returnResult({
                    data: null,
                    error: new it
                })
            }
            )
        } catch (r) {
            if (B(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async fetchJwk(e, r={
        keys: []
    }) {
        let n = r.keys.find(a => a.kid === e);
        if (n)
            return n;
        const s = Date.now();
        if (n = this.jwks.keys.find(a => a.kid === e),
        n && this.jwks_cached_at + O_ > s)
            return n;
        const {data: i, error: o} = await H(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, {
            headers: this.headers
        });
        if (o)
            throw o;
        return !i.keys || i.keys.length === 0 || (this.jwks = i,
        this.jwks_cached_at = s,
        n = i.keys.find(a => a.kid === e),
        !n) ? null : n
    }
    async getClaims(e, r={}) {
        try {
            let n = e;
            if (!n) {
                const {data: p, error: v} = await this.getSession();
                if (v || !p.session)
                    return this._returnResult({
                        data: null,
                        error: v
                    });
                n = p.session.access_token
            }
            const {header: s, payload: i, signature: o, raw: {header: a, payload: l}} = jl(n);
            r != null && r.allowExpired || Q_(i.exp);
            const c = !s.alg || s.alg.startsWith("HS") || !s.kid || !("crypto"in globalThis && "subtle"in globalThis.crypto) ? null : await this.fetchJwk(s.kid, r != null && r.keys ? {
                keys: r.keys
            } : r == null ? void 0 : r.jwks);
            if (!c) {
                const {error: p} = await this.getUser(n);
                if (p)
                    throw p;
                return {
                    data: {
                        claims: i,
                        header: s,
                        signature: o
                    },
                    error: null
                }
            }
            const d = J_(s.alg)
              , h = await crypto.subtle.importKey("jwk", c, d, !0, ["verify"]);
            if (!await crypto.subtle.verify(d, h, o, D_(`${a}.${l}`)))
                throw new ma("Invalid JWT signature");
            return {
                data: {
                    claims: i,
                    header: s,
                    signature: o
                },
                error: null
            }
        } catch (n) {
            if (B(n))
                return this._returnResult({
                    data: null,
                    error: n
                });
            throw n
        }
    }
}
;
pd.nextInstanceID = {};
const jS = hd
  , TS = pd
  , PS = Object.freeze(Object.defineProperty({
    __proto__: null,
    AuthAdminApi: jS,
    AuthApiError: Py,
    AuthClient: TS,
    AuthError: Os,
    AuthImplicitGrantRedirectError: ti,
    AuthInvalidCredentialsError: ei,
    AuthInvalidJwtError: ma,
    AuthInvalidTokenResponseError: tn,
    AuthPKCEGrantCodeExchangeError: Yu,
    AuthRetryableFetchError: ga,
    AuthSessionMissingError: it,
    AuthUnknownError: xr,
    AuthWeakPasswordError: Zu,
    CustomAuthError: hr,
    GoTrueAdminApi: hd,
    GoTrueClient: pd,
    NavigatorLockAcquireTimeoutError: Dy,
    SIGN_OUT_SCOPES: $o,
    isAuthApiError: Oy,
    isAuthError: B,
    isAuthImplicitGrantRedirectError: Ay,
    isAuthRetryableFetchError: Do,
    isAuthSessionMissingError: Ry,
    isAuthWeakPasswordError: R_,
    lockInternals: nn,
    navigatorLock: $y,
    processLock: oS
}, Symbol.toStringTag, {
    value: "Module"
}))
  , By = Ui(PS);
Object.defineProperty(Wa, "__esModule", {
    value: !0
});
Wa.SupabaseAuthClient = void 0;
const OS = By;
class RS extends OS.AuthClient {
    constructor(e) {
        super(e)
    }
}
Wa.SupabaseAuthClient = RS;
Object.defineProperty(ca, "__esModule", {
    value: !0
});
const AS = Vm
  , IS = Ke
  , NS = cy
  , LS = x_
  , xo = ky
  , DS = Ey
  , mf = Qr
  , $S = Wa;
let US = class {
    constructor(e, r, n) {
        var s, i, o;
        this.supabaseUrl = e,
        this.supabaseKey = r;
        const a = (0,
        mf.validateSupabaseUrl)(e);
        if (!r)
            throw new Error("supabaseKey is required.");
        this.realtimeUrl = new URL("realtime/v1",a),
        this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws"),
        this.authUrl = new URL("auth/v1",a),
        this.storageUrl = new URL("storage/v1",a),
        this.functionsUrl = new URL("functions/v1",a);
        const l = `sb-${a.hostname.split(".")[0]}-auth-token`
          , c = {
            db: xo.DEFAULT_DB_OPTIONS,
            realtime: xo.DEFAULT_REALTIME_OPTIONS,
            auth: Object.assign(Object.assign({}, xo.DEFAULT_AUTH_OPTIONS), {
                storageKey: l
            }),
            global: xo.DEFAULT_GLOBAL_OPTIONS
        }
          , d = (0,
        mf.applySettingDefaults)(n ?? {}, c);
        this.storageKey = (s = d.auth.storageKey) !== null && s !== void 0 ? s : "",
        this.headers = (i = d.global.headers) !== null && i !== void 0 ? i : {},
        d.accessToken ? (this.accessToken = d.accessToken,
        this.auth = new Proxy({},{
            get: (h, f) => {
                throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(f)} is not possible`)
            }
        })) : this.auth = this._initSupabaseAuthClient((o = d.auth) !== null && o !== void 0 ? o : {}, this.headers, d.global.fetch),
        this.fetch = (0,
        DS.fetchWithAuth)(r, this._getAccessToken.bind(this), d.global.fetch),
        this.realtime = this._initRealtimeClient(Object.assign({
            headers: this.headers,
            accessToken: this._getAccessToken.bind(this)
        }, d.realtime)),
        this.accessToken && this.accessToken().then(h => this.realtime.setAuth(h)).catch(h => console.warn("Failed to set initial Realtime auth token:", h)),
        this.rest = new IS.PostgrestClient(new URL("rest/v1",a).href,{
            headers: this.headers,
            schema: d.db.schema,
            fetch: this.fetch
        }),
        this.storage = new LS.StorageClient(this.storageUrl.href,this.headers,this.fetch,n == null ? void 0 : n.storage),
        d.accessToken || this._listenForAuthEvents()
    }
    get functions() {
        return new AS.FunctionsClient(this.functionsUrl.href,{
            headers: this.headers,
            customFetch: this.fetch
        })
    }
    from(e) {
        return this.rest.from(e)
    }
    schema(e) {
        return this.rest.schema(e)
    }
    rpc(e, r={}, n={
        head: !1,
        get: !1,
        count: void 0
    }) {
        return this.rest.rpc(e, r, n)
    }
    channel(e, r={
        config: {}
    }) {
        return this.realtime.channel(e, r)
    }
    getChannels() {
        return this.realtime.getChannels()
    }
    removeChannel(e) {
        return this.realtime.removeChannel(e)
    }
    removeAllChannels() {
        return this.realtime.removeAllChannels()
    }
    async _getAccessToken() {
        var e, r;
        if (this.accessToken)
            return await this.accessToken();
        const {data: n} = await this.auth.getSession();
        return (r = (e = n.session) === null || e === void 0 ? void 0 : e.access_token) !== null && r !== void 0 ? r : this.supabaseKey
    }
    _initSupabaseAuthClient({autoRefreshToken: e, persistSession: r, detectSessionInUrl: n, storage: s, userStorage: i, storageKey: o, flowType: a, lock: l, debug: c, throwOnError: d}, h, f) {
        const p = {
            Authorization: `Bearer ${this.supabaseKey}`,
            apikey: `${this.supabaseKey}`
        };
        return new $S.SupabaseAuthClient({
            url: this.authUrl.href,
            headers: Object.assign(Object.assign({}, p), h),
            storageKey: o,
            autoRefreshToken: e,
            persistSession: r,
            detectSessionInUrl: n,
            storage: s,
            userStorage: i,
            flowType: a,
            lock: l,
            debug: c,
            throwOnError: d,
            fetch: f,
            hasCustomAuthorizationHeader: Object.keys(this.headers).some(v => v.toLowerCase() === "authorization")
        })
    }
    _initRealtimeClient(e) {
        return new NS.RealtimeClient(this.realtimeUrl.href,Object.assign(Object.assign({}, e), {
            params: Object.assign({
                apikey: this.supabaseKey
            }, e == null ? void 0 : e.params)
        }))
    }
    _listenForAuthEvents() {
        return this.auth.onAuthStateChange( (r, n) => {
            this._handleTokenChanged(r, "CLIENT", n == null ? void 0 : n.access_token)
        }
        )
    }
    _handleTokenChanged(e, r, n) {
        (e === "TOKEN_REFRESHED" || e === "SIGNED_IN") && this.changedAccessToken !== n ? (this.changedAccessToken = n,
        this.realtime.setAuth(n)) : e === "SIGNED_OUT" && (this.realtime.setAuth(),
        r == "STORAGE" && this.auth.signOut(),
        this.changedAccessToken = void 0)
    }
}
;
ca.default = US;
(function(t) {
    var e = In && In.__createBinding || (Object.create ? function(d, h, f, p) {
        p === void 0 && (p = f);
        var v = Object.getOwnPropertyDescriptor(h, f);
        (!v || ("get"in v ? !h.__esModule : v.writable || v.configurable)) && (v = {
            enumerable: !0,
            get: function() {
                return h[f]
            }
        }),
        Object.defineProperty(d, p, v)
    }
    : function(d, h, f, p) {
        p === void 0 && (p = f),
        d[p] = h[f]
    }
    )
      , r = In && In.__exportStar || function(d, h) {
        for (var f in d)
            f !== "default" && !Object.prototype.hasOwnProperty.call(h, f) && e(h, d, f)
    }
      , n = In && In.__importDefault || function(d) {
        return d && d.__esModule ? d : {
            default: d
        }
    }
    ;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.createClient = t.SupabaseClient = t.FunctionRegion = t.FunctionsError = t.FunctionsRelayError = t.FunctionsFetchError = t.FunctionsHttpError = t.PostgrestError = void 0;
    const s = n(ca);
    r(By, t);
    var i = Ke;
    Object.defineProperty(t, "PostgrestError", {
        enumerable: !0,
        get: function() {
            return i.PostgrestError
        }
    });
    var o = Vm;
    Object.defineProperty(t, "FunctionsHttpError", {
        enumerable: !0,
        get: function() {
            return o.FunctionsHttpError
        }
    }),
    Object.defineProperty(t, "FunctionsFetchError", {
        enumerable: !0,
        get: function() {
            return o.FunctionsFetchError
        }
    }),
    Object.defineProperty(t, "FunctionsRelayError", {
        enumerable: !0,
        get: function() {
            return o.FunctionsRelayError
        }
    }),
    Object.defineProperty(t, "FunctionsError", {
        enumerable: !0,
        get: function() {
            return o.FunctionsError
        }
    }),
    Object.defineProperty(t, "FunctionRegion", {
        enumerable: !0,
        get: function() {
            return o.FunctionRegion
        }
    }),
    r(cy, t);
    var a = ca;
    Object.defineProperty(t, "SupabaseClient", {
        enumerable: !0,
        get: function() {
            return n(a).default
        }
    });
    const l = (d, h, f) => new s.default(d,h,f);
    t.createClient = l;
    function c() {
        if (typeof window < "u" || typeof process > "u")
            return !1;
        const d = process.version;
        if (d == null)
            return !1;
        const h = d.match(/^v(\d+)\./);
        return h ? parseInt(h[1], 10) <= 18 : !1
    }
    c() && console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217")
}
)(id);
const zy = Tf(id)
  , FS = jf({
    __proto__: null,
    default: zy
}, [id])
  , {PostgrestError: xk, FunctionsHttpError: _k, FunctionsFetchError: Sk, FunctionsRelayError: kk, FunctionsError: Ek, FunctionRegion: Ck, SupabaseClient: jk, createClient: BS, GoTrueAdminApi: Tk, GoTrueClient: Pk, AuthAdminApi: Ok, AuthClient: Rk, navigatorLock: Ak, NavigatorLockAcquireTimeoutError: Ik, lockInternals: Nk, processLock: Lk, SIGN_OUT_SCOPES: Dk, AuthError: $k, AuthApiError: Uk, AuthUnknownError: Fk, CustomAuthError: Bk, AuthSessionMissingError: zk, AuthInvalidTokenResponseError: Mk, AuthInvalidCredentialsError: Wk, AuthImplicitGrantRedirectError: Gk, AuthPKCEGrantCodeExchangeError: Vk, AuthRetryableFetchError: Hk, AuthWeakPasswordError: qk, AuthInvalidJwtError: Kk, isAuthError: Qk, isAuthApiError: Jk, isAuthSessionMissingError: Xk, isAuthImplicitGrantRedirectError: Yk, isAuthRetryableFetchError: Zk, isAuthWeakPasswordError: e1, RealtimePresence: t1, RealtimeChannel: r1, RealtimeClient: n1, REALTIME_LISTEN_TYPES: s1, REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: i1, REALTIME_PRESENCE_LISTEN_EVENTS: o1, REALTIME_SUBSCRIBE_STATES: a1, REALTIME_CHANNEL_STATES: l1} = zy || FS
  , zS = "https://fvpapjdflprmkrqxkzkl.supabase.co"
  , MS = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ2cGFwamRmbHBybWtycXhremtsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU2NjIwNjEsImV4cCI6MjA4MTIzODA2MX0.Ps5MdzORDDZCeC1OlTZ0kpj0x_TOINn6x3JfEi0-vFc"
  , Fn = BS(zS, MS)
  , ri = {
    async create(t) {
        const {data: e, error: r} = await Fn.from("packages").insert([t]).select();
        if (r)
            throw r;
        return e
    },
    async getByCategory(t) {
        const {data: e, error: r} = await Fn.from("packages").select("*").eq("category", t).eq("enabled", !0).order("price", {
            ascending: !0
        });
        if (r)
            throw r;
        return e == null ? void 0 : e.map(n => ({
            id: n.id,
            dataAmount: `${n.data_amount}GB`,
            price: Number(n.price),
            deliveryTime: n.delivery_time,
            isEnabled: n.enabled
        }))
    },
    async update(t, e) {
        const {data: r, error: n} = await Fn.from("packages").update({
            ...e,
            updated_at: new Date
        }).eq("id", t).select();
        if (n)
            throw n;
        return r
    },
    async delete(t) {
        const {error: e} = await Fn.from("packages").delete().eq("id", t);
        if (e)
            throw e
    },
    async getAll(t) {
        const {data: e, error: r} = await Fn.from("packages").select("*").eq("category", t).order("price", {
            ascending: !0
        });
        if (r)
            throw r;
        return e == null ? void 0 : e.map(n => ({
            id: n.id,
            dataAmount: `${n.data_amount}GB`,
            price: Number(n.price),
            deliveryTime: n.delivery_time,
            isEnabled: n.enabled
        }))
    },
    async toggle(t, e) {
        const {data: r, error: n} = await Fn.from("packages").update({
            enabled: e,
            updated_at: new Date
        }).eq("id", t).select();
        if (n)
            throw n;
        return r
    }
};
function WS() {
    const [,t] = Rn()
      , [e,r] = j.useState([])
      , [n,s] = j.useState(!0)
      , [i,o] = j.useState("")
      , [a,l] = j.useState(null)
      , [c,d] = j.useState(!1)
      , [h,f] = j.useState(1.3)
      , [p,v] = j.useState([])
      , [w,b] = j.useState("")
      , [g,m] = j.useState(null)
      , [y,x] = j.useState(!1);
    j.useEffect( () => {
        C(),
        k()
    }
    , []);
    const k = () => {
        try {
            const M = localStorage.getItem("fastnetSettings");
            if (M) {
                const ne = JSON.parse(M);
                ne.transactionCharge && f(parseFloat(ne.transactionCharge))
            }
        } catch (M) {
            console.error("Error loading settings:", M)
        }
    }
      , C = async () => {
        try {
            s(!0);
            const M = await ri.getByCategory("fastnet");
            M && M.length > 0 && r(M)
        } catch (M) {
            console.error("Error loading packages from Supabase:", M)
        } finally {
            s(!1)
        }
    }
      , T = M => M + M * h / 100
      , I = async () => {
        if (!w) {
            alert("Please enter an order ID");
            return
        }
        x(!0);
        try {
            const M = await fetch(`/api/fastnet/orders/status/${w}`);
            if (M.ok) {
                const ne = await M.json();
                m({
                    shortId: ne.shortId || ne.short_id,
                    status: ne.status,
                    packageDetails: ne.packageDetails || ne.package_details,
                    createdAt: new Date(ne.createdAt || ne.created_at).toLocaleDateString()
                })
            } else
                m(null),
                alert("Order not found")
        } catch (M) {
            console.error("Status check error:", M),
            m(null),
            alert("Error checking status")
        } finally {
            x(!1)
        }
    }
      , z = () => {
        if (!i || !a) {
            alert("Please enter phone number and select a package");
            return
        }
        const M = {
            id: Date.now().toString(),
            pkg: a,
            phoneNumber: i
        };
        v([...p, M]),
        o(""),
        l(null)
    }
      , N = M => {
        v(p.filter(ne => ne.id !== M))
    }
      , Z = async () => {
        if (p.length === 0) {
            alert("Please add items to cart first");
            return
        }
        const M = "pk_live_574b7f2d8e5798fcab3221d292ef5fa8d28c204e";
        if (!window.PaystackPop) {
            alert("Payment system not loaded. Please refresh the page."),
            console.error("PaystackPop is not available");
            return
        }
        d(!0);
        const ne = p.reduce( (R, L) => R + L.pkg.price, 0)
          , Le = ne * (h / 100)
          , S = ne + Le;
        try {
            window.PaystackPop.setup({
                key: M,
                email: "customer@wirenet.com",
                amount: Math.ceil(S * 100),
                currency: "GHS",
                ref: `FN-BULK-${Date.now()}-${Math.floor(Math.random() * 1e3)}`,
                callback: function(L) {
                    console.log("Payment successful:", L.reference);
                    const O = [...p];
                    let W = 0;
                    (async () => {
                        for (const ue of O)
                            try {
                                (await fetch("/api/fastnet/purchase", {
                                    method: "POST",
                                    headers: {
                                        "Content-Type": "application/json"
                                    },
                                    body: JSON.stringify({
                                        phoneNumber: ue.phoneNumber,
                                        dataAmount: ue.pkg.dataAmount,
                                        price: ue.pkg.price,
                                        reference: L.reference
                                    })
                                })).ok && W++
                            } catch (We) {
                                console.error("Error creating order:", We)
                            }
                        alert(`Payment successful! ${W} order(s) created.`),
                        v([]),
                        o(""),
                        l(null),
                        d(!1)
                    }
                    )()
                },
                onClose: () => {
                    alert("Transaction cancelled"),
                    d(!1)
                }
            }).openIframe()
        } catch (R) {
            console.error("Paystack initialization error:", R),
            alert("Failed to initialize payment. Please try again."),
            d(!1)
        }
    }
      , V = p.reduce( (M, ne) => M + ne.pkg.price, 0)
      , he = V * (h / 100)
      , Me = V + he;
    return u.jsxs("div", {
        style: q.body,
        children: [u.jsxs("div", {
            style: q.header,
            children: [u.jsx("div", {
                style: q.headerTop,
                children: u.jsxs(se, {
                    variant: "ghost",
                    size: "sm",
                    onClick: () => t("/"),
                    style: {
                        marginBottom: "10px"
                    },
                    children: [u.jsx($a, {
                        size: 18,
                        style: {
                            marginRight: "8px"
                        }
                    }), "Back to WireNet"]
                })
            }), u.jsx("h1", {
                style: q.h1,
                children: "FastNet - NON-EXPIRY MTN DATA"
            }), u.jsx("p", {
                style: q.subtitle,
                children: "Super Fast Delivery - 5-20 Minutes"
            })]
        }), u.jsxs("div", {
            style: q.contactBar,
            children: [" Contact: ", u.jsx("a", {
                href: "tel:+233XXXXXXXXX",
                style: q.contactLink,
                children: "+233 XXX XXX XXX"
            }), " |  WhatsApp: ", u.jsx("a", {
                href: "https://wa.me/233XXXXXXXXX",
                style: q.contactLink,
                children: "Chat with us"
            })]
        }), u.jsxs("main", {
            style: q.main,
            children: [u.jsxs("div", {
                style: q.statusChecker,
                children: [u.jsx("h2", {
                    style: q.statusCheckerH2,
                    children: "Check Order Status"
                }), u.jsxs("div", {
                    style: q.statusCheckerForm,
                    children: [u.jsx(Ie, {
                        type: "text",
                        placeholder: "Enter Order ID",
                        value: w,
                        onChange: M => b(M.target.value),
                        style: q.input
                    }), u.jsx(se, {
                        onClick: I,
                        disabled: y,
                        style: q.statusButton,
                        children: y ? "Checking..." : "Check Status"
                    })]
                }), g && u.jsxs("div", {
                    style: q.statusReport,
                    children: [u.jsxs("p", {
                        children: [u.jsx("strong", {
                            children: "Order ID:"
                        }), " ", g.shortId]
                    }), u.jsxs("p", {
                        children: [u.jsx("strong", {
                            children: "Status:"
                        }), " ", g.status]
                    }), u.jsxs("p", {
                        children: [u.jsx("strong", {
                            children: "Package:"
                        }), " ", g.packageDetails]
                    }), u.jsxs("p", {
                        children: [u.jsx("strong", {
                            children: "Date:"
                        }), " ", g.createdAt]
                    })]
                })]
            }), u.jsx("h2", {
                style: q.sectionTitle,
                children: "Available Packages"
            }), n ? u.jsx("p", {
                style: q.loading,
                children: "Loading packages..."
            }) : e.length === 0 ? u.jsx("p", {
                style: q.loading,
                children: "No packages available"
            }) : u.jsx("div", {
                style: q.packagesGrid,
                children: e.map(M => u.jsxs("div", {
                    onClick: () => l(M),
                    style: {
                        ...q.packageCard,
                        ...(a == null ? void 0 : a.id) === M.id ? q.packageCardSelected : {}
                    },
                    children: [u.jsx("p", {
                        style: q.packageCardName,
                        children: M.dataAmount
                    }), u.jsxs("p", {
                        style: q.packageCardPrice,
                        children: ["GH", M.price]
                    }), u.jsxs("p", {
                        style: q.packageDelivery,
                        children: [" ", M.deliveryTime]
                    })]
                }, M.id))
            }), u.jsx("h2", {
                style: q.sectionTitle,
                children: "Purchase Data"
            }), u.jsxs("div", {
                style: q.purchaseSection,
                children: [u.jsxs("div", {
                    style: q.purchaseCard,
                    children: [u.jsx("h3", {
                        children: "Phone Number"
                    }), u.jsx(Ie, {
                        type: "tel",
                        placeholder: "Enter MTN number",
                        value: i,
                        onChange: M => o(M.target.value),
                        style: q.input
                    })]
                }), u.jsxs("div", {
                    style: q.purchaseCard,
                    children: [u.jsx("h3", {
                        children: "Selected Package"
                    }), a ? u.jsxs("div", {
                        style: q.selectedPackageInfo,
                        children: [u.jsx("p", {
                            style: q.packageName,
                            children: a.dataAmount
                        }), u.jsxs("p", {
                            style: q.packagePrice,
                            children: ["GH", a.price]
                        }), u.jsxs("p", {
                            style: q.packageTotal,
                            children: ["Total: GH", T(a.price).toFixed(2)]
                        })]
                    }) : u.jsx("p", {
                        style: q.noSelection,
                        children: "Select a package above"
                    })]
                }), u.jsxs("div", {
                    style: q.purchaseCard,
                    children: [u.jsx("h3", {
                        children: "Add to Cart"
                    }), u.jsxs(se, {
                        onClick: z,
                        disabled: !i || !a,
                        style: {
                            ...q.buyButton,
                            opacity: !i || !a ? .5 : 1
                        },
                        children: [u.jsx(ua, {
                            size: 18,
                            style: {
                                marginRight: "8px"
                            }
                        }), "Add to Cart"]
                    }), u.jsx("p", {
                        style: {
                            fontSize: "0.85em",
                            color: "#666",
                            marginTop: "10px",
                            textAlign: "center"
                        },
                        children: "Add items to cart, then pay for all at once"
                    })]
                })]
            }), p.length > 0 && u.jsxs("div", {
                style: q.cartSection,
                children: [u.jsxs("h2", {
                    style: q.sectionTitle,
                    children: [u.jsx(ua, {
                        size: 24,
                        style: {
                            marginRight: "10px",
                            verticalAlign: "middle"
                        }
                    }), "Your Cart (", p.length, ")"]
                }), u.jsx("div", {
                    style: q.cartList,
                    children: p.map(M => u.jsxs("div", {
                        style: q.cartItem,
                        children: [u.jsxs("div", {
                            children: [u.jsx("p", {
                                style: q.cartItemPhone,
                                children: M.phoneNumber
                            }), u.jsxs("p", {
                                style: q.cartItemPkg,
                                children: [M.pkg.dataAmount, " - GH", M.pkg.price]
                            })]
                        }), u.jsx("button", {
                            onClick: () => N(M.id),
                            style: q.removeButton,
                            children: u.jsx(Ua, {
                                size: 18
                            })
                        })]
                    }, M.id))
                }), u.jsxs("div", {
                    style: q.cartSummary,
                    children: [u.jsxs("div", {
                        style: q.summaryRow,
                        children: [u.jsx("span", {
                            children: "Subtotal:"
                        }), u.jsxs("span", {
                            children: ["GH", V.toFixed(2)]
                        })]
                    }), u.jsxs("div", {
                        style: q.summaryRow,
                        children: [u.jsxs("span", {
                            children: ["Fee (", h, "%):"]
                        }), u.jsxs("span", {
                            children: ["GH", he.toFixed(2)]
                        })]
                    }), u.jsxs("div", {
                        style: q.summaryTotal,
                        children: [u.jsx("span", {
                            children: "Total:"
                        }), u.jsxs("span", {
                            children: ["GH", Me.toFixed(2)]
                        })]
                    }), u.jsx(se, {
                        onClick: Z,
                        disabled: c,
                        style: q.checkoutButton,
                        children: c ? "Processing..." : `Pay GH${Me.toFixed(2)}`
                    })]
                })]
            })]
        }), u.jsx("button", {
            onClick: () => window.open("https://wa.me/233XXXXXXXXX", "_blank"),
            style: q.whatsappButton,
            title: "Chat on WhatsApp",
            children: u.jsx(nd, {
                size: 24
            })
        })]
    })
}
const q = {
    body: {
        fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
        margin: 0,
        padding: 0,
        backgroundColor: "#f0f4f8",
        color: "#333",
        minHeight: "100vh"
    },
    header: {
        backgroundColor: "white",
        boxShadow: "0 4px 15px rgba(0, 0, 0, 0.1)",
        padding: "20px",
        textAlign: "center",
        borderBottom: "3px solid #007bff"
    },
    headerTop: {
        textAlign: "left"
    },
    h1: {
        color: "#1a1a1a",
        marginBottom: "5px",
        fontSize: "2.5em"
    },
    subtitle: {
        color: "#007bff",
        fontSize: "1.1em",
        fontWeight: "500"
    },
    contactBar: {
        backgroundColor: "#007bff",
        color: "white",
        padding: "12px",
        textAlign: "center",
        borderRadius: "5px",
        margin: "20px"
    },
    contactLink: {
        color: "#ffcc00",
        textDecoration: "none",
        fontWeight: "bold"
    },
    main: {
        maxWidth: "1200px",
        margin: "0 auto",
        padding: "20px"
    },
    statusChecker: {
        backgroundColor: "#e3f2fd",
        padding: "20px",
        borderRadius: "8px",
        marginBottom: "30px",
        textAlign: "center",
        border: "1px solid #90caf9"
    },
    statusCheckerH2: {
        marginTop: 0,
        color: "#1565c0"
    },
    statusCheckerForm: {
        display: "flex",
        justifyContent: "center",
        gap: "10px",
        flexWrap: "wrap"
    },
    input: {
        padding: "10px",
        border: "1px solid #ccc",
        borderRadius: "5px",
        width: "200px"
    },
    statusButton: {
        padding: "10px 20px",
        backgroundColor: "#1565c0",
        color: "white",
        border: "none",
        borderRadius: "5px",
        cursor: "pointer"
    },
    statusReport: {
        marginTop: "15px",
        textAlign: "left",
        padding: "15px",
        backgroundColor: "#fff",
        borderRadius: "5px",
        maxWidth: "400px",
        margin: "15px auto 0"
    },
    sectionTitle: {
        fontSize: "1.8em",
        marginTop: "30px",
        marginBottom: "20px",
        color: "#1a1a1a"
    },
    purchaseSection: {
        display: "grid",
        gridTemplateColumns: "repeat(auto-fit, minmax(250px, 1fr))",
        gap: "20px",
        marginBottom: "30px"
    },
    purchaseCard: {
        padding: "20px",
        backgroundColor: "#fff",
        borderRadius: "8px",
        border: "1px solid #ddd",
        boxShadow: "0 2px 8px rgba(0, 0, 0, 0.05)"
    },
    selectedPackageInfo: {
        textAlign: "center"
    },
    packageName: {
        fontSize: "2em",
        fontWeight: "bold",
        color: "#007bff",
        margin: "10px 0"
    },
    packagePrice: {
        fontSize: "1.5em",
        fontWeight: "bold",
        color: "#1a1a1a"
    },
    packageTotal: {
        fontSize: "1.1em",
        color: "#28a745",
        marginTop: "10px",
        fontWeight: "bold"
    },
    noSelection: {
        color: "#999",
        textAlign: "center",
        padding: "20px 0"
    },
    buyButton: {
        width: "100%",
        padding: "12px",
        backgroundColor: "#007bff",
        color: "white",
        border: "none",
        borderRadius: "5px",
        cursor: "pointer",
        fontWeight: "bold",
        fontSize: "1.1em",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
    },
    loading: {
        textAlign: "center",
        color: "#666",
        padding: "40px"
    },
    packagesGrid: {
        display: "grid",
        gridTemplateColumns: "repeat(auto-fit, minmax(130px, 1fr))",
        gap: "15px",
        marginBottom: "30px"
    },
    packageCard: {
        padding: "20px",
        backgroundColor: "#fff",
        border: "2px solid #ddd",
        borderRadius: "10px",
        textAlign: "center",
        cursor: "pointer",
        transition: "all 0.3s",
        boxShadow: "0 2px 8px rgba(0, 0, 0, 0.05)"
    },
    packageCardSelected: {
        border: "2px solid #007bff",
        backgroundColor: "#e3f2fd",
        boxShadow: "0 0 15px rgba(0, 123, 255, 0.3)",
        transform: "scale(1.02)"
    },
    packageCardName: {
        fontSize: "1.4em",
        fontWeight: "bold",
        color: "#007bff",
        margin: "5px 0"
    },
    packageCardPrice: {
        fontSize: "1.2em",
        fontWeight: "bold",
        color: "#1a1a1a",
        margin: "5px 0"
    },
    packageDelivery: {
        fontSize: "0.85em",
        color: "#666",
        margin: "5px 0 0"
    },
    whatsappButton: {
        position: "fixed",
        bottom: "24px",
        right: "24px",
        backgroundColor: "#25D366",
        color: "white",
        border: "none",
        borderRadius: "50%",
        width: "56px",
        height: "56px",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        cursor: "pointer",
        boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
        zIndex: 50
    },
    cartSection: {
        backgroundColor: "white",
        padding: "25px",
        borderRadius: "10px",
        boxShadow: "0 4px 15px rgba(0, 0, 0, 0.1)",
        marginTop: "30px"
    },
    cartList: {
        marginBottom: "20px"
    },
    cartItem: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        padding: "12px",
        borderBottom: "1px solid #eee"
    },
    cartItemPhone: {
        fontWeight: "bold",
        margin: 0,
        color: "#1a1a1a"
    },
    cartItemPkg: {
        color: "#666",
        margin: 0,
        fontSize: "0.9em"
    },
    removeButton: {
        background: "none",
        border: "none",
        color: "#dc3545",
        cursor: "pointer",
        padding: "5px"
    },
    cartSummary: {
        borderTop: "2px solid #eee",
        paddingTop: "15px"
    },
    summaryRow: {
        display: "flex",
        justifyContent: "space-between",
        marginBottom: "8px",
        color: "#666"
    },
    summaryTotal: {
        display: "flex",
        justifyContent: "space-between",
        marginTop: "15px",
        marginBottom: "20px",
        fontSize: "1.3em",
        fontWeight: "bold",
        color: "#1a1a1a"
    },
    checkoutButton: {
        width: "100%",
        padding: "15px",
        backgroundColor: "#28a745",
        color: "white",
        border: "none",
        borderRadius: "5px",
        cursor: "pointer",
        fontWeight: "bold",
        fontSize: "1.2em"
    }
};
function GS() {
    const [,t] = Rn()
      , [e,r] = j.useState("orders")
      , [n,s] = j.useState([])
      , [i,o] = j.useState([])
      , [a,l] = j.useState({
        whatsAppLink: "",
        transactionCharge: "1.3"
    })
      , [c,d] = j.useState("ALL")
      , [h,f] = j.useState(new Set)
      , [p,v] = j.useState("")
      , [w,b] = j.useState("")
      , [g,m] = j.useState({
        name: "",
        gb: "",
        price: ""
    })
      , [y,x] = j.useState(null);
    j.useEffect( () => {
        k(),
        C(),
        T()
    }
    , []);
    const k = () => {
        try {
            const S = localStorage.getItem("datagodOrders");
            if (S) {
                const R = JSON.parse(S);
                s(R.map(L => ({
                    ...L,
                    createdAt: new Date(L.createdAt)
                })).sort( (L, O) => O.createdAt.getTime() - L.createdAt.getTime()))
            }
        } catch (S) {
            console.error("Error loading orders:", S)
        }
    }
      , C = () => {
        try {
            const S = localStorage.getItem("datagodPackages");
            if (S)
                o(JSON.parse(S).sort( (R, L) => R.dataValueGB - L.dataValueGB));
            else {
                const R = [{
                    id: "1",
                    packageName: "1GB",
                    dataValueGB: 1,
                    priceGHS: 2.5,
                    isEnabled: !0
                }, {
                    id: "2",
                    packageName: "2GB",
                    dataValueGB: 2,
                    priceGHS: 4.5,
                    isEnabled: !0
                }, {
                    id: "3",
                    packageName: "5GB",
                    dataValueGB: 5,
                    priceGHS: 10,
                    isEnabled: !0
                }, {
                    id: "4",
                    packageName: "10GB",
                    dataValueGB: 10,
                    priceGHS: 18,
                    isEnabled: !0
                }];
                localStorage.setItem("datagodPackages", JSON.stringify(R)),
                o(R.sort( (L, O) => L.dataValueGB - O.dataValueGB))
            }
        } catch (S) {
            console.error("Error loading packages:", S)
        }
    }
      , T = () => {
        try {
            const S = localStorage.getItem("wirenetSettings")
              , R = localStorage.getItem("datagodSettings");
            let L = ""
              , O = "1.3";
            S && (L = JSON.parse(S).whatsappLink || ""),
            R && (O = JSON.parse(R).transactionCharge || "1.3"),
            l({
                whatsAppLink: L,
                transactionCharge: O
            })
        } catch (S) {
            console.error("Error loading settings:", S)
        }
    }
      , I = () => c === "ALL" ? n : n.filter(S => S.status === c)
      , z = S => {
        const R = new Set(h);
        R.has(S) ? R.delete(S) : R.add(S),
        f(R)
    }
      , N = S => {
        f(S ? new Set(I().map(R => R.id)) : new Set)
    }
      , Z = () => {
        if (h.size === 0) {
            b(" Please select at least one order");
            return
        }
        if (!p) {
            b(" Please select a status");
            return
        }
        const S = n.map(R => h.has(R.id) ? {
            ...R,
            status: p,
            updatedAt: new Date
        } : R);
        s(S),
        localStorage.setItem("datagodOrders", JSON.stringify(S)),
        f(new Set),
        v(""),
        b(` ${h.size} orders updated to ${p}`),
        setTimeout( () => b(""), 3e3)
    }
      , V = (S, R) => {
        const L = n.map(O => O.id === S ? {
            ...O,
            status: R,
            updatedAt: new Date
        } : O);
        s(L),
        localStorage.setItem("datagodOrders", JSON.stringify(L)),
        b(" Order status updated"),
        setTimeout( () => b(""), 2e3)
    }
      , he = () => {
        if (!g.name || !g.gb || !g.price) {
            b(" Please fill all fields");
            return
        }
        const S = {
            id: Date.now().toString(),
            packageName: g.name,
            dataValueGB: parseFloat(g.gb),
            priceGHS: parseFloat(g.price),
            isEnabled: !0
        }
          , R = [...i, S].sort( (L, O) => L.dataValueGB - O.dataValueGB);
        o(R),
        localStorage.setItem("datagodPackages", JSON.stringify(R)),
        m({
            name: "",
            gb: "",
            price: ""
        }),
        b(" Package added"),
        setTimeout( () => b(""), 2e3)
    }
      , Me = S => {
        const R = i.filter(L => L.id !== S);
        o(R),
        localStorage.setItem("datagodPackages", JSON.stringify(R)),
        b(" Package deleted"),
        setTimeout( () => b(""), 2e3)
    }
      , M = S => {
        const R = i.map(L => L.id === S ? {
            ...L,
            isEnabled: !L.isEnabled
        } : L);
        o(R),
        localStorage.setItem("datagodPackages", JSON.stringify(R))
    }
      , ne = () => {
        const S = n.filter(ie => h.has(ie.id));
        if (S.length === 0) {
            b(" Please select orders to export");
            return
        }
        const R = [["Order ID", "Phone", "Package", "Price", "Status", "Date"].join(","), ...S.map(ie => [ie.shortId, ie.customerPhone, ie.packageDetails.replace("GB", ""), ie.packagePrice, ie.status, ie.createdAt.toLocaleDateString()].join(","))].join(`
`)
          , L = new Blob([R],{
            type: "text/csv"
        })
          , O = window.URL.createObjectURL(L)
          , W = document.createElement("a");
        W.href = O,
        W.download = `datagod-orders-${Date.now()}.csv`,
        W.click(),
        b(" Orders exported to CSV"),
        setTimeout( () => b(""), 2e3)
    }
      , Le = I();
    return u.jsxs("div", {
        style: D.body,
        children: [u.jsx("header", {
            style: D.header,
            children: u.jsxs("div", {
                style: D.headerContent,
                children: [u.jsxs(se, {
                    variant: "ghost",
                    size: "sm",
                    onClick: () => t("/admin"),
                    style: {
                        marginRight: "16px"
                    },
                    children: [u.jsx($a, {
                        size: 18,
                        style: {
                            marginRight: "8px"
                        }
                    }), "Back"]
                }), u.jsx("h1", {
                    style: D.h1,
                    children: "DataGod Admin Dashboard"
                })]
            })
        }), u.jsxs("main", {
            style: D.main,
            children: [w && u.jsx("div", {
                style: {
                    ...D.message,
                    backgroundColor: w.includes("") ? "#d4edda" : "#f8d7da",
                    color: w.includes("") ? "#155724" : "#721c24"
                },
                children: w
            }), u.jsxs("div", {
                style: D.tabs,
                children: [u.jsx("button", {
                    onClick: () => r("orders"),
                    style: {
                        ...D.tab,
                        borderBottom: e === "orders" ? "3px solid #ffcc00" : "none",
                        fontWeight: e === "orders" ? "bold" : "normal"
                    },
                    children: "Orders"
                }), u.jsx("button", {
                    onClick: () => r("packages"),
                    style: {
                        ...D.tab,
                        borderBottom: e === "packages" ? "3px solid #ffcc00" : "none",
                        fontWeight: e === "packages" ? "bold" : "normal"
                    },
                    children: "Packages"
                }), u.jsx("button", {
                    onClick: () => r("settings"),
                    style: {
                        ...D.tab,
                        borderBottom: e === "settings" ? "3px solid #ffcc00" : "none",
                        fontWeight: e === "settings" ? "bold" : "normal"
                    },
                    children: "Settings"
                })]
            }), e === "orders" && u.jsxs("div", {
                children: [u.jsxs(ve, {
                    style: D.card,
                    children: [u.jsx(Ze, {
                        children: u.jsx(et, {
                            children: "Order Management"
                        })
                    }), u.jsx(we, {
                        children: u.jsxs("div", {
                            style: D.filterSection,
                            children: [u.jsxs("div", {
                                style: D.filterGroup,
                                children: [u.jsx("label", {
                                    style: D.label,
                                    children: "Filter by Status:"
                                }), u.jsxs("select", {
                                    value: c,
                                    onChange: S => d(S.target.value),
                                    style: D.select,
                                    children: [u.jsx("option", {
                                        value: "ALL",
                                        children: "All Orders"
                                    }), u.jsx("option", {
                                        value: "PAID",
                                        children: "Paid"
                                    }), u.jsx("option", {
                                        value: "PROCESSING",
                                        children: "Processing"
                                    }), u.jsx("option", {
                                        value: "FULFILLED",
                                        children: "Fulfilled"
                                    }), u.jsx("option", {
                                        value: "CANCELLED",
                                        children: "Cancelled"
                                    })]
                                })]
                            }), u.jsxs("div", {
                                style: D.filterGroup,
                                children: [u.jsx("label", {
                                    style: D.label,
                                    children: "Bulk Status Change:"
                                }), u.jsxs("select", {
                                    value: p,
                                    onChange: S => v(S.target.value),
                                    style: D.select,
                                    children: [u.jsx("option", {
                                        value: "",
                                        children: "Select Status"
                                    }), u.jsx("option", {
                                        value: "PAID",
                                        children: "Paid"
                                    }), u.jsx("option", {
                                        value: "PROCESSING",
                                        children: "Processing"
                                    }), u.jsx("option", {
                                        value: "FULFILLED",
                                        children: "Fulfilled"
                                    }), u.jsx("option", {
                                        value: "CANCELLED",
                                        children: "Cancelled"
                                    })]
                                })]
                            }), u.jsxs(se, {
                                onClick: Z,
                                style: D.bulkButton,
                                children: ["Update (", h.size, ")"]
                            }), u.jsxs(se, {
                                onClick: ne,
                                style: D.exportButton,
                                children: [u.jsx(Lb, {
                                    size: 16,
                                    style: {
                                        marginRight: "8px"
                                    }
                                }), "Export CSV"]
                            })]
                        })
                    })]
                }), u.jsx(ve, {
                    style: D.card,
                    children: u.jsx(we, {
                        style: {
                            padding: "20px"
                        },
                        children: u.jsx("div", {
                            style: D.tableWrapper,
                            children: u.jsxs("table", {
                                style: D.table,
                                children: [u.jsx("thead", {
                                    children: u.jsxs("tr", {
                                        style: D.tableHeader,
                                        children: [u.jsx("th", {
                                            style: D.tableCell,
                                            children: u.jsx("input", {
                                                type: "checkbox",
                                                checked: h.size === Le.length && Le.length > 0,
                                                onChange: S => N(S.target.checked)
                                            })
                                        }), u.jsx("th", {
                                            style: D.tableCell,
                                            children: "Order ID"
                                        }), u.jsx("th", {
                                            style: D.tableCell,
                                            children: "Phone"
                                        }), u.jsx("th", {
                                            style: D.tableCell,
                                            children: "Package"
                                        }), u.jsx("th", {
                                            style: D.tableCell,
                                            children: "Price"
                                        }), u.jsx("th", {
                                            style: D.tableCell,
                                            children: "Status"
                                        }), u.jsx("th", {
                                            style: D.tableCell,
                                            children: "Date"
                                        }), u.jsx("th", {
                                            style: D.tableCell,
                                            children: "Action"
                                        })]
                                    })
                                }), u.jsx("tbody", {
                                    children: Le.length === 0 ? u.jsx("tr", {
                                        children: u.jsx("td", {
                                            colSpan: 8,
                                            style: {
                                                textAlign: "center",
                                                padding: "20px",
                                                color: "#999"
                                            },
                                            children: "No orders found"
                                        })
                                    }) : Le.map(S => u.jsxs("tr", {
                                        style: D.tableRow,
                                        children: [u.jsx("td", {
                                            style: D.tableCell,
                                            children: u.jsx("input", {
                                                type: "checkbox",
                                                checked: h.has(S.id),
                                                onChange: () => z(S.id)
                                            })
                                        }), u.jsx("td", {
                                            style: D.tableCell,
                                            children: S.shortId
                                        }), u.jsx("td", {
                                            style: D.tableCell,
                                            children: S.customerPhone
                                        }), u.jsx("td", {
                                            style: D.tableCell,
                                            children: S.packageDetails
                                        }), u.jsxs("td", {
                                            style: D.tableCell,
                                            children: ["GH", S.packagePrice]
                                        }), u.jsx("td", {
                                            style: D.tableCell,
                                            children: u.jsxs("select", {
                                                value: S.status,
                                                onChange: R => V(S.id, R.target.value),
                                                style: {
                                                    ...D.statusSelect,
                                                    backgroundColor: S.status === "FULFILLED" ? "#28a745" : S.status === "PROCESSING" ? "#ffc107" : S.status === "PAID" ? "#007bff" : "#dc3545"
                                                },
                                                children: [u.jsx("option", {
                                                    value: "PAID",
                                                    children: "Paid"
                                                }), u.jsx("option", {
                                                    value: "PROCESSING",
                                                    children: "Processing"
                                                }), u.jsx("option", {
                                                    value: "FULFILLED",
                                                    children: "Fulfilled"
                                                }), u.jsx("option", {
                                                    value: "CANCELLED",
                                                    children: "Cancelled"
                                                })]
                                            })
                                        }), u.jsx("td", {
                                            style: D.tableCell,
                                            children: S.createdAt.toLocaleDateString()
                                        }), u.jsx("td", {
                                            style: D.tableCell,
                                            children: u.jsx("button", {
                                                onClick: () => V(S.id, "FULFILLED"),
                                                style: D.actionButton,
                                                children: ""
                                            })
                                        })]
                                    }, S.id))
                                })]
                            })
                        })
                    })
                })]
            }), e === "packages" && u.jsxs("div", {
                children: [u.jsxs(ve, {
                    style: D.card,
                    children: [u.jsx(Ze, {
                        children: u.jsx(et, {
                            children: "Add New Package"
                        })
                    }), u.jsxs(we, {
                        children: [u.jsxs("div", {
                            style: D.formGrid,
                            children: [u.jsxs("div", {
                                children: [u.jsx("label", {
                                    style: D.label,
                                    children: "Package Name"
                                }), u.jsx(Ie, {
                                    placeholder: "e.g., 1GB",
                                    value: g.name,
                                    onChange: S => m({
                                        ...g,
                                        name: S.target.value
                                    })
                                })]
                            }), u.jsxs("div", {
                                children: [u.jsx("label", {
                                    style: D.label,
                                    children: "Data (GB)"
                                }), u.jsx(Ie, {
                                    type: "number",
                                    placeholder: "e.g., 1",
                                    value: g.gb,
                                    onChange: S => m({
                                        ...g,
                                        gb: S.target.value
                                    })
                                })]
                            }), u.jsxs("div", {
                                children: [u.jsx("label", {
                                    style: D.label,
                                    children: "Price (GH)"
                                }), u.jsx(Ie, {
                                    type: "number",
                                    placeholder: "e.g., 2.5",
                                    value: g.price,
                                    onChange: S => m({
                                        ...g,
                                        price: S.target.value
                                    })
                                })]
                            })]
                        }), u.jsxs(se, {
                            onClick: he,
                            style: D.addButton,
                            children: [u.jsx(cm, {
                                size: 18,
                                style: {
                                    marginRight: "8px"
                                }
                            }), "Add Package"]
                        })]
                    })]
                }), u.jsxs(ve, {
                    style: D.card,
                    children: [u.jsx(Ze, {
                        children: u.jsx(et, {
                            children: "Manage Packages"
                        })
                    }), u.jsx(we, {
                        children: u.jsx("div", {
                            style: D.tableWrapper,
                            children: u.jsxs("table", {
                                style: D.table,
                                children: [u.jsx("thead", {
                                    children: u.jsxs("tr", {
                                        style: D.tableHeader,
                                        children: [u.jsx("th", {
                                            style: D.tableCell,
                                            children: "Package"
                                        }), u.jsx("th", {
                                            style: D.tableCell,
                                            children: "Data (GB)"
                                        }), u.jsx("th", {
                                            style: D.tableCell,
                                            children: "Price (GH)"
                                        }), u.jsx("th", {
                                            style: D.tableCell,
                                            children: "Status"
                                        }), u.jsx("th", {
                                            style: D.tableCell,
                                            children: "Action"
                                        })]
                                    })
                                }), u.jsx("tbody", {
                                    children: i.map(S => u.jsxs("tr", {
                                        style: D.tableRow,
                                        children: [u.jsx("td", {
                                            style: D.tableCell,
                                            children: S.packageName
                                        }), u.jsx("td", {
                                            style: D.tableCell,
                                            children: S.dataValueGB
                                        }), u.jsx("td", {
                                            style: D.tableCell,
                                            children: S.priceGHS
                                        }), u.jsx("td", {
                                            style: D.tableCell,
                                            children: u.jsx("button", {
                                                onClick: () => M(S.id),
                                                style: {
                                                    ...D.statusButton,
                                                    backgroundColor: S.isEnabled ? "#28a745" : "#dc3545"
                                                },
                                                children: S.isEnabled ? " Enabled" : " Disabled"
                                            })
                                        }), u.jsx("td", {
                                            style: D.tableCell,
                                            children: u.jsx("button", {
                                                onClick: () => Me(S.id),
                                                style: D.deleteButton,
                                                children: u.jsx(Ua, {
                                                    size: 16
                                                })
                                            })
                                        })]
                                    }, S.id))
                                })]
                            })
                        })
                    })]
                })]
            }), e === "settings" && u.jsxs(ve, {
                style: D.card,
                children: [u.jsx(Ze, {
                    children: u.jsx(et, {
                        children: "Platform Settings"
                    })
                }), u.jsx(we, {
                    children: u.jsxs("div", {
                        style: D.settingsForm,
                        children: [u.jsxs("div", {
                            children: [u.jsx("label", {
                                style: D.label,
                                children: "WhatsApp Link"
                            }), u.jsx(Ie, {
                                type: "url",
                                placeholder: "https://wa.link/...",
                                value: a.whatsAppLink,
                                onChange: S => l({
                                    ...a,
                                    whatsAppLink: S.target.value
                                })
                            })]
                        }), u.jsxs("div", {
                            children: [u.jsx("label", {
                                style: D.label,
                                children: "Transaction Charge (%)"
                            }), u.jsx(Ie, {
                                type: "number",
                                placeholder: "1.3",
                                value: a.transactionCharge,
                                onChange: S => l({
                                    ...a,
                                    transactionCharge: S.target.value
                                })
                            }), u.jsx("p", {
                                style: {
                                    fontSize: "0.8em",
                                    color: "#666",
                                    marginTop: "5px"
                                },
                                children: "Percentage charge added to each transaction"
                            })]
                        }), u.jsx(se, {
                            onClick: () => {
                                const S = {
                                    ...a
                                }
                                  , R = JSON.parse(localStorage.getItem("wirenetSettings") || "{}");
                                localStorage.setItem("wirenetSettings", JSON.stringify({
                                    ...R,
                                    whatsappLink: S.whatsAppLink
                                })),
                                localStorage.setItem("datagodSettings", JSON.stringify({
                                    transactionCharge: S.transactionCharge
                                })),
                                b(" Settings saved"),
                                setTimeout( () => b(""), 2e3)
                            }
                            ,
                            style: D.saveButton,
                            children: "Save Settings"
                        })]
                    })
                })]
            })]
        })]
    })
}
const D = {
    body: {
        fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
        margin: 0,
        padding: 0,
        backgroundColor: "#f4f4f9",
        color: "#333"
    },
    header: {
        backgroundColor: "white",
        boxShadow: "0 1px 3px rgba(0, 0, 0, 0.1)",
        position: "sticky",
        top: 0,
        zIndex: 40
    },
    headerContent: {
        maxWidth: "1400px",
        margin: "0 auto",
        padding: "16px 20px",
        display: "flex",
        alignItems: "center"
    },
    h1: {
        fontSize: "1.5em",
        fontWeight: "bold",
        color: "#ffcc00",
        margin: 0
    },
    main: {
        maxWidth: "1400px",
        margin: "0 auto",
        padding: "32px 20px"
    },
    message: {
        padding: "16px",
        borderRadius: "8px",
        marginBottom: "20px",
        fontWeight: "bold"
    },
    tabs: {
        display: "flex",
        gap: "20px",
        marginBottom: "24px",
        borderBottom: "2px solid #ddd"
    },
    tab: {
        padding: "12px 20px",
        backgroundColor: "transparent",
        border: "none",
        cursor: "pointer",
        fontSize: "1em",
        color: "#666",
        transition: "all 0.3s"
    },
    card: {
        marginBottom: "24px",
        borderRadius: "8px",
        boxShadow: "0 1px 3px rgba(0, 0, 0, 0.1)"
    },
    filterSection: {
        display: "grid",
        gridTemplateColumns: "repeat(auto-fit, minmax(200px, 1fr))",
        gap: "16px",
        alignItems: "flex-end"
    },
    filterGroup: {
        display: "flex",
        flexDirection: "column"
    },
    label: {
        fontSize: "0.875em",
        fontWeight: "bold",
        marginBottom: "8px"
    },
    select: {
        padding: "8px",
        border: "1px solid #ddd",
        borderRadius: "4px",
        fontSize: "0.9em"
    },
    bulkButton: {
        backgroundColor: "#ffcc00",
        color: "#1a1a1a",
        fontWeight: "bold"
    },
    exportButton: {
        backgroundColor: "#007bff",
        color: "white",
        fontWeight: "bold"
    },
    tableWrapper: {
        overflowX: "auto"
    },
    table: {
        width: "100%",
        borderCollapse: "collapse"
    },
    tableHeader: {
        backgroundColor: "#f9f9f9",
        borderBottom: "2px solid #ddd"
    },
    tableRow: {
        borderBottom: "1px solid #ddd"
    },
    tableCell: {
        padding: "12px",
        textAlign: "left"
    },
    statusSelect: {
        padding: "6px 12px",
        color: "white",
        border: "none",
        borderRadius: "4px",
        cursor: "pointer",
        fontSize: "0.875em",
        fontWeight: "bold"
    },
    statusButton: {
        padding: "6px 12px",
        color: "white",
        border: "none",
        borderRadius: "4px",
        cursor: "pointer",
        fontSize: "0.875em",
        fontWeight: "bold"
    },
    deleteButton: {
        padding: "6px 12px",
        backgroundColor: "#dc3545",
        color: "white",
        border: "none",
        borderRadius: "4px",
        cursor: "pointer"
    },
    actionButton: {
        padding: "6px 12px",
        backgroundColor: "#28a745",
        color: "white",
        border: "none",
        borderRadius: "4px",
        cursor: "pointer"
    },
    formGrid: {
        display: "grid",
        gridTemplateColumns: "repeat(auto-fit, minmax(150px, 1fr))",
        gap: "16px",
        marginBottom: "16px"
    },
    addButton: {
        backgroundColor: "#ffcc00",
        color: "#1a1a1a",
        fontWeight: "bold"
    },
    settingsForm: {
        display: "flex",
        flexDirection: "column",
        gap: "16px"
    },
    saveButton: {
        backgroundColor: "#ffcc00",
        color: "#1a1a1a",
        fontWeight: "bold",
        width: "fit-content"
    }
};
function VS() {
    const [,t] = Rn()
      , [e,r] = j.useState("dashboard")
      , [n,s] = j.useState([])
      , [i,o] = j.useState([])
      , [a,l] = j.useState({
        amount: "",
        price: "",
        delivery: ""
    })
      , [c,d] = j.useState("")
      , [h,f] = j.useState("ALL")
      , [p,v] = j.useState(new Set)
      , [w,b] = j.useState("")
      , [g,m] = j.useState("dataxpress")
      , [y,x] = j.useState(null)
      , [k,C] = j.useState(!1)
      , [T,I] = j.useState({
        dataxpress: {
            balance: "...",
            currency: ""
        },
        hubnet: {
            balance: "...",
            currency: ""
        },
        dakazina: {
            balance: "...",
            currency: ""
        }
    })
      , [z,N] = j.useState({
        transactionCharge: "1.3"
    });
    j.useEffect( () => {
        V(),
        he(),
        Me(),
        Z()
    }
    , []);
    const Z = async () => {
        var E, Q, J;
        try {
            const An = await fetch("/api/fastnet/balances");
            if (An.ok) {
                const Mt = await An.json()
                  , Ha = qa => {
                    if (!qa || !qa.success)
                        return "Error";
                    const gd = parseFloat(qa.balance);
                    return isNaN(gd) ? "0.00" : gd.toFixed(2)
                }
                ;
                I({
                    dataxpress: {
                        balance: Ha(Mt.dataxpress),
                        currency: ((E = Mt.dataxpress) == null ? void 0 : E.currency) || "GH"
                    },
                    hubnet: {
                        balance: Ha(Mt.hubnet),
                        currency: ((Q = Mt.hubnet) == null ? void 0 : Q.currency) || "GH"
                    },
                    dakazina: {
                        balance: Ha(Mt.dakazina),
                        currency: ((J = Mt.dakazina) == null ? void 0 : J.currency) || "GH"
                    }
                })
            }
        } catch (An) {
            console.error("Error fetching wallet balances:", An)
        }
    }
      , V = async () => {
        try {
            const E = await fetch("/api/fastnet/orders");
            if (E.ok) {
                const Q = await E.json();
                s(Q.map(J => ({
                    ...J,
                    id: String(J.id),
                    shortId: J.shortId || J.short_id,
                    customerPhone: J.customerPhone || J.customer_phone,
                    packageDetails: J.packageDetails || J.package_details,
                    packagePrice: J.packagePrice || J.package_price,
                    supplierUsed: J.supplierUsed || J.supplier_used,
                    createdAt: new Date(J.createdAt || J.created_at)
                })))
            } else
                E.status === 401 ? (console.log("Not authenticated - orders will be empty until login"),
                s([])) : (console.error("Failed to load orders from API"),
                s([]))
        } catch (E) {
            console.error("Error loading orders:", E),
            s([])
        }
    }
      , he = async () => {
        try {
            const E = await ri.getAll("fastnet");
            E && E.length > 0 ? o(E) : o([])
        } catch (E) {
            console.error("Error loading packages from Supabase:", E),
            o([])
        }
    }
      , Me = async () => {
        try {
            const E = localStorage.getItem("fastnetSettings");
            if (E) {
                const J = JSON.parse(E);
                N({
                    transactionCharge: J.transactionCharge || "1.3"
                })
            }
            const Q = await fetch("/api/fastnet/supplier", {
                credentials: "include"
            });
            if (Q.ok) {
                const J = await Q.json();
                J.supplier && m(J.supplier)
            }
        } catch (E) {
            console.error("Error loading settings:", E)
        }
    }
      , M = async E => {
        try {
            const Q = await fetch("/api/fastnet/supplier", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                credentials: "include",
                body: JSON.stringify({
                    supplier: E
                })
            });
            if (Q.ok)
                m(E),
                d(` Active supplier changed to ${E.toUpperCase()}`);
            else {
                const J = await Q.json();
                d(` Failed to change supplier: ${J.message || "Unknown error"}`)
            }
        } catch (Q) {
            console.error("Error changing supplier:", Q),
            d(" Failed to change supplier - network error")
        }
        setTimeout( () => d(""), 3e3)
    }
      , ne = () => {
        const E = JSON.parse(localStorage.getItem("fastnetSettings") || "{}");
        localStorage.setItem("fastnetSettings", JSON.stringify({
            ...E,
            transactionCharge: z.transactionCharge
        })),
        d(" Settings saved"),
        setTimeout( () => d(""), 2e3)
    }
      , Le = n.reduce( (E, Q) => E + (Q.packagePrice || 0), 0)
      , S = n.filter(E => E.status === "PROCESSING" || E.status === "PAID").length
      , R = n.filter(E => E.status === "FULFILLED").length
      , L = () => h === "ALL" ? n : n.filter(E => E.status === h)
      , O = E => {
        const Q = new Set(p);
        Q.has(E) ? Q.delete(E) : Q.add(E),
        v(Q)
    }
      , W = E => {
        v(E ? new Set(L().map(Q => Q.id)) : new Set)
    }
      , ie = async () => {
        if (!(p.size === 0 || !w))
            try {
                const E = Array.from(p).map(J => fetch(`/api/fastnet/orders/${J}`, {
                    method: "PATCH",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        status: w
                    })
                }));
                await Promise.all(E);
                const Q = n.map(J => p.has(J.id) ? {
                    ...J,
                    status: w
                } : J);
                s(Q),
                v(new Set),
                b(""),
                d(` ${p.size} orders updated`),
                setTimeout( () => d(""), 3e3)
            } catch (E) {
                console.error("Error updating orders:", E),
                d(" Failed to update orders"),
                setTimeout( () => d(""), 3e3)
            }
    }
      , ue = async (E, Q) => {
        try {
            if ((await fetch(`/api/fastnet/orders/${E}`, {
                method: "PATCH",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    status: Q
                })
            })).ok) {
                const An = n.map(Mt => Mt.id === E ? {
                    ...Mt,
                    status: Q
                } : Mt);
                s(An),
                d(" Order status updated")
            } else
                d(" Failed to update order");
            setTimeout( () => d(""), 2e3)
        } catch (J) {
            console.error("Error updating order:", J),
            d(" Failed to update order"),
            setTimeout( () => d(""), 2e3)
        }
    }
      , We = async E => {
        x(E);
        try {
            const Q = await fetch(`/api/fastnet/orders/${E}/check-status`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                }
            });
            if (Q.ok) {
                const J = await Q.json();
                J.success ? (d(` Status from ${J.supplier}: ${J.supplierStatus}`),
                await V()) : d(` ${J.message || "Could not check status"}`)
            } else {
                const J = await Q.json();
                d(` ${J.message || "Failed to check status"}`)
            }
        } catch (Q) {
            console.error("Error checking order status:", Q),
            d(" Failed to check order status")
        } finally {
            x(null),
            setTimeout( () => d(""), 3e3)
        }
    }
      , Ge = async () => {
        C(!0);
        try {
            const E = await fetch("/api/fastnet/orders/refresh-all-statuses", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                }
            });
            if (E.ok) {
                const Q = await E.json();
                d(` ${Q.message}`),
                await V()
            } else {
                const Q = await E.json();
                d(` ${Q.message || "Failed to refresh statuses"}`)
            }
        } catch (E) {
            console.error("Error refreshing all statuses:", E),
            d(" Failed to refresh all statuses")
        } finally {
            C(!1),
            setTimeout( () => d(""), 3e3)
        }
    }
      , zt = async () => {
        if (!a.amount || !a.price || !a.delivery) {
            d(" Please fill all fields");
            return
        }
        try {
            const E = parseInt(a.amount.replace(/\D/g, ""));
            await ri.create({
                category: "fastnet",
                data_amount: E,
                price: parseFloat(a.price),
                delivery_time: a.delivery,
                enabled: !0
            }),
            await he(),
            l({
                amount: "",
                price: "",
                delivery: ""
            }),
            d(" Package added"),
            setTimeout( () => d(""), 2e3)
        } catch (E) {
            console.error("Error adding package:", E),
            d(" Failed to add package"),
            setTimeout( () => d(""), 2e3)
        }
    }
      , My = async E => {
        try {
            await ri.delete(E),
            await he(),
            d(" Package deleted"),
            setTimeout( () => d(""), 2e3)
        } catch (Q) {
            console.error("Error deleting package:", Q),
            d(" Failed to delete package"),
            setTimeout( () => d(""), 2e3)
        }
    }
      , Wy = async E => {
        try {
            const Q = i.find(J => J.id === E);
            Q && (await ri.toggle(E, !Q.isEnabled),
            await he())
        } catch (Q) {
            console.error("Error toggling package:", Q),
            d(" Failed to update package"),
            setTimeout( () => d(""), 2e3)
        }
    }
      , Va = L();
    return u.jsxs("div", {
        style: P.body,
        children: [u.jsx("header", {
            style: P.header,
            children: u.jsxs("div", {
                style: P.headerContent,
                children: [u.jsxs(se, {
                    variant: "ghost",
                    size: "sm",
                    onClick: () => t("/admin"),
                    style: {
                        marginRight: "16px"
                    },
                    children: [u.jsx($a, {
                        size: 18,
                        style: {
                            marginRight: "8px"
                        }
                    }), " Back"]
                }), u.jsx("h1", {
                    style: P.h1,
                    children: "FastNet Admin Dashboard"
                }), u.jsxs("div", {
                    style: P.activeSupplierBadge,
                    children: ["Active: ", g.toUpperCase()]
                })]
            })
        }), u.jsxs("main", {
            style: P.main,
            children: [c && u.jsx("div", {
                style: {
                    ...P.message,
                    backgroundColor: c.includes("") ? "#d4edda" : "#f8d7da",
                    color: c.includes("") ? "#155724" : "#721c24"
                },
                children: c
            }), u.jsx("div", {
                style: P.tabs,
                children: ["dashboard", "orders", "packages", "settings"].map(E => u.jsx("button", {
                    onClick: () => r(E),
                    style: {
                        ...P.tab,
                        borderBottom: e === E ? "3px solid #007bff" : "none",
                        fontWeight: e === E ? "bold" : "normal",
                        color: e === E ? "#007bff" : "#666"
                    },
                    children: E.charAt(0).toUpperCase() + E.slice(1)
                }, E))
            }), e === "dashboard" && u.jsxs("div", {
                style: P.dashboardGrid,
                children: [u.jsx(ve, {
                    style: P.statCard,
                    children: u.jsxs(we, {
                        style: P.statContent,
                        children: [u.jsxs("div", {
                            children: [u.jsx("p", {
                                style: P.statLabel,
                                children: "Total Orders"
                            }), u.jsx("p", {
                                style: P.statValue,
                                children: n.length
                            })]
                        }), u.jsx(ua, {
                            size: 24,
                            color: "#007bff"
                        })]
                    })
                }), u.jsx(ve, {
                    style: P.statCard,
                    children: u.jsxs(we, {
                        style: P.statContent,
                        children: [u.jsxs("div", {
                            children: [u.jsx("p", {
                                style: P.statLabel,
                                children: "Total Revenue"
                            }), u.jsxs("p", {
                                style: P.statValue,
                                children: ["GH", Le.toFixed(2)]
                            })]
                        }), u.jsx(Db, {
                            size: 24,
                            color: "#28a745"
                        })]
                    })
                }), u.jsx(ve, {
                    style: P.statCard,
                    children: u.jsxs(we, {
                        style: P.statContent,
                        children: [u.jsxs("div", {
                            children: [u.jsx("p", {
                                style: P.statLabel,
                                children: "Pending"
                            }), u.jsx("p", {
                                style: P.statValue,
                                children: S
                            })]
                        }), u.jsx(Nb, {
                            size: 24,
                            color: "#ffc107"
                        })]
                    })
                }), u.jsx(ve, {
                    style: P.statCard,
                    children: u.jsxs(we, {
                        style: P.statContent,
                        children: [u.jsxs("div", {
                            children: [u.jsx("p", {
                                style: P.statLabel,
                                children: "Completed"
                            }), u.jsx("p", {
                                style: P.statValue,
                                children: R
                            })]
                        }), u.jsx(Ib, {
                            size: 24,
                            color: "#28a745"
                        })]
                    })
                })]
            }), e === "orders" && u.jsxs("div", {
                children: [u.jsxs(ve, {
                    style: P.card,
                    children: [u.jsx(Ze, {
                        children: u.jsx(et, {
                            children: "Order Management"
                        })
                    }), u.jsx(we, {
                        children: u.jsxs("div", {
                            style: P.filterSection,
                            children: [u.jsxs("div", {
                                style: P.filterGroup,
                                children: [u.jsx("label", {
                                    style: P.label,
                                    children: "Filter Status:"
                                }), u.jsxs("select", {
                                    value: h,
                                    onChange: E => f(E.target.value),
                                    style: P.select,
                                    children: [u.jsx("option", {
                                        value: "ALL",
                                        children: "All"
                                    }), u.jsx("option", {
                                        value: "PAID",
                                        children: "Paid"
                                    }), u.jsx("option", {
                                        value: "PROCESSING",
                                        children: "Processing"
                                    }), u.jsx("option", {
                                        value: "FULFILLED",
                                        children: "Fulfilled"
                                    }), u.jsx("option", {
                                        value: "CANCELLED",
                                        children: "Cancelled"
                                    })]
                                })]
                            }), u.jsxs("div", {
                                style: P.filterGroup,
                                children: [u.jsx("label", {
                                    style: P.label,
                                    children: "Bulk Action:"
                                }), u.jsxs("select", {
                                    value: w,
                                    onChange: E => b(E.target.value),
                                    style: P.select,
                                    children: [u.jsx("option", {
                                        value: "",
                                        children: "Select Status"
                                    }), u.jsx("option", {
                                        value: "PAID",
                                        children: "Paid"
                                    }), u.jsx("option", {
                                        value: "PROCESSING",
                                        children: "Processing"
                                    }), u.jsx("option", {
                                        value: "FULFILLED",
                                        children: "Fulfilled"
                                    }), u.jsx("option", {
                                        value: "CANCELLED",
                                        children: "Cancelled"
                                    })]
                                })]
                            }), u.jsxs(se, {
                                onClick: ie,
                                style: P.bulkButton,
                                children: ["Update (", p.size, ")"]
                            }), u.jsxs(se, {
                                onClick: Ge,
                                disabled: k,
                                style: {
                                    ...P.bulkButton,
                                    marginLeft: "10px",
                                    backgroundColor: "#17a2b8"
                                },
                                children: [u.jsx($b, {
                                    size: 16,
                                    style: {
                                        marginRight: "6px"
                                    },
                                    className: k ? "animate-spin" : ""
                                }), k ? "Refreshing..." : "Refresh All Statuses"]
                            })]
                        })
                    })]
                }), u.jsx(ve, {
                    style: P.card,
                    children: u.jsx(we, {
                        style: {
                            padding: "20px"
                        },
                        children: u.jsx("div", {
                            style: P.tableWrapper,
                            children: u.jsxs("table", {
                                style: P.table,
                                children: [u.jsx("thead", {
                                    children: u.jsxs("tr", {
                                        style: P.tableHeader,
                                        children: [u.jsx("th", {
                                            style: P.tableCell,
                                            children: u.jsx("input", {
                                                type: "checkbox",
                                                checked: p.size === Va.length && Va.length > 0,
                                                onChange: E => W(E.target.checked)
                                            })
                                        }), u.jsx("th", {
                                            style: P.tableCell,
                                            children: "Order ID"
                                        }), u.jsx("th", {
                                            style: P.tableCell,
                                            children: "Phone"
                                        }), u.jsx("th", {
                                            style: P.tableCell,
                                            children: "Package"
                                        }), u.jsx("th", {
                                            style: P.tableCell,
                                            children: "Price"
                                        }), u.jsx("th", {
                                            style: P.tableCell,
                                            children: "Status"
                                        }), u.jsx("th", {
                                            style: P.tableCell,
                                            children: "Supplier"
                                        }), u.jsx("th", {
                                            style: P.tableCell,
                                            children: "Date"
                                        }), u.jsx("th", {
                                            style: P.tableCell,
                                            children: "Actions"
                                        })]
                                    })
                                }), u.jsx("tbody", {
                                    children: Va.map(E => u.jsxs("tr", {
                                        style: P.tableRow,
                                        children: [u.jsx("td", {
                                            style: P.tableCell,
                                            children: u.jsx("input", {
                                                type: "checkbox",
                                                checked: p.has(E.id),
                                                onChange: () => O(E.id)
                                            })
                                        }), u.jsx("td", {
                                            style: P.tableCell,
                                            children: E.shortId
                                        }), u.jsx("td", {
                                            style: P.tableCell,
                                            children: E.customerPhone
                                        }), u.jsx("td", {
                                            style: P.tableCell,
                                            children: E.packageDetails
                                        }), u.jsxs("td", {
                                            style: P.tableCell,
                                            children: ["GH", E.packagePrice]
                                        }), u.jsx("td", {
                                            style: P.tableCell,
                                            children: u.jsxs("select", {
                                                value: E.status,
                                                onChange: Q => ue(E.id, Q.target.value),
                                                style: {
                                                    ...P.statusSelect,
                                                    backgroundColor: E.status === "FULFILLED" ? "#28a745" : E.status === "PROCESSING" ? "#ffc107" : E.status === "FAILED" ? "#dc3545" : "#007bff"
                                                },
                                                children: [u.jsx("option", {
                                                    value: "PAID",
                                                    children: "Paid"
                                                }), u.jsx("option", {
                                                    value: "PROCESSING",
                                                    children: "Processing"
                                                }), u.jsx("option", {
                                                    value: "FULFILLED",
                                                    children: "Fulfilled"
                                                }), u.jsx("option", {
                                                    value: "FAILED",
                                                    children: "Failed"
                                                }), u.jsx("option", {
                                                    value: "CANCELLED",
                                                    children: "Cancelled"
                                                })]
                                            })
                                        }), u.jsx("td", {
                                            style: P.tableCell,
                                            children: E.supplierUsed ? E.supplierUsed.toUpperCase() : "-"
                                        }), u.jsx("td", {
                                            style: P.tableCell,
                                            children: E.createdAt.toLocaleDateString()
                                        }), u.jsx("td", {
                                            style: P.tableCell,
                                            children: u.jsxs("div", {
                                                style: {
                                                    display: "flex",
                                                    gap: "5px"
                                                },
                                                children: [u.jsx("button", {
                                                    onClick: () => ue(E.id, "FULFILLED"),
                                                    style: P.actionButton,
                                                    title: "Mark Fulfilled",
                                                    children: ""
                                                }), E.supplierUsed && E.supplierUsed !== "hubnet" && (E.status === "PROCESSING" || E.status === "PAID") && u.jsx("button", {
                                                    onClick: () => We(E.id),
                                                    disabled: y === E.id,
                                                    style: {
                                                        ...P.actionButton,
                                                        backgroundColor: "#17a2b8"
                                                    },
                                                    title: "Check Status from Supplier",
                                                    children: y === E.id ? "..." : u.jsx(Ub, {
                                                        size: 14
                                                    })
                                                })]
                                            })
                                        })]
                                    }, E.id))
                                })]
                            })
                        })
                    })
                })]
            }), e === "packages" && u.jsxs("div", {
                children: [u.jsxs(ve, {
                    style: P.card,
                    children: [u.jsx(Ze, {
                        children: u.jsx(et, {
                            children: "Add Package"
                        })
                    }), u.jsxs(we, {
                        children: [u.jsxs("div", {
                            style: P.formGrid,
                            children: [u.jsxs("div", {
                                children: [u.jsx("label", {
                                    style: P.label,
                                    children: "Amount"
                                }), u.jsx(Ie, {
                                    placeholder: "e.g. 1GB",
                                    value: a.amount,
                                    onChange: E => l({
                                        ...a,
                                        amount: E.target.value
                                    })
                                })]
                            }), u.jsxs("div", {
                                children: [u.jsx("label", {
                                    style: P.label,
                                    children: "Price"
                                }), u.jsx(Ie, {
                                    type: "number",
                                    placeholder: "e.g. 5",
                                    value: a.price,
                                    onChange: E => l({
                                        ...a,
                                        price: E.target.value
                                    })
                                })]
                            }), u.jsxs("div", {
                                children: [u.jsx("label", {
                                    style: P.label,
                                    children: "Delivery"
                                }), u.jsx(Ie, {
                                    placeholder: "e.g. 5-10 mins",
                                    value: a.delivery,
                                    onChange: E => l({
                                        ...a,
                                        delivery: E.target.value
                                    })
                                })]
                            })]
                        }), u.jsxs(se, {
                            onClick: zt,
                            style: P.addButton,
                            children: [u.jsx(cm, {
                                size: 18,
                                style: {
                                    marginRight: "8px"
                                }
                            }), " Add"]
                        })]
                    })]
                }), u.jsx(ve, {
                    style: P.card,
                    children: u.jsx(we, {
                        children: u.jsx("div", {
                            style: P.tableWrapper,
                            children: u.jsxs("table", {
                                style: P.table,
                                children: [u.jsx("thead", {
                                    children: u.jsxs("tr", {
                                        style: P.tableHeader,
                                        children: [u.jsx("th", {
                                            style: P.tableCell,
                                            children: "Amount"
                                        }), u.jsx("th", {
                                            style: P.tableCell,
                                            children: "Price"
                                        }), u.jsx("th", {
                                            style: P.tableCell,
                                            children: "Delivery"
                                        }), u.jsx("th", {
                                            style: P.tableCell,
                                            children: "Status"
                                        }), u.jsx("th", {
                                            style: P.tableCell,
                                            children: "Action"
                                        })]
                                    })
                                }), u.jsx("tbody", {
                                    children: i.map(E => u.jsxs("tr", {
                                        style: P.tableRow,
                                        children: [u.jsx("td", {
                                            style: P.tableCell,
                                            children: E.dataAmount
                                        }), u.jsxs("td", {
                                            style: P.tableCell,
                                            children: ["GH", E.price]
                                        }), u.jsx("td", {
                                            style: P.tableCell,
                                            children: E.deliveryTime
                                        }), u.jsx("td", {
                                            style: P.tableCell,
                                            children: u.jsx("button", {
                                                onClick: () => Wy(E.id),
                                                style: {
                                                    ...P.statusButton,
                                                    backgroundColor: E.isEnabled ? "#28a745" : "#dc3545"
                                                },
                                                children: E.isEnabled ? "Enabled" : "Disabled"
                                            })
                                        }), u.jsx("td", {
                                            style: P.tableCell,
                                            children: u.jsx("button", {
                                                onClick: () => My(E.id),
                                                style: P.deleteButton,
                                                children: u.jsx(Ua, {
                                                    size: 16
                                                })
                                            })
                                        })]
                                    }, E.id))
                                })]
                            })
                        })
                    })
                })]
            }), e === "settings" && u.jsxs("div", {
                style: P.dashboardGrid,
                children: [u.jsxs(ve, {
                    style: P.card,
                    children: [u.jsxs(Ze, {
                        children: [u.jsxs(et, {
                            className: "flex items-center gap-2",
                            children: [u.jsx(Du, {
                                size: 20
                            }), "Supplier Management"]
                        }), u.jsx(Mr, {
                            children: "Select active supplier for order fulfillment"
                        })]
                    }), u.jsx(we, {
                        children: u.jsx("div", {
                            style: P.supplierGrid,
                            children: ["dataxpress", "hubnet", "dakazina"].map(E => u.jsxs("div", {
                                onClick: () => M(E),
                                style: {
                                    ...P.supplierCard,
                                    borderColor: g === E ? "#007bff" : "#ddd",
                                    backgroundColor: g === E ? "#f0f7ff" : "white"
                                },
                                children: [u.jsxs("div", {
                                    style: P.supplierHeader,
                                    children: [u.jsx("span", {
                                        style: P.supplierName,
                                        children: E.charAt(0).toUpperCase() + E.slice(1)
                                    }), g === E && u.jsx("span", {
                                        style: P.activeBadge,
                                        children: "ACTIVE"
                                    })]
                                }), u.jsxs("div", {
                                    style: P.balanceInfo,
                                    children: [u.jsx("span", {
                                        children: "Balance:"
                                    }), u.jsxs("span", {
                                        style: P.balanceValue,
                                        children: [T[E].currency, " ", T[E].balance]
                                    })]
                                })]
                            }, E))
                        })
                    })]
                }), u.jsxs(ve, {
                    style: P.card,
                    children: [u.jsx(Ze, {
                        children: u.jsx(et, {
                            children: "Transaction Settings"
                        })
                    }), u.jsx(we, {
                        children: u.jsxs("div", {
                            style: P.settingsForm,
                            children: [u.jsxs("div", {
                                children: [u.jsx("label", {
                                    style: P.label,
                                    children: "Transaction Charge (%)"
                                }), u.jsx(Ie, {
                                    type: "number",
                                    placeholder: "1.3",
                                    value: z.transactionCharge,
                                    onChange: E => N({
                                        ...z,
                                        transactionCharge: E.target.value
                                    })
                                }), u.jsx("p", {
                                    style: {
                                        fontSize: "0.8em",
                                        color: "#666",
                                        marginTop: "5px"
                                    },
                                    children: "Percentage charge added to each transaction"
                                })]
                            }), u.jsx(se, {
                                onClick: ne,
                                style: P.saveButton,
                                children: "Save Settings"
                            })]
                        })
                    })]
                })]
            })]
        })]
    })
}
const P = {
    body: {
        fontFamily: "'Segoe UI', sans-serif",
        backgroundColor: "#f0f4f8",
        minHeight: "100vh",
        color: "#333"
    },
    header: {
        backgroundColor: "white",
        boxShadow: "0 1px 3px rgba(0,0,0,0.1)",
        position: "sticky",
        top: 0,
        zIndex: 40
    },
    headerContent: {
        maxWidth: "1400px",
        margin: "0 auto",
        padding: "16px 20px",
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between"
    },
    h1: {
        fontSize: "1.5em",
        fontWeight: "bold",
        color: "#007bff",
        margin: 0
    },
    activeSupplierBadge: {
        backgroundColor: "#e6f7ff",
        color: "#007bff",
        padding: "4px 12px",
        borderRadius: "20px",
        fontSize: "0.85em",
        fontWeight: "bold",
        border: "1px solid #b3e0ff"
    },
    main: {
        maxWidth: "1400px",
        margin: "0 auto",
        padding: "32px 20px"
    },
    message: {
        padding: "16px",
        borderRadius: "8px",
        marginBottom: "20px",
        fontWeight: "bold"
    },
    tabs: {
        display: "flex",
        gap: "20px",
        marginBottom: "24px",
        borderBottom: "2px solid #ddd"
    },
    tab: {
        padding: "12px 20px",
        backgroundColor: "transparent",
        border: "none",
        cursor: "pointer",
        fontSize: "1em",
        transition: "all 0.3s"
    },
    dashboardGrid: {
        display: "grid",
        gridTemplateColumns: "repeat(auto-fit, minmax(250px, 1fr))",
        gap: "20px",
        marginBottom: "30px"
    },
    statCard: {
        borderRadius: "8px",
        boxShadow: "0 1px 3px rgba(0,0,0,0.1)"
    },
    statContent: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        padding: "20px"
    },
    statLabel: {
        color: "#666",
        fontSize: "0.9em"
    },
    statValue: {
        fontSize: "1.8em",
        fontWeight: "bold",
        color: "#333"
    },
    card: {
        marginBottom: "24px",
        borderRadius: "8px",
        boxShadow: "0 1px 3px rgba(0,0,0,0.1)"
    },
    filterSection: {
        display: "grid",
        gridTemplateColumns: "repeat(auto-fit, minmax(200px, 1fr))",
        gap: "16px",
        alignItems: "flex-end"
    },
    filterGroup: {
        display: "flex",
        flexDirection: "column",
        gap: "8px"
    },
    label: {
        fontSize: "0.875em",
        fontWeight: "bold"
    },
    select: {
        padding: "8px",
        border: "1px solid #ddd",
        borderRadius: "4px"
    },
    bulkButton: {
        backgroundColor: "#007bff",
        color: "white",
        fontWeight: "bold"
    },
    tableWrapper: {
        overflowX: "auto"
    },
    table: {
        width: "100%",
        borderCollapse: "collapse"
    },
    tableHeader: {
        backgroundColor: "#f9f9f9",
        borderBottom: "2px solid #ddd"
    },
    tableRow: {
        borderBottom: "1px solid #ddd"
    },
    tableCell: {
        padding: "12px",
        textAlign: "left"
    },
    statusSelect: {
        padding: "6px 12px",
        color: "white",
        border: "none",
        borderRadius: "4px",
        cursor: "pointer",
        fontSize: "0.875em",
        fontWeight: "bold"
    },
    statusButton: {
        padding: "6px 12px",
        color: "white",
        border: "none",
        borderRadius: "4px",
        cursor: "pointer",
        fontSize: "0.875em",
        fontWeight: "bold"
    },
    deleteButton: {
        padding: "6px 12px",
        backgroundColor: "#dc3545",
        color: "white",
        border: "none",
        borderRadius: "4px",
        cursor: "pointer"
    },
    actionButton: {
        padding: "6px 12px",
        backgroundColor: "#28a745",
        color: "white",
        border: "none",
        borderRadius: "4px",
        cursor: "pointer"
    },
    formGrid: {
        display: "grid",
        gridTemplateColumns: "repeat(auto-fit, minmax(150px, 1fr))",
        gap: "16px",
        marginBottom: "16px"
    },
    addButton: {
        backgroundColor: "#007bff",
        color: "white",
        fontWeight: "bold"
    },
    supplierGrid: {
        display: "grid",
        gridTemplateColumns: "repeat(auto-fit, minmax(250px, 1fr))",
        gap: "20px"
    },
    supplierCard: {
        padding: "20px",
        borderRadius: "8px",
        border: "2px solid #ddd",
        cursor: "pointer",
        transition: "all 0.2s"
    },
    supplierHeader: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        marginBottom: "15px"
    },
    supplierName: {
        fontSize: "1.2em",
        fontWeight: "bold",
        color: "#333"
    },
    activeBadge: {
        backgroundColor: "#28a745",
        color: "white",
        padding: "4px 8px",
        borderRadius: "4px",
        fontSize: "0.75em",
        fontWeight: "bold"
    },
    balanceInfo: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        color: "#666"
    },
    balanceValue: {
        fontWeight: "bold",
        color: "#333",
        fontSize: "1.1em"
    },
    settingsForm: {
        display: "flex",
        flexDirection: "column",
        gap: "16px"
    },
    saveButton: {
        backgroundColor: "#007bff",
        color: "white",
        fontWeight: "bold",
        width: "fit-content"
    }
};
function HS() {
    const {data: t, isLoading: e, error: r} = Tb({
        queryKey: ["auth"],
        queryFn: async () => {
            try {
                const n = await fetch("/api/auth/user");
                return n.ok ? n.json() : null
            } catch {
                return null
            }
        }
    });
    return {
        user: t || null,
        isLoading: e,
        isAuthenticated: !!t,
        error: r
    }
}
const qS = new pb;
function KS() {
    const {isLoading: t} = HS();
    return t ? u.jsx("div", {
        className: "flex items-center justify-center min-h-screen",
        children: u.jsxs("div", {
            className: "text-center",
            children: [u.jsx("div", {
                className: "animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto mb-4"
            }), u.jsx("p", {
                className: "text-muted-foreground",
                children: "Loading..."
            })]
        })
    }) : u.jsxs(Xg, {
        children: [u.jsx(Jr, {
            path: "/",
            component: bx
        }), u.jsx(Jr, {
            path: "/admin/login",
            component: _x
        }), u.jsx(Jr, {
            path: "/admin",
            component: xx
        }), u.jsx(Jr, {
            path: "/datagod",
            component: Sx
        }), u.jsx(Jr, {
            path: "/fastnet",
            component: WS
        }), u.jsx(Jr, {
            path: "/admin/datagod",
            component: GS
        }), u.jsx(Jr, {
            path: "/admin/fastnet",
            component: VS
        })]
    })
}
function QS() {
    return u.jsxs(mb, {
        client: qS,
        children: [u.jsx(KS, {}), u.jsx(Pb, {})]
    })
}
Pl.createRoot(document.getElementById("root")).render(u.jsx(Ff.StrictMode, {
    children: u.jsx(QS, {})
}));
